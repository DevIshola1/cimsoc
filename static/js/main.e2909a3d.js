/*! For license information please see main.e2909a3d.js.LICENSE.txt */
(() => {
    var e = {
            2943: e => {
                "use strict";
                for (var t = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {}, r = 0; r < 32; r++) {
                    var i = t.charAt(r);
                    if (void 0 !== n[i]) throw new TypeError(i + " is ambiguous");
                    n[i] = r
                }

                function o(e) {
                    var t = e >> 25;
                    return (33554431 & e) << 5 ^ 996825010 & -(1 & t) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1)
                }

                function s(e) {
                    for (var t = 1, n = 0; n < e.length; ++n) {
                        var r = e.charCodeAt(n);
                        if (r < 33 || r > 126) return "Invalid prefix (" + e + ")";
                        t = o(t) ^ r >> 5
                    }
                    for (t = o(t), n = 0; n < e.length; ++n) {
                        var i = e.charCodeAt(n);
                        t = o(t) ^ 31 & i
                    }
                    return t
                }

                function a(e, t) {
                    if (t = t || 90, e.length < 8) return e + " too short";
                    if (e.length > t) return "Exceeds length limit";
                    var r = e.toLowerCase(),
                        i = e.toUpperCase();
                    if (e !== r && e !== i) return "Mixed-case string " + e;
                    var a = (e = r).lastIndexOf("1");
                    if (-1 === a) return "No separator character for " + e;
                    if (0 === a) return "Missing prefix for " + e;
                    var l = e.slice(0, a),
                        u = e.slice(a + 1);
                    if (u.length < 6) return "Data too short";
                    var c = s(l);
                    if ("string" === typeof c) return c;
                    for (var d = [], h = 0; h < u.length; ++h) {
                        var f = u.charAt(h),
                            p = n[f];
                        if (void 0 === p) return "Unknown character " + f;
                        c = o(c) ^ p, h + 6 >= u.length || d.push(p)
                    }
                    return 1 !== c ? "Invalid checksum for " + e : {
                        prefix: l,
                        words: d
                    }
                }

                function l(e, t, n, r) {
                    for (var i = 0, o = 0, s = (1 << n) - 1, a = [], l = 0; l < e.length; ++l)
                        for (i = i << t | e[l], o += t; o >= n;) o -= n, a.push(i >> o & s);
                    if (r) o > 0 && a.push(i << n - o & s);
                    else {
                        if (o >= t) return "Excess padding";
                        if (i << n - o & s) return "Non-zero padding"
                    }
                    return a
                }
                e.exports = {
                    decodeUnsafe: function() {
                        var e = a.apply(null, arguments);
                        if ("object" === typeof e) return e
                    },
                    decode: function(e) {
                        var t = a.apply(null, arguments);
                        if ("object" === typeof t) return t;
                        throw new Error(t)
                    },
                    encode: function(e, n, r) {
                        if (r = r || 90, e.length + 7 + n.length > r) throw new TypeError("Exceeds length limit");
                        var i = s(e = e.toLowerCase());
                        if ("string" === typeof i) throw new Error(i);
                        for (var a = e + "1", l = 0; l < n.length; ++l) {
                            var u = n[l];
                            if (u >> 5 !== 0) throw new Error("Non 5-bit word");
                            i = o(i) ^ u, a += t.charAt(u)
                        }
                        for (l = 0; l < 6; ++l) i = o(i);
                        for (i ^= 1, l = 0; l < 6; ++l) {
                            a += t.charAt(i >> 5 * (5 - l) & 31)
                        }
                        return a
                    },
                    toWordsUnsafe: function(e) {
                        var t = l(e, 8, 5, !0);
                        if (Array.isArray(t)) return t
                    },
                    toWords: function(e) {
                        var t = l(e, 8, 5, !0);
                        if (Array.isArray(t)) return t;
                        throw new Error(t)
                    },
                    fromWordsUnsafe: function(e) {
                        var t = l(e, 5, 8, !1);
                        if (Array.isArray(t)) return t
                    },
                    fromWords: function(e) {
                        var t = l(e, 5, 8, !1);
                        if (Array.isArray(t)) return t;
                        throw new Error(t)
                    }
                }
            },
            6373: function(e, t, n) {
                ! function(e, t) {
                    "use strict";

                    function r(e, t) {
                        if (!e) throw new Error(t || "Assertion failed")
                    }

                    function i(e, t) {
                        e.super_ = t;
                        var n = function() {};
                        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
                    }

                    function o(e, t, n) {
                        if (o.isBN(e)) return e;
                        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e && ("le" !== t && "be" !== t || (n = t, t = 10), this._init(e || 0, t || 10, n || "be"))
                    }
                    var s;
                    "object" === typeof e ? e.exports = o : t.BN = o, o.BN = o, o.wordSize = 26;
                    try {
                        s = "undefined" !== typeof window && "undefined" !== typeof window.Buffer ? window.Buffer : n(7790).Buffer
                    } catch (_) {}

                    function a(e, t) {
                        var n = e.charCodeAt(t);
                        return n >= 48 && n <= 57 ? n - 48 : n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : void r(!1, "Invalid character in " + e)
                    }

                    function l(e, t, n) {
                        var r = a(e, n);
                        return n - 1 >= t && (r |= a(e, n - 1) << 4), r
                    }

                    function u(e, t, n, i) {
                        for (var o = 0, s = 0, a = Math.min(e.length, n), l = t; l < a; l++) {
                            var u = e.charCodeAt(l) - 48;
                            o *= i, s = u >= 49 ? u - 49 + 10 : u >= 17 ? u - 17 + 10 : u, r(u >= 0 && s < i, "Invalid character"), o += s
                        }
                        return o
                    }

                    function c(e, t) {
                        e.words = t.words, e.length = t.length, e.negative = t.negative, e.red = t.red
                    }
                    if (o.isBN = function(e) {
                            return e instanceof o || null !== e && "object" === typeof e && e.constructor.wordSize === o.wordSize && Array.isArray(e.words)
                        }, o.max = function(e, t) {
                            return e.cmp(t) > 0 ? e : t
                        }, o.min = function(e, t) {
                            return e.cmp(t) < 0 ? e : t
                        }, o.prototype._init = function(e, t, n) {
                            if ("number" === typeof e) return this._initNumber(e, t, n);
                            if ("object" === typeof e) return this._initArray(e, t, n);
                            "hex" === t && (t = 16), r(t === (0 | t) && t >= 2 && t <= 36);
                            var i = 0;
                            "-" === (e = e.toString().replace(/\s+/g, ""))[0] && (i++, this.negative = 1), i < e.length && (16 === t ? this._parseHex(e, i, n) : (this._parseBase(e, t, i), "le" === n && this._initArray(this.toArray(), t, n)))
                        }, o.prototype._initNumber = function(e, t, n) {
                            e < 0 && (this.negative = 1, e = -e), e < 67108864 ? (this.words = [67108863 & e], this.length = 1) : e < 4503599627370496 ? (this.words = [67108863 & e, e / 67108864 & 67108863], this.length = 2) : (r(e < 9007199254740992), this.words = [67108863 & e, e / 67108864 & 67108863, 1], this.length = 3), "le" === n && this._initArray(this.toArray(), t, n)
                        }, o.prototype._initArray = function(e, t, n) {
                            if (r("number" === typeof e.length), e.length <= 0) return this.words = [0], this.length = 1, this;
                            this.length = Math.ceil(e.length / 3), this.words = new Array(this.length);
                            for (var i = 0; i < this.length; i++) this.words[i] = 0;
                            var o, s, a = 0;
                            if ("be" === n)
                                for (i = e.length - 1, o = 0; i >= 0; i -= 3) s = e[i] | e[i - 1] << 8 | e[i - 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
                            else if ("le" === n)
                                for (i = 0, o = 0; i < e.length; i += 3) s = e[i] | e[i + 1] << 8 | e[i + 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
                            return this._strip()
                        }, o.prototype._parseHex = function(e, t, n) {
                            this.length = Math.ceil((e.length - t) / 6), this.words = new Array(this.length);
                            for (var r = 0; r < this.length; r++) this.words[r] = 0;
                            var i, o = 0,
                                s = 0;
                            if ("be" === n)
                                for (r = e.length - 1; r >= t; r -= 2) i = l(e, t, r) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
                            else
                                for (r = (e.length - t) % 2 === 0 ? t + 1 : t; r < e.length; r += 2) i = l(e, t, r) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
                            this._strip()
                        }, o.prototype._parseBase = function(e, t, n) {
                            this.words = [0], this.length = 1;
                            for (var r = 0, i = 1; i <= 67108863; i *= t) r++;
                            r--, i = i / t | 0;
                            for (var o = e.length - n, s = o % r, a = Math.min(o, o - s) + n, l = 0, c = n; c < a; c += r) l = u(e, c, c + r, t), this.imuln(i), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
                            if (0 !== s) {
                                var d = 1;
                                for (l = u(e, c, e.length, t), c = 0; c < s; c++) d *= t;
                                this.imuln(d), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l)
                            }
                            this._strip()
                        }, o.prototype.copy = function(e) {
                            e.words = new Array(this.length);
                            for (var t = 0; t < this.length; t++) e.words[t] = this.words[t];
                            e.length = this.length, e.negative = this.negative, e.red = this.red
                        }, o.prototype._move = function(e) {
                            c(e, this)
                        }, o.prototype.clone = function() {
                            var e = new o(null);
                            return this.copy(e), e
                        }, o.prototype._expand = function(e) {
                            for (; this.length < e;) this.words[this.length++] = 0;
                            return this
                        }, o.prototype._strip = function() {
                            for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
                            return this._normSign()
                        }, o.prototype._normSign = function() {
                            return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
                        }, "undefined" !== typeof Symbol && "function" === typeof Symbol.for) try {
                        o.prototype[Symbol.for("nodejs.util.inspect.custom")] = d
                    } catch (_) {
                        o.prototype.inspect = d
                    } else o.prototype.inspect = d;

                    function d() {
                        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                    }
                    var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                        f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                        p = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
                    o.prototype.toString = function(e, t) {
                        var n;
                        if (t = 0 | t || 1, 16 === (e = e || 10) || "hex" === e) {
                            n = "";
                            for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                                var a = this.words[s],
                                    l = (16777215 & (a << i | o)).toString(16);
                                o = a >>> 24 - i & 16777215, (i += 2) >= 26 && (i -= 26, s--), n = 0 !== o || s !== this.length - 1 ? h[6 - l.length] + l + n : l + n
                            }
                            for (0 !== o && (n = o.toString(16) + n); n.length % t !== 0;) n = "0" + n;
                            return 0 !== this.negative && (n = "-" + n), n
                        }
                        if (e === (0 | e) && e >= 2 && e <= 36) {
                            var u = f[e],
                                c = p[e];
                            n = "";
                            var d = this.clone();
                            for (d.negative = 0; !d.isZero();) {
                                var m = d.modrn(c).toString(e);
                                n = (d = d.idivn(c)).isZero() ? m + n : h[u - m.length] + m + n
                            }
                            for (this.isZero() && (n = "0" + n); n.length % t !== 0;) n = "0" + n;
                            return 0 !== this.negative && (n = "-" + n), n
                        }
                        r(!1, "Base should be between 2 and 36")
                    }, o.prototype.toNumber = function() {
                        var e = this.words[0];
                        return 2 === this.length ? e += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e : e
                    }, o.prototype.toJSON = function() {
                        return this.toString(16, 2)
                    }, s && (o.prototype.toBuffer = function(e, t) {
                        return this.toArrayLike(s, e, t)
                    }), o.prototype.toArray = function(e, t) {
                        return this.toArrayLike(Array, e, t)
                    };

                    function m(e, t, n) {
                        n.negative = t.negative ^ e.negative;
                        var r = e.length + t.length | 0;
                        n.length = r, r = r - 1 | 0;
                        var i = 0 | e.words[0],
                            o = 0 | t.words[0],
                            s = i * o,
                            a = 67108863 & s,
                            l = s / 67108864 | 0;
                        n.words[0] = a;
                        for (var u = 1; u < r; u++) {
                            for (var c = l >>> 26, d = 67108863 & l, h = Math.min(u, t.length - 1), f = Math.max(0, u - e.length + 1); f <= h; f++) {
                                var p = u - f | 0;
                                c += (s = (i = 0 | e.words[p]) * (o = 0 | t.words[f]) + d) / 67108864 | 0, d = 67108863 & s
                            }
                            n.words[u] = 0 | d, l = 0 | c
                        }
                        return 0 !== l ? n.words[u] = 0 | l : n.length--, n._strip()
                    }
                    o.prototype.toArrayLike = function(e, t, n) {
                        this._strip();
                        var i = this.byteLength(),
                            o = n || Math.max(1, i);
                        r(i <= o, "byte array longer than desired length"), r(o > 0, "Requested array length <= 0");
                        var s = function(e, t) {
                            return e.allocUnsafe ? e.allocUnsafe(t) : new e(t)
                        }(e, o);
                        return this["_toArrayLike" + ("le" === t ? "LE" : "BE")](s, i), s
                    }, o.prototype._toArrayLikeLE = function(e, t) {
                        for (var n = 0, r = 0, i = 0, o = 0; i < this.length; i++) {
                            var s = this.words[i] << o | r;
                            e[n++] = 255 & s, n < e.length && (e[n++] = s >> 8 & 255), n < e.length && (e[n++] = s >> 16 & 255), 6 === o ? (n < e.length && (e[n++] = s >> 24 & 255), r = 0, o = 0) : (r = s >>> 24, o += 2)
                        }
                        if (n < e.length)
                            for (e[n++] = r; n < e.length;) e[n++] = 0
                    }, o.prototype._toArrayLikeBE = function(e, t) {
                        for (var n = e.length - 1, r = 0, i = 0, o = 0; i < this.length; i++) {
                            var s = this.words[i] << o | r;
                            e[n--] = 255 & s, n >= 0 && (e[n--] = s >> 8 & 255), n >= 0 && (e[n--] = s >> 16 & 255), 6 === o ? (n >= 0 && (e[n--] = s >> 24 & 255), r = 0, o = 0) : (r = s >>> 24, o += 2)
                        }
                        if (n >= 0)
                            for (e[n--] = r; n >= 0;) e[n--] = 0
                    }, Math.clz32 ? o.prototype._countBits = function(e) {
                        return 32 - Math.clz32(e)
                    } : o.prototype._countBits = function(e) {
                        var t = e,
                            n = 0;
                        return t >= 4096 && (n += 13, t >>>= 13), t >= 64 && (n += 7, t >>>= 7), t >= 8 && (n += 4, t >>>= 4), t >= 2 && (n += 2, t >>>= 2), n + t
                    }, o.prototype._zeroBits = function(e) {
                        if (0 === e) return 26;
                        var t = e,
                            n = 0;
                        return 0 === (8191 & t) && (n += 13, t >>>= 13), 0 === (127 & t) && (n += 7, t >>>= 7), 0 === (15 & t) && (n += 4, t >>>= 4), 0 === (3 & t) && (n += 2, t >>>= 2), 0 === (1 & t) && n++, n
                    }, o.prototype.bitLength = function() {
                        var e = this.words[this.length - 1],
                            t = this._countBits(e);
                        return 26 * (this.length - 1) + t
                    }, o.prototype.zeroBits = function() {
                        if (this.isZero()) return 0;
                        for (var e = 0, t = 0; t < this.length; t++) {
                            var n = this._zeroBits(this.words[t]);
                            if (e += n, 26 !== n) break
                        }
                        return e
                    }, o.prototype.byteLength = function() {
                        return Math.ceil(this.bitLength() / 8)
                    }, o.prototype.toTwos = function(e) {
                        return 0 !== this.negative ? this.abs().inotn(e).iaddn(1) : this.clone()
                    }, o.prototype.fromTwos = function(e) {
                        return this.testn(e - 1) ? this.notn(e).iaddn(1).ineg() : this.clone()
                    }, o.prototype.isNeg = function() {
                        return 0 !== this.negative
                    }, o.prototype.neg = function() {
                        return this.clone().ineg()
                    }, o.prototype.ineg = function() {
                        return this.isZero() || (this.negative ^= 1), this
                    }, o.prototype.iuor = function(e) {
                        for (; this.length < e.length;) this.words[this.length++] = 0;
                        for (var t = 0; t < e.length; t++) this.words[t] = this.words[t] | e.words[t];
                        return this._strip()
                    }, o.prototype.ior = function(e) {
                        return r(0 === (this.negative | e.negative)), this.iuor(e)
                    }, o.prototype.or = function(e) {
                        return this.length > e.length ? this.clone().ior(e) : e.clone().ior(this)
                    }, o.prototype.uor = function(e) {
                        return this.length > e.length ? this.clone().iuor(e) : e.clone().iuor(this)
                    }, o.prototype.iuand = function(e) {
                        var t;
                        t = this.length > e.length ? e : this;
                        for (var n = 0; n < t.length; n++) this.words[n] = this.words[n] & e.words[n];
                        return this.length = t.length, this._strip()
                    }, o.prototype.iand = function(e) {
                        return r(0 === (this.negative | e.negative)), this.iuand(e)
                    }, o.prototype.and = function(e) {
                        return this.length > e.length ? this.clone().iand(e) : e.clone().iand(this)
                    }, o.prototype.uand = function(e) {
                        return this.length > e.length ? this.clone().iuand(e) : e.clone().iuand(this)
                    }, o.prototype.iuxor = function(e) {
                        var t, n;
                        this.length > e.length ? (t = this, n = e) : (t = e, n = this);
                        for (var r = 0; r < n.length; r++) this.words[r] = t.words[r] ^ n.words[r];
                        if (this !== t)
                            for (; r < t.length; r++) this.words[r] = t.words[r];
                        return this.length = t.length, this._strip()
                    }, o.prototype.ixor = function(e) {
                        return r(0 === (this.negative | e.negative)), this.iuxor(e)
                    }, o.prototype.xor = function(e) {
                        return this.length > e.length ? this.clone().ixor(e) : e.clone().ixor(this)
                    }, o.prototype.uxor = function(e) {
                        return this.length > e.length ? this.clone().iuxor(e) : e.clone().iuxor(this)
                    }, o.prototype.inotn = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t = 0 | Math.ceil(e / 26),
                            n = e % 26;
                        this._expand(t), n > 0 && t--;
                        for (var i = 0; i < t; i++) this.words[i] = 67108863 & ~this.words[i];
                        return n > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - n), this._strip()
                    }, o.prototype.notn = function(e) {
                        return this.clone().inotn(e)
                    }, o.prototype.setn = function(e, t) {
                        r("number" === typeof e && e >= 0);
                        var n = e / 26 | 0,
                            i = e % 26;
                        return this._expand(n + 1), this.words[n] = t ? this.words[n] | 1 << i : this.words[n] & ~(1 << i), this._strip()
                    }, o.prototype.iadd = function(e) {
                        var t, n, r;
                        if (0 !== this.negative && 0 === e.negative) return this.negative = 0, t = this.isub(e), this.negative ^= 1, this._normSign();
                        if (0 === this.negative && 0 !== e.negative) return e.negative = 0, t = this.isub(e), e.negative = 1, t._normSign();
                        this.length > e.length ? (n = this, r = e) : (n = e, r = this);
                        for (var i = 0, o = 0; o < r.length; o++) t = (0 | n.words[o]) + (0 | r.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
                        for (; 0 !== i && o < n.length; o++) t = (0 | n.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
                        if (this.length = n.length, 0 !== i) this.words[this.length] = i, this.length++;
                        else if (n !== this)
                            for (; o < n.length; o++) this.words[o] = n.words[o];
                        return this
                    }, o.prototype.add = function(e) {
                        var t;
                        return 0 !== e.negative && 0 === this.negative ? (e.negative = 0, t = this.sub(e), e.negative ^= 1, t) : 0 === e.negative && 0 !== this.negative ? (this.negative = 0, t = e.sub(this), this.negative = 1, t) : this.length > e.length ? this.clone().iadd(e) : e.clone().iadd(this)
                    }, o.prototype.isub = function(e) {
                        if (0 !== e.negative) {
                            e.negative = 0;
                            var t = this.iadd(e);
                            return e.negative = 1, t._normSign()
                        }
                        if (0 !== this.negative) return this.negative = 0, this.iadd(e), this.negative = 1, this._normSign();
                        var n, r, i = this.cmp(e);
                        if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                        i > 0 ? (n = this, r = e) : (n = e, r = this);
                        for (var o = 0, s = 0; s < r.length; s++) o = (t = (0 | n.words[s]) - (0 | r.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
                        for (; 0 !== o && s < n.length; s++) o = (t = (0 | n.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
                        if (0 === o && s < n.length && n !== this)
                            for (; s < n.length; s++) this.words[s] = n.words[s];
                        return this.length = Math.max(this.length, s), n !== this && (this.negative = 1), this._strip()
                    }, o.prototype.sub = function(e) {
                        return this.clone().isub(e)
                    };
                    var g = function(e, t, n) {
                        var r, i, o, s = e.words,
                            a = t.words,
                            l = n.words,
                            u = 0,
                            c = 0 | s[0],
                            d = 8191 & c,
                            h = c >>> 13,
                            f = 0 | s[1],
                            p = 8191 & f,
                            m = f >>> 13,
                            g = 0 | s[2],
                            y = 8191 & g,
                            v = g >>> 13,
                            b = 0 | s[3],
                            w = 8191 & b,
                            E = b >>> 13,
                            x = 0 | s[4],
                            A = 8191 & x,
                            k = x >>> 13,
                            C = 0 | s[5],
                            P = 8191 & C,
                            S = C >>> 13,
                            _ = 0 | s[6],
                            N = 8191 & _,
                            M = _ >>> 13,
                            I = 0 | s[7],
                            O = 8191 & I,
                            T = I >>> 13,
                            R = 0 | s[8],
                            L = 8191 & R,
                            B = R >>> 13,
                            F = 0 | s[9],
                            j = 8191 & F,
                            D = F >>> 13,
                            U = 0 | a[0],
                            z = 8191 & U,
                            q = U >>> 13,
                            G = 0 | a[1],
                            H = 8191 & G,
                            $ = G >>> 13,
                            Q = 0 | a[2],
                            V = 8191 & Q,
                            K = Q >>> 13,
                            W = 0 | a[3],
                            J = 8191 & W,
                            Z = W >>> 13,
                            Y = 0 | a[4],
                            X = 8191 & Y,
                            ee = Y >>> 13,
                            te = 0 | a[5],
                            ne = 8191 & te,
                            re = te >>> 13,
                            ie = 0 | a[6],
                            oe = 8191 & ie,
                            se = ie >>> 13,
                            ae = 0 | a[7],
                            le = 8191 & ae,
                            ue = ae >>> 13,
                            ce = 0 | a[8],
                            de = 8191 & ce,
                            he = ce >>> 13,
                            fe = 0 | a[9],
                            pe = 8191 & fe,
                            me = fe >>> 13;
                        n.negative = e.negative ^ t.negative, n.length = 19;
                        var ge = (u + (r = Math.imul(d, z)) | 0) + ((8191 & (i = (i = Math.imul(d, q)) + Math.imul(h, z) | 0)) << 13) | 0;
                        u = ((o = Math.imul(h, q)) + (i >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, r = Math.imul(p, z), i = (i = Math.imul(p, q)) + Math.imul(m, z) | 0, o = Math.imul(m, q);
                        var ye = (u + (r = r + Math.imul(d, H) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, $) | 0) + Math.imul(h, H) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, $) | 0) + (i >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, r = Math.imul(y, z), i = (i = Math.imul(y, q)) + Math.imul(v, z) | 0, o = Math.imul(v, q), r = r + Math.imul(p, H) | 0, i = (i = i + Math.imul(p, $) | 0) + Math.imul(m, H) | 0, o = o + Math.imul(m, $) | 0;
                        var ve = (u + (r = r + Math.imul(d, V) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, K) | 0) + Math.imul(h, V) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, K) | 0) + (i >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, r = Math.imul(w, z), i = (i = Math.imul(w, q)) + Math.imul(E, z) | 0, o = Math.imul(E, q), r = r + Math.imul(y, H) | 0, i = (i = i + Math.imul(y, $) | 0) + Math.imul(v, H) | 0, o = o + Math.imul(v, $) | 0, r = r + Math.imul(p, V) | 0, i = (i = i + Math.imul(p, K) | 0) + Math.imul(m, V) | 0, o = o + Math.imul(m, K) | 0;
                        var be = (u + (r = r + Math.imul(d, J) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, Z) | 0) + Math.imul(h, J) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, Z) | 0) + (i >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, r = Math.imul(A, z), i = (i = Math.imul(A, q)) + Math.imul(k, z) | 0, o = Math.imul(k, q), r = r + Math.imul(w, H) | 0, i = (i = i + Math.imul(w, $) | 0) + Math.imul(E, H) | 0, o = o + Math.imul(E, $) | 0, r = r + Math.imul(y, V) | 0, i = (i = i + Math.imul(y, K) | 0) + Math.imul(v, V) | 0, o = o + Math.imul(v, K) | 0, r = r + Math.imul(p, J) | 0, i = (i = i + Math.imul(p, Z) | 0) + Math.imul(m, J) | 0, o = o + Math.imul(m, Z) | 0;
                        var we = (u + (r = r + Math.imul(d, X) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ee) | 0) + Math.imul(h, X) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, ee) | 0) + (i >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, r = Math.imul(P, z), i = (i = Math.imul(P, q)) + Math.imul(S, z) | 0, o = Math.imul(S, q), r = r + Math.imul(A, H) | 0, i = (i = i + Math.imul(A, $) | 0) + Math.imul(k, H) | 0, o = o + Math.imul(k, $) | 0, r = r + Math.imul(w, V) | 0, i = (i = i + Math.imul(w, K) | 0) + Math.imul(E, V) | 0, o = o + Math.imul(E, K) | 0, r = r + Math.imul(y, J) | 0, i = (i = i + Math.imul(y, Z) | 0) + Math.imul(v, J) | 0, o = o + Math.imul(v, Z) | 0, r = r + Math.imul(p, X) | 0, i = (i = i + Math.imul(p, ee) | 0) + Math.imul(m, X) | 0, o = o + Math.imul(m, ee) | 0;
                        var Ee = (u + (r = r + Math.imul(d, ne) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, re) | 0) + Math.imul(h, ne) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, re) | 0) + (i >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, r = Math.imul(N, z), i = (i = Math.imul(N, q)) + Math.imul(M, z) | 0, o = Math.imul(M, q), r = r + Math.imul(P, H) | 0, i = (i = i + Math.imul(P, $) | 0) + Math.imul(S, H) | 0, o = o + Math.imul(S, $) | 0, r = r + Math.imul(A, V) | 0, i = (i = i + Math.imul(A, K) | 0) + Math.imul(k, V) | 0, o = o + Math.imul(k, K) | 0, r = r + Math.imul(w, J) | 0, i = (i = i + Math.imul(w, Z) | 0) + Math.imul(E, J) | 0, o = o + Math.imul(E, Z) | 0, r = r + Math.imul(y, X) | 0, i = (i = i + Math.imul(y, ee) | 0) + Math.imul(v, X) | 0, o = o + Math.imul(v, ee) | 0, r = r + Math.imul(p, ne) | 0, i = (i = i + Math.imul(p, re) | 0) + Math.imul(m, ne) | 0, o = o + Math.imul(m, re) | 0;
                        var xe = (u + (r = r + Math.imul(d, oe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, se) | 0) + Math.imul(h, oe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, se) | 0) + (i >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, r = Math.imul(O, z), i = (i = Math.imul(O, q)) + Math.imul(T, z) | 0, o = Math.imul(T, q), r = r + Math.imul(N, H) | 0, i = (i = i + Math.imul(N, $) | 0) + Math.imul(M, H) | 0, o = o + Math.imul(M, $) | 0, r = r + Math.imul(P, V) | 0, i = (i = i + Math.imul(P, K) | 0) + Math.imul(S, V) | 0, o = o + Math.imul(S, K) | 0, r = r + Math.imul(A, J) | 0, i = (i = i + Math.imul(A, Z) | 0) + Math.imul(k, J) | 0, o = o + Math.imul(k, Z) | 0, r = r + Math.imul(w, X) | 0, i = (i = i + Math.imul(w, ee) | 0) + Math.imul(E, X) | 0, o = o + Math.imul(E, ee) | 0, r = r + Math.imul(y, ne) | 0, i = (i = i + Math.imul(y, re) | 0) + Math.imul(v, ne) | 0, o = o + Math.imul(v, re) | 0, r = r + Math.imul(p, oe) | 0, i = (i = i + Math.imul(p, se) | 0) + Math.imul(m, oe) | 0, o = o + Math.imul(m, se) | 0;
                        var Ae = (u + (r = r + Math.imul(d, le) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, ue) | 0) + Math.imul(h, le) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, ue) | 0) + (i >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, r = Math.imul(L, z), i = (i = Math.imul(L, q)) + Math.imul(B, z) | 0, o = Math.imul(B, q), r = r + Math.imul(O, H) | 0, i = (i = i + Math.imul(O, $) | 0) + Math.imul(T, H) | 0, o = o + Math.imul(T, $) | 0, r = r + Math.imul(N, V) | 0, i = (i = i + Math.imul(N, K) | 0) + Math.imul(M, V) | 0, o = o + Math.imul(M, K) | 0, r = r + Math.imul(P, J) | 0, i = (i = i + Math.imul(P, Z) | 0) + Math.imul(S, J) | 0, o = o + Math.imul(S, Z) | 0, r = r + Math.imul(A, X) | 0, i = (i = i + Math.imul(A, ee) | 0) + Math.imul(k, X) | 0, o = o + Math.imul(k, ee) | 0, r = r + Math.imul(w, ne) | 0, i = (i = i + Math.imul(w, re) | 0) + Math.imul(E, ne) | 0, o = o + Math.imul(E, re) | 0, r = r + Math.imul(y, oe) | 0, i = (i = i + Math.imul(y, se) | 0) + Math.imul(v, oe) | 0, o = o + Math.imul(v, se) | 0, r = r + Math.imul(p, le) | 0, i = (i = i + Math.imul(p, ue) | 0) + Math.imul(m, le) | 0, o = o + Math.imul(m, ue) | 0;
                        var ke = (u + (r = r + Math.imul(d, de) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, he) | 0) + Math.imul(h, de) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, he) | 0) + (i >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, r = Math.imul(j, z), i = (i = Math.imul(j, q)) + Math.imul(D, z) | 0, o = Math.imul(D, q), r = r + Math.imul(L, H) | 0, i = (i = i + Math.imul(L, $) | 0) + Math.imul(B, H) | 0, o = o + Math.imul(B, $) | 0, r = r + Math.imul(O, V) | 0, i = (i = i + Math.imul(O, K) | 0) + Math.imul(T, V) | 0, o = o + Math.imul(T, K) | 0, r = r + Math.imul(N, J) | 0, i = (i = i + Math.imul(N, Z) | 0) + Math.imul(M, J) | 0, o = o + Math.imul(M, Z) | 0, r = r + Math.imul(P, X) | 0, i = (i = i + Math.imul(P, ee) | 0) + Math.imul(S, X) | 0, o = o + Math.imul(S, ee) | 0, r = r + Math.imul(A, ne) | 0, i = (i = i + Math.imul(A, re) | 0) + Math.imul(k, ne) | 0, o = o + Math.imul(k, re) | 0, r = r + Math.imul(w, oe) | 0, i = (i = i + Math.imul(w, se) | 0) + Math.imul(E, oe) | 0, o = o + Math.imul(E, se) | 0, r = r + Math.imul(y, le) | 0, i = (i = i + Math.imul(y, ue) | 0) + Math.imul(v, le) | 0, o = o + Math.imul(v, ue) | 0, r = r + Math.imul(p, de) | 0, i = (i = i + Math.imul(p, he) | 0) + Math.imul(m, de) | 0, o = o + Math.imul(m, he) | 0;
                        var Ce = (u + (r = r + Math.imul(d, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(d, me) | 0) + Math.imul(h, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(h, me) | 0) + (i >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863, r = Math.imul(j, H), i = (i = Math.imul(j, $)) + Math.imul(D, H) | 0, o = Math.imul(D, $), r = r + Math.imul(L, V) | 0, i = (i = i + Math.imul(L, K) | 0) + Math.imul(B, V) | 0, o = o + Math.imul(B, K) | 0, r = r + Math.imul(O, J) | 0, i = (i = i + Math.imul(O, Z) | 0) + Math.imul(T, J) | 0, o = o + Math.imul(T, Z) | 0, r = r + Math.imul(N, X) | 0, i = (i = i + Math.imul(N, ee) | 0) + Math.imul(M, X) | 0, o = o + Math.imul(M, ee) | 0, r = r + Math.imul(P, ne) | 0, i = (i = i + Math.imul(P, re) | 0) + Math.imul(S, ne) | 0, o = o + Math.imul(S, re) | 0, r = r + Math.imul(A, oe) | 0, i = (i = i + Math.imul(A, se) | 0) + Math.imul(k, oe) | 0, o = o + Math.imul(k, se) | 0, r = r + Math.imul(w, le) | 0, i = (i = i + Math.imul(w, ue) | 0) + Math.imul(E, le) | 0, o = o + Math.imul(E, ue) | 0, r = r + Math.imul(y, de) | 0, i = (i = i + Math.imul(y, he) | 0) + Math.imul(v, de) | 0, o = o + Math.imul(v, he) | 0;
                        var Pe = (u + (r = r + Math.imul(p, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(p, me) | 0) + Math.imul(m, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(m, me) | 0) + (i >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863, r = Math.imul(j, V), i = (i = Math.imul(j, K)) + Math.imul(D, V) | 0, o = Math.imul(D, K), r = r + Math.imul(L, J) | 0, i = (i = i + Math.imul(L, Z) | 0) + Math.imul(B, J) | 0, o = o + Math.imul(B, Z) | 0, r = r + Math.imul(O, X) | 0, i = (i = i + Math.imul(O, ee) | 0) + Math.imul(T, X) | 0, o = o + Math.imul(T, ee) | 0, r = r + Math.imul(N, ne) | 0, i = (i = i + Math.imul(N, re) | 0) + Math.imul(M, ne) | 0, o = o + Math.imul(M, re) | 0, r = r + Math.imul(P, oe) | 0, i = (i = i + Math.imul(P, se) | 0) + Math.imul(S, oe) | 0, o = o + Math.imul(S, se) | 0, r = r + Math.imul(A, le) | 0, i = (i = i + Math.imul(A, ue) | 0) + Math.imul(k, le) | 0, o = o + Math.imul(k, ue) | 0, r = r + Math.imul(w, de) | 0, i = (i = i + Math.imul(w, he) | 0) + Math.imul(E, de) | 0, o = o + Math.imul(E, he) | 0;
                        var Se = (u + (r = r + Math.imul(y, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(y, me) | 0) + Math.imul(v, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(v, me) | 0) + (i >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, r = Math.imul(j, J), i = (i = Math.imul(j, Z)) + Math.imul(D, J) | 0, o = Math.imul(D, Z), r = r + Math.imul(L, X) | 0, i = (i = i + Math.imul(L, ee) | 0) + Math.imul(B, X) | 0, o = o + Math.imul(B, ee) | 0, r = r + Math.imul(O, ne) | 0, i = (i = i + Math.imul(O, re) | 0) + Math.imul(T, ne) | 0, o = o + Math.imul(T, re) | 0, r = r + Math.imul(N, oe) | 0, i = (i = i + Math.imul(N, se) | 0) + Math.imul(M, oe) | 0, o = o + Math.imul(M, se) | 0, r = r + Math.imul(P, le) | 0, i = (i = i + Math.imul(P, ue) | 0) + Math.imul(S, le) | 0, o = o + Math.imul(S, ue) | 0, r = r + Math.imul(A, de) | 0, i = (i = i + Math.imul(A, he) | 0) + Math.imul(k, de) | 0, o = o + Math.imul(k, he) | 0;
                        var _e = (u + (r = r + Math.imul(w, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(w, me) | 0) + Math.imul(E, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(E, me) | 0) + (i >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, r = Math.imul(j, X), i = (i = Math.imul(j, ee)) + Math.imul(D, X) | 0, o = Math.imul(D, ee), r = r + Math.imul(L, ne) | 0, i = (i = i + Math.imul(L, re) | 0) + Math.imul(B, ne) | 0, o = o + Math.imul(B, re) | 0, r = r + Math.imul(O, oe) | 0, i = (i = i + Math.imul(O, se) | 0) + Math.imul(T, oe) | 0, o = o + Math.imul(T, se) | 0, r = r + Math.imul(N, le) | 0, i = (i = i + Math.imul(N, ue) | 0) + Math.imul(M, le) | 0, o = o + Math.imul(M, ue) | 0, r = r + Math.imul(P, de) | 0, i = (i = i + Math.imul(P, he) | 0) + Math.imul(S, de) | 0, o = o + Math.imul(S, he) | 0;
                        var Ne = (u + (r = r + Math.imul(A, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(A, me) | 0) + Math.imul(k, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(k, me) | 0) + (i >>> 13) | 0) + (Ne >>> 26) | 0, Ne &= 67108863, r = Math.imul(j, ne), i = (i = Math.imul(j, re)) + Math.imul(D, ne) | 0, o = Math.imul(D, re), r = r + Math.imul(L, oe) | 0, i = (i = i + Math.imul(L, se) | 0) + Math.imul(B, oe) | 0, o = o + Math.imul(B, se) | 0, r = r + Math.imul(O, le) | 0, i = (i = i + Math.imul(O, ue) | 0) + Math.imul(T, le) | 0, o = o + Math.imul(T, ue) | 0, r = r + Math.imul(N, de) | 0, i = (i = i + Math.imul(N, he) | 0) + Math.imul(M, de) | 0, o = o + Math.imul(M, he) | 0;
                        var Me = (u + (r = r + Math.imul(P, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(P, me) | 0) + Math.imul(S, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(S, me) | 0) + (i >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, r = Math.imul(j, oe), i = (i = Math.imul(j, se)) + Math.imul(D, oe) | 0, o = Math.imul(D, se), r = r + Math.imul(L, le) | 0, i = (i = i + Math.imul(L, ue) | 0) + Math.imul(B, le) | 0, o = o + Math.imul(B, ue) | 0, r = r + Math.imul(O, de) | 0, i = (i = i + Math.imul(O, he) | 0) + Math.imul(T, de) | 0, o = o + Math.imul(T, he) | 0;
                        var Ie = (u + (r = r + Math.imul(N, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(N, me) | 0) + Math.imul(M, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(M, me) | 0) + (i >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, r = Math.imul(j, le), i = (i = Math.imul(j, ue)) + Math.imul(D, le) | 0, o = Math.imul(D, ue), r = r + Math.imul(L, de) | 0, i = (i = i + Math.imul(L, he) | 0) + Math.imul(B, de) | 0, o = o + Math.imul(B, he) | 0;
                        var Oe = (u + (r = r + Math.imul(O, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(O, me) | 0) + Math.imul(T, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(T, me) | 0) + (i >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, r = Math.imul(j, de), i = (i = Math.imul(j, he)) + Math.imul(D, de) | 0, o = Math.imul(D, he);
                        var Te = (u + (r = r + Math.imul(L, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(L, me) | 0) + Math.imul(B, pe) | 0)) << 13) | 0;
                        u = ((o = o + Math.imul(B, me) | 0) + (i >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863;
                        var Re = (u + (r = Math.imul(j, pe)) | 0) + ((8191 & (i = (i = Math.imul(j, me)) + Math.imul(D, pe) | 0)) << 13) | 0;
                        return u = ((o = Math.imul(D, me)) + (i >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, l[0] = ge, l[1] = ye, l[2] = ve, l[3] = be, l[4] = we, l[5] = Ee, l[6] = xe, l[7] = Ae, l[8] = ke, l[9] = Ce, l[10] = Pe, l[11] = Se, l[12] = _e, l[13] = Ne, l[14] = Me, l[15] = Ie, l[16] = Oe, l[17] = Te, l[18] = Re, 0 !== u && (l[19] = u, n.length++), n
                    };

                    function y(e, t, n) {
                        n.negative = t.negative ^ e.negative, n.length = e.length + t.length;
                        for (var r = 0, i = 0, o = 0; o < n.length - 1; o++) {
                            var s = i;
                            i = 0;
                            for (var a = 67108863 & r, l = Math.min(o, t.length - 1), u = Math.max(0, o - e.length + 1); u <= l; u++) {
                                var c = o - u,
                                    d = (0 | e.words[c]) * (0 | t.words[u]),
                                    h = 67108863 & d;
                                a = 67108863 & (h = h + a | 0), i += (s = (s = s + (d / 67108864 | 0) | 0) + (h >>> 26) | 0) >>> 26, s &= 67108863
                            }
                            n.words[o] = a, r = s, s = i
                        }
                        return 0 !== r ? n.words[o] = r : n.length--, n._strip()
                    }

                    function v(e, t, n) {
                        return y(e, t, n)
                    }

                    function b(e, t) {
                        this.x = e, this.y = t
                    }
                    Math.imul || (g = m), o.prototype.mulTo = function(e, t) {
                        var n = this.length + e.length;
                        return 10 === this.length && 10 === e.length ? g(this, e, t) : n < 63 ? m(this, e, t) : n < 1024 ? y(this, e, t) : v(this, e, t)
                    }, b.prototype.makeRBT = function(e) {
                        for (var t = new Array(e), n = o.prototype._countBits(e) - 1, r = 0; r < e; r++) t[r] = this.revBin(r, n, e);
                        return t
                    }, b.prototype.revBin = function(e, t, n) {
                        if (0 === e || e === n - 1) return e;
                        for (var r = 0, i = 0; i < t; i++) r |= (1 & e) << t - i - 1, e >>= 1;
                        return r
                    }, b.prototype.permute = function(e, t, n, r, i, o) {
                        for (var s = 0; s < o; s++) r[s] = t[e[s]], i[s] = n[e[s]]
                    }, b.prototype.transform = function(e, t, n, r, i, o) {
                        this.permute(o, e, t, n, r, i);
                        for (var s = 1; s < i; s <<= 1)
                            for (var a = s << 1, l = Math.cos(2 * Math.PI / a), u = Math.sin(2 * Math.PI / a), c = 0; c < i; c += a)
                                for (var d = l, h = u, f = 0; f < s; f++) {
                                    var p = n[c + f],
                                        m = r[c + f],
                                        g = n[c + f + s],
                                        y = r[c + f + s],
                                        v = d * g - h * y;
                                    y = d * y + h * g, g = v, n[c + f] = p + g, r[c + f] = m + y, n[c + f + s] = p - g, r[c + f + s] = m - y, f !== a && (v = l * d - u * h, h = l * h + u * d, d = v)
                                }
                    }, b.prototype.guessLen13b = function(e, t) {
                        var n = 1 | Math.max(t, e),
                            r = 1 & n,
                            i = 0;
                        for (n = n / 2 | 0; n; n >>>= 1) i++;
                        return 1 << i + 1 + r
                    }, b.prototype.conjugate = function(e, t, n) {
                        if (!(n <= 1))
                            for (var r = 0; r < n / 2; r++) {
                                var i = e[r];
                                e[r] = e[n - r - 1], e[n - r - 1] = i, i = t[r], t[r] = -t[n - r - 1], t[n - r - 1] = -i
                            }
                    }, b.prototype.normalize13b = function(e, t) {
                        for (var n = 0, r = 0; r < t / 2; r++) {
                            var i = 8192 * Math.round(e[2 * r + 1] / t) + Math.round(e[2 * r] / t) + n;
                            e[r] = 67108863 & i, n = i < 67108864 ? 0 : i / 67108864 | 0
                        }
                        return e
                    }, b.prototype.convert13b = function(e, t, n, i) {
                        for (var o = 0, s = 0; s < t; s++) o += 0 | e[s], n[2 * s] = 8191 & o, o >>>= 13, n[2 * s + 1] = 8191 & o, o >>>= 13;
                        for (s = 2 * t; s < i; ++s) n[s] = 0;
                        r(0 === o), r(0 === (-8192 & o))
                    }, b.prototype.stub = function(e) {
                        for (var t = new Array(e), n = 0; n < e; n++) t[n] = 0;
                        return t
                    }, b.prototype.mulp = function(e, t, n) {
                        var r = 2 * this.guessLen13b(e.length, t.length),
                            i = this.makeRBT(r),
                            o = this.stub(r),
                            s = new Array(r),
                            a = new Array(r),
                            l = new Array(r),
                            u = new Array(r),
                            c = new Array(r),
                            d = new Array(r),
                            h = n.words;
                        h.length = r, this.convert13b(e.words, e.length, s, r), this.convert13b(t.words, t.length, u, r), this.transform(s, o, a, l, r, i), this.transform(u, o, c, d, r, i);
                        for (var f = 0; f < r; f++) {
                            var p = a[f] * c[f] - l[f] * d[f];
                            l[f] = a[f] * d[f] + l[f] * c[f], a[f] = p
                        }
                        return this.conjugate(a, l, r), this.transform(a, l, h, o, r, i), this.conjugate(h, o, r), this.normalize13b(h, r), n.negative = e.negative ^ t.negative, n.length = e.length + t.length, n._strip()
                    }, o.prototype.mul = function(e) {
                        var t = new o(null);
                        return t.words = new Array(this.length + e.length), this.mulTo(e, t)
                    }, o.prototype.mulf = function(e) {
                        var t = new o(null);
                        return t.words = new Array(this.length + e.length), v(this, e, t)
                    }, o.prototype.imul = function(e) {
                        return this.clone().mulTo(e, this)
                    }, o.prototype.imuln = function(e) {
                        var t = e < 0;
                        t && (e = -e), r("number" === typeof e), r(e < 67108864);
                        for (var n = 0, i = 0; i < this.length; i++) {
                            var o = (0 | this.words[i]) * e,
                                s = (67108863 & o) + (67108863 & n);
                            n >>= 26, n += o / 67108864 | 0, n += s >>> 26, this.words[i] = 67108863 & s
                        }
                        return 0 !== n && (this.words[i] = n, this.length++), t ? this.ineg() : this
                    }, o.prototype.muln = function(e) {
                        return this.clone().imuln(e)
                    }, o.prototype.sqr = function() {
                        return this.mul(this)
                    }, o.prototype.isqr = function() {
                        return this.imul(this.clone())
                    }, o.prototype.pow = function(e) {
                        var t = function(e) {
                            for (var t = new Array(e.bitLength()), n = 0; n < t.length; n++) {
                                var r = n / 26 | 0,
                                    i = n % 26;
                                t[n] = e.words[r] >>> i & 1
                            }
                            return t
                        }(e);
                        if (0 === t.length) return new o(1);
                        for (var n = this, r = 0; r < t.length && 0 === t[r]; r++, n = n.sqr());
                        if (++r < t.length)
                            for (var i = n.sqr(); r < t.length; r++, i = i.sqr()) 0 !== t[r] && (n = n.mul(i));
                        return n
                    }, o.prototype.iushln = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t, n = e % 26,
                            i = (e - n) / 26,
                            o = 67108863 >>> 26 - n << 26 - n;
                        if (0 !== n) {
                            var s = 0;
                            for (t = 0; t < this.length; t++) {
                                var a = this.words[t] & o,
                                    l = (0 | this.words[t]) - a << n;
                                this.words[t] = l | s, s = a >>> 26 - n
                            }
                            s && (this.words[t] = s, this.length++)
                        }
                        if (0 !== i) {
                            for (t = this.length - 1; t >= 0; t--) this.words[t + i] = this.words[t];
                            for (t = 0; t < i; t++) this.words[t] = 0;
                            this.length += i
                        }
                        return this._strip()
                    }, o.prototype.ishln = function(e) {
                        return r(0 === this.negative), this.iushln(e)
                    }, o.prototype.iushrn = function(e, t, n) {
                        var i;
                        r("number" === typeof e && e >= 0), i = t ? (t - t % 26) / 26 : 0;
                        var o = e % 26,
                            s = Math.min((e - o) / 26, this.length),
                            a = 67108863 ^ 67108863 >>> o << o,
                            l = n;
                        if (i -= s, i = Math.max(0, i), l) {
                            for (var u = 0; u < s; u++) l.words[u] = this.words[u];
                            l.length = s
                        }
                        if (0 === s);
                        else if (this.length > s)
                            for (this.length -= s, u = 0; u < this.length; u++) this.words[u] = this.words[u + s];
                        else this.words[0] = 0, this.length = 1;
                        var c = 0;
                        for (u = this.length - 1; u >= 0 && (0 !== c || u >= i); u--) {
                            var d = 0 | this.words[u];
                            this.words[u] = c << 26 - o | d >>> o, c = d & a
                        }
                        return l && 0 !== c && (l.words[l.length++] = c), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip()
                    }, o.prototype.ishrn = function(e, t, n) {
                        return r(0 === this.negative), this.iushrn(e, t, n)
                    }, o.prototype.shln = function(e) {
                        return this.clone().ishln(e)
                    }, o.prototype.ushln = function(e) {
                        return this.clone().iushln(e)
                    }, o.prototype.shrn = function(e) {
                        return this.clone().ishrn(e)
                    }, o.prototype.ushrn = function(e) {
                        return this.clone().iushrn(e)
                    }, o.prototype.testn = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t = e % 26,
                            n = (e - t) / 26,
                            i = 1 << t;
                        return !(this.length <= n) && !!(this.words[n] & i)
                    }, o.prototype.imaskn = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t = e % 26,
                            n = (e - t) / 26;
                        if (r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n) return this;
                        if (0 !== t && n++, this.length = Math.min(n, this.length), 0 !== t) {
                            var i = 67108863 ^ 67108863 >>> t << t;
                            this.words[this.length - 1] &= i
                        }
                        return this._strip()
                    }, o.prototype.maskn = function(e) {
                        return this.clone().imaskn(e)
                    }, o.prototype.iaddn = function(e) {
                        return r("number" === typeof e), r(e < 67108864), e < 0 ? this.isubn(-e) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= e ? (this.words[0] = e - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e), this.negative = 1, this) : this._iaddn(e)
                    }, o.prototype._iaddn = function(e) {
                        this.words[0] += e;
                        for (var t = 0; t < this.length && this.words[t] >= 67108864; t++) this.words[t] -= 67108864, t === this.length - 1 ? this.words[t + 1] = 1 : this.words[t + 1]++;
                        return this.length = Math.max(this.length, t + 1), this
                    }, o.prototype.isubn = function(e) {
                        if (r("number" === typeof e), r(e < 67108864), e < 0) return this.iaddn(-e);
                        if (0 !== this.negative) return this.negative = 0, this.iaddn(e), this.negative = 1, this;
                        if (this.words[0] -= e, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                        else
                            for (var t = 0; t < this.length && this.words[t] < 0; t++) this.words[t] += 67108864, this.words[t + 1] -= 1;
                        return this._strip()
                    }, o.prototype.addn = function(e) {
                        return this.clone().iaddn(e)
                    }, o.prototype.subn = function(e) {
                        return this.clone().isubn(e)
                    }, o.prototype.iabs = function() {
                        return this.negative = 0, this
                    }, o.prototype.abs = function() {
                        return this.clone().iabs()
                    }, o.prototype._ishlnsubmul = function(e, t, n) {
                        var i, o, s = e.length + n;
                        this._expand(s);
                        var a = 0;
                        for (i = 0; i < e.length; i++) {
                            o = (0 | this.words[i + n]) + a;
                            var l = (0 | e.words[i]) * t;
                            a = ((o -= 67108863 & l) >> 26) - (l / 67108864 | 0), this.words[i + n] = 67108863 & o
                        }
                        for (; i < this.length - n; i++) a = (o = (0 | this.words[i + n]) + a) >> 26, this.words[i + n] = 67108863 & o;
                        if (0 === a) return this._strip();
                        for (r(-1 === a), a = 0, i = 0; i < this.length; i++) a = (o = -(0 | this.words[i]) + a) >> 26, this.words[i] = 67108863 & o;
                        return this.negative = 1, this._strip()
                    }, o.prototype._wordDiv = function(e, t) {
                        var n = (this.length, e.length),
                            r = this.clone(),
                            i = e,
                            s = 0 | i.words[i.length - 1];
                        0 !== (n = 26 - this._countBits(s)) && (i = i.ushln(n), r.iushln(n), s = 0 | i.words[i.length - 1]);
                        var a, l = r.length - i.length;
                        if ("mod" !== t) {
                            (a = new o(null)).length = l + 1, a.words = new Array(a.length);
                            for (var u = 0; u < a.length; u++) a.words[u] = 0
                        }
                        var c = r.clone()._ishlnsubmul(i, 1, l);
                        0 === c.negative && (r = c, a && (a.words[l] = 1));
                        for (var d = l - 1; d >= 0; d--) {
                            var h = 67108864 * (0 | r.words[i.length + d]) + (0 | r.words[i.length + d - 1]);
                            for (h = Math.min(h / s | 0, 67108863), r._ishlnsubmul(i, h, d); 0 !== r.negative;) h--, r.negative = 0, r._ishlnsubmul(i, 1, d), r.isZero() || (r.negative ^= 1);
                            a && (a.words[d] = h)
                        }
                        return a && a._strip(), r._strip(), "div" !== t && 0 !== n && r.iushrn(n), {
                            div: a || null,
                            mod: r
                        }
                    }, o.prototype.divmod = function(e, t, n) {
                        return r(!e.isZero()), this.isZero() ? {
                            div: new o(0),
                            mod: new o(0)
                        } : 0 !== this.negative && 0 === e.negative ? (a = this.neg().divmod(e, t), "mod" !== t && (i = a.div.neg()), "div" !== t && (s = a.mod.neg(), n && 0 !== s.negative && s.iadd(e)), {
                            div: i,
                            mod: s
                        }) : 0 === this.negative && 0 !== e.negative ? (a = this.divmod(e.neg(), t), "mod" !== t && (i = a.div.neg()), {
                            div: i,
                            mod: a.mod
                        }) : 0 !== (this.negative & e.negative) ? (a = this.neg().divmod(e.neg(), t), "div" !== t && (s = a.mod.neg(), n && 0 !== s.negative && s.isub(e)), {
                            div: a.div,
                            mod: s
                        }) : e.length > this.length || this.cmp(e) < 0 ? {
                            div: new o(0),
                            mod: this
                        } : 1 === e.length ? "div" === t ? {
                            div: this.divn(e.words[0]),
                            mod: null
                        } : "mod" === t ? {
                            div: null,
                            mod: new o(this.modrn(e.words[0]))
                        } : {
                            div: this.divn(e.words[0]),
                            mod: new o(this.modrn(e.words[0]))
                        } : this._wordDiv(e, t);
                        var i, s, a
                    }, o.prototype.div = function(e) {
                        return this.divmod(e, "div", !1).div
                    }, o.prototype.mod = function(e) {
                        return this.divmod(e, "mod", !1).mod
                    }, o.prototype.umod = function(e) {
                        return this.divmod(e, "mod", !0).mod
                    }, o.prototype.divRound = function(e) {
                        var t = this.divmod(e);
                        if (t.mod.isZero()) return t.div;
                        var n = 0 !== t.div.negative ? t.mod.isub(e) : t.mod,
                            r = e.ushrn(1),
                            i = e.andln(1),
                            o = n.cmp(r);
                        return o < 0 || 1 === i && 0 === o ? t.div : 0 !== t.div.negative ? t.div.isubn(1) : t.div.iaddn(1)
                    }, o.prototype.modrn = function(e) {
                        var t = e < 0;
                        t && (e = -e), r(e <= 67108863);
                        for (var n = (1 << 26) % e, i = 0, o = this.length - 1; o >= 0; o--) i = (n * i + (0 | this.words[o])) % e;
                        return t ? -i : i
                    }, o.prototype.modn = function(e) {
                        return this.modrn(e)
                    }, o.prototype.idivn = function(e) {
                        var t = e < 0;
                        t && (e = -e), r(e <= 67108863);
                        for (var n = 0, i = this.length - 1; i >= 0; i--) {
                            var o = (0 | this.words[i]) + 67108864 * n;
                            this.words[i] = o / e | 0, n = o % e
                        }
                        return this._strip(), t ? this.ineg() : this
                    }, o.prototype.divn = function(e) {
                        return this.clone().idivn(e)
                    }, o.prototype.egcd = function(e) {
                        r(0 === e.negative), r(!e.isZero());
                        var t = this,
                            n = e.clone();
                        t = 0 !== t.negative ? t.umod(e) : t.clone();
                        for (var i = new o(1), s = new o(0), a = new o(0), l = new o(1), u = 0; t.isEven() && n.isEven();) t.iushrn(1), n.iushrn(1), ++u;
                        for (var c = n.clone(), d = t.clone(); !t.isZero();) {
                            for (var h = 0, f = 1; 0 === (t.words[0] & f) && h < 26; ++h, f <<= 1);
                            if (h > 0)
                                for (t.iushrn(h); h-- > 0;)(i.isOdd() || s.isOdd()) && (i.iadd(c), s.isub(d)), i.iushrn(1), s.iushrn(1);
                            for (var p = 0, m = 1; 0 === (n.words[0] & m) && p < 26; ++p, m <<= 1);
                            if (p > 0)
                                for (n.iushrn(p); p-- > 0;)(a.isOdd() || l.isOdd()) && (a.iadd(c), l.isub(d)), a.iushrn(1), l.iushrn(1);
                            t.cmp(n) >= 0 ? (t.isub(n), i.isub(a), s.isub(l)) : (n.isub(t), a.isub(i), l.isub(s))
                        }
                        return {
                            a: a,
                            b: l,
                            gcd: n.iushln(u)
                        }
                    }, o.prototype._invmp = function(e) {
                        r(0 === e.negative), r(!e.isZero());
                        var t = this,
                            n = e.clone();
                        t = 0 !== t.negative ? t.umod(e) : t.clone();
                        for (var i, s = new o(1), a = new o(0), l = n.clone(); t.cmpn(1) > 0 && n.cmpn(1) > 0;) {
                            for (var u = 0, c = 1; 0 === (t.words[0] & c) && u < 26; ++u, c <<= 1);
                            if (u > 0)
                                for (t.iushrn(u); u-- > 0;) s.isOdd() && s.iadd(l), s.iushrn(1);
                            for (var d = 0, h = 1; 0 === (n.words[0] & h) && d < 26; ++d, h <<= 1);
                            if (d > 0)
                                for (n.iushrn(d); d-- > 0;) a.isOdd() && a.iadd(l), a.iushrn(1);
                            t.cmp(n) >= 0 ? (t.isub(n), s.isub(a)) : (n.isub(t), a.isub(s))
                        }
                        return (i = 0 === t.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(e), i
                    }, o.prototype.gcd = function(e) {
                        if (this.isZero()) return e.abs();
                        if (e.isZero()) return this.abs();
                        var t = this.clone(),
                            n = e.clone();
                        t.negative = 0, n.negative = 0;
                        for (var r = 0; t.isEven() && n.isEven(); r++) t.iushrn(1), n.iushrn(1);
                        for (;;) {
                            for (; t.isEven();) t.iushrn(1);
                            for (; n.isEven();) n.iushrn(1);
                            var i = t.cmp(n);
                            if (i < 0) {
                                var o = t;
                                t = n, n = o
                            } else if (0 === i || 0 === n.cmpn(1)) break;
                            t.isub(n)
                        }
                        return n.iushln(r)
                    }, o.prototype.invm = function(e) {
                        return this.egcd(e).a.umod(e)
                    }, o.prototype.isEven = function() {
                        return 0 === (1 & this.words[0])
                    }, o.prototype.isOdd = function() {
                        return 1 === (1 & this.words[0])
                    }, o.prototype.andln = function(e) {
                        return this.words[0] & e
                    }, o.prototype.bincn = function(e) {
                        r("number" === typeof e);
                        var t = e % 26,
                            n = (e - t) / 26,
                            i = 1 << t;
                        if (this.length <= n) return this._expand(n + 1), this.words[n] |= i, this;
                        for (var o = i, s = n; 0 !== o && s < this.length; s++) {
                            var a = 0 | this.words[s];
                            o = (a += o) >>> 26, a &= 67108863, this.words[s] = a
                        }
                        return 0 !== o && (this.words[s] = o, this.length++), this
                    }, o.prototype.isZero = function() {
                        return 1 === this.length && 0 === this.words[0]
                    }, o.prototype.cmpn = function(e) {
                        var t, n = e < 0;
                        if (0 !== this.negative && !n) return -1;
                        if (0 === this.negative && n) return 1;
                        if (this._strip(), this.length > 1) t = 1;
                        else {
                            n && (e = -e), r(e <= 67108863, "Number is too big");
                            var i = 0 | this.words[0];
                            t = i === e ? 0 : i < e ? -1 : 1
                        }
                        return 0 !== this.negative ? 0 | -t : t
                    }, o.prototype.cmp = function(e) {
                        if (0 !== this.negative && 0 === e.negative) return -1;
                        if (0 === this.negative && 0 !== e.negative) return 1;
                        var t = this.ucmp(e);
                        return 0 !== this.negative ? 0 | -t : t
                    }, o.prototype.ucmp = function(e) {
                        if (this.length > e.length) return 1;
                        if (this.length < e.length) return -1;
                        for (var t = 0, n = this.length - 1; n >= 0; n--) {
                            var r = 0 | this.words[n],
                                i = 0 | e.words[n];
                            if (r !== i) {
                                r < i ? t = -1 : r > i && (t = 1);
                                break
                            }
                        }
                        return t
                    }, o.prototype.gtn = function(e) {
                        return 1 === this.cmpn(e)
                    }, o.prototype.gt = function(e) {
                        return 1 === this.cmp(e)
                    }, o.prototype.gten = function(e) {
                        return this.cmpn(e) >= 0
                    }, o.prototype.gte = function(e) {
                        return this.cmp(e) >= 0
                    }, o.prototype.ltn = function(e) {
                        return -1 === this.cmpn(e)
                    }, o.prototype.lt = function(e) {
                        return -1 === this.cmp(e)
                    }, o.prototype.lten = function(e) {
                        return this.cmpn(e) <= 0
                    }, o.prototype.lte = function(e) {
                        return this.cmp(e) <= 0
                    }, o.prototype.eqn = function(e) {
                        return 0 === this.cmpn(e)
                    }, o.prototype.eq = function(e) {
                        return 0 === this.cmp(e)
                    }, o.red = function(e) {
                        return new P(e)
                    }, o.prototype.toRed = function(e) {
                        return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), e.convertTo(this)._forceRed(e)
                    }, o.prototype.fromRed = function() {
                        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
                    }, o.prototype._forceRed = function(e) {
                        return this.red = e, this
                    }, o.prototype.forceRed = function(e) {
                        return r(!this.red, "Already a number in reduction context"), this._forceRed(e)
                    }, o.prototype.redAdd = function(e) {
                        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, e)
                    }, o.prototype.redIAdd = function(e) {
                        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e)
                    }, o.prototype.redSub = function(e) {
                        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, e)
                    }, o.prototype.redISub = function(e) {
                        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, e)
                    }, o.prototype.redShl = function(e) {
                        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, e)
                    }, o.prototype.redMul = function(e) {
                        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.mul(this, e)
                    }, o.prototype.redIMul = function(e) {
                        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.imul(this, e)
                    }, o.prototype.redSqr = function() {
                        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
                    }, o.prototype.redISqr = function() {
                        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
                    }, o.prototype.redSqrt = function() {
                        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
                    }, o.prototype.redInvm = function() {
                        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
                    }, o.prototype.redNeg = function() {
                        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
                    }, o.prototype.redPow = function(e) {
                        return r(this.red && !e.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e)
                    };
                    var w = {
                        k256: null,
                        p224: null,
                        p192: null,
                        p25519: null
                    };

                    function E(e, t) {
                        this.name = e, this.p = new o(t, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
                    }

                    function x() {
                        E.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                    }

                    function A() {
                        E.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                    }

                    function k() {
                        E.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                    }

                    function C() {
                        E.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                    }

                    function P(e) {
                        if ("string" === typeof e) {
                            var t = o._prime(e);
                            this.m = t.p, this.prime = t
                        } else r(e.gtn(1), "modulus must be greater than 1"), this.m = e, this.prime = null
                    }

                    function S(e) {
                        P.call(this, e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
                    }
                    E.prototype._tmp = function() {
                        var e = new o(null);
                        return e.words = new Array(Math.ceil(this.n / 13)), e
                    }, E.prototype.ireduce = function(e) {
                        var t, n = e;
                        do {
                            this.split(n, this.tmp), t = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength()
                        } while (t > this.n);
                        var r = t < this.n ? -1 : n.ucmp(this.p);
                        return 0 === r ? (n.words[0] = 0, n.length = 1) : r > 0 ? n.isub(this.p) : void 0 !== n.strip ? n.strip() : n._strip(), n
                    }, E.prototype.split = function(e, t) {
                        e.iushrn(this.n, 0, t)
                    }, E.prototype.imulK = function(e) {
                        return e.imul(this.k)
                    }, i(x, E), x.prototype.split = function(e, t) {
                        for (var n = 4194303, r = Math.min(e.length, 9), i = 0; i < r; i++) t.words[i] = e.words[i];
                        if (t.length = r, e.length <= 9) return e.words[0] = 0, void(e.length = 1);
                        var o = e.words[9];
                        for (t.words[t.length++] = o & n, i = 10; i < e.length; i++) {
                            var s = 0 | e.words[i];
                            e.words[i - 10] = (s & n) << 4 | o >>> 22, o = s
                        }
                        o >>>= 22, e.words[i - 10] = o, 0 === o && e.length > 10 ? e.length -= 10 : e.length -= 9
                    }, x.prototype.imulK = function(e) {
                        e.words[e.length] = 0, e.words[e.length + 1] = 0, e.length += 2;
                        for (var t = 0, n = 0; n < e.length; n++) {
                            var r = 0 | e.words[n];
                            t += 977 * r, e.words[n] = 67108863 & t, t = 64 * r + (t / 67108864 | 0)
                        }
                        return 0 === e.words[e.length - 1] && (e.length--, 0 === e.words[e.length - 1] && e.length--), e
                    }, i(A, E), i(k, E), i(C, E), C.prototype.imulK = function(e) {
                        for (var t = 0, n = 0; n < e.length; n++) {
                            var r = 19 * (0 | e.words[n]) + t,
                                i = 67108863 & r;
                            r >>>= 26, e.words[n] = i, t = r
                        }
                        return 0 !== t && (e.words[e.length++] = t), e
                    }, o._prime = function(e) {
                        if (w[e]) return w[e];
                        var t;
                        if ("k256" === e) t = new x;
                        else if ("p224" === e) t = new A;
                        else if ("p192" === e) t = new k;
                        else {
                            if ("p25519" !== e) throw new Error("Unknown prime " + e);
                            t = new C
                        }
                        return w[e] = t, t
                    }, P.prototype._verify1 = function(e) {
                        r(0 === e.negative, "red works only with positives"), r(e.red, "red works only with red numbers")
                    }, P.prototype._verify2 = function(e, t) {
                        r(0 === (e.negative | t.negative), "red works only with positives"), r(e.red && e.red === t.red, "red works only with red numbers")
                    }, P.prototype.imod = function(e) {
                        return this.prime ? this.prime.ireduce(e)._forceRed(this) : (c(e, e.umod(this.m)._forceRed(this)), e)
                    }, P.prototype.neg = function(e) {
                        return e.isZero() ? e.clone() : this.m.sub(e)._forceRed(this)
                    }, P.prototype.add = function(e, t) {
                        this._verify2(e, t);
                        var n = e.add(t);
                        return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this)
                    }, P.prototype.iadd = function(e, t) {
                        this._verify2(e, t);
                        var n = e.iadd(t);
                        return n.cmp(this.m) >= 0 && n.isub(this.m), n
                    }, P.prototype.sub = function(e, t) {
                        this._verify2(e, t);
                        var n = e.sub(t);
                        return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this)
                    }, P.prototype.isub = function(e, t) {
                        this._verify2(e, t);
                        var n = e.isub(t);
                        return n.cmpn(0) < 0 && n.iadd(this.m), n
                    }, P.prototype.shl = function(e, t) {
                        return this._verify1(e), this.imod(e.ushln(t))
                    }, P.prototype.imul = function(e, t) {
                        return this._verify2(e, t), this.imod(e.imul(t))
                    }, P.prototype.mul = function(e, t) {
                        return this._verify2(e, t), this.imod(e.mul(t))
                    }, P.prototype.isqr = function(e) {
                        return this.imul(e, e.clone())
                    }, P.prototype.sqr = function(e) {
                        return this.mul(e, e)
                    }, P.prototype.sqrt = function(e) {
                        if (e.isZero()) return e.clone();
                        var t = this.m.andln(3);
                        if (r(t % 2 === 1), 3 === t) {
                            var n = this.m.add(new o(1)).iushrn(2);
                            return this.pow(e, n)
                        }
                        for (var i = this.m.subn(1), s = 0; !i.isZero() && 0 === i.andln(1);) s++, i.iushrn(1);
                        r(!i.isZero());
                        var a = new o(1).toRed(this),
                            l = a.redNeg(),
                            u = this.m.subn(1).iushrn(1),
                            c = this.m.bitLength();
                        for (c = new o(2 * c * c).toRed(this); 0 !== this.pow(c, u).cmp(l);) c.redIAdd(l);
                        for (var d = this.pow(c, i), h = this.pow(e, i.addn(1).iushrn(1)), f = this.pow(e, i), p = s; 0 !== f.cmp(a);) {
                            for (var m = f, g = 0; 0 !== m.cmp(a); g++) m = m.redSqr();
                            r(g < p);
                            var y = this.pow(d, new o(1).iushln(p - g - 1));
                            h = h.redMul(y), d = y.redSqr(), f = f.redMul(d), p = g
                        }
                        return h
                    }, P.prototype.invm = function(e) {
                        var t = e._invmp(this.m);
                        return 0 !== t.negative ? (t.negative = 0, this.imod(t).redNeg()) : this.imod(t)
                    }, P.prototype.pow = function(e, t) {
                        if (t.isZero()) return new o(1).toRed(this);
                        if (0 === t.cmpn(1)) return e.clone();
                        var n = new Array(16);
                        n[0] = new o(1).toRed(this), n[1] = e;
                        for (var r = 2; r < n.length; r++) n[r] = this.mul(n[r - 1], e);
                        var i = n[0],
                            s = 0,
                            a = 0,
                            l = t.bitLength() % 26;
                        for (0 === l && (l = 26), r = t.length - 1; r >= 0; r--) {
                            for (var u = t.words[r], c = l - 1; c >= 0; c--) {
                                var d = u >> c & 1;
                                i !== n[0] && (i = this.sqr(i)), 0 !== d || 0 !== s ? (s <<= 1, s |= d, (4 === ++a || 0 === r && 0 === c) && (i = this.mul(i, n[s]), a = 0, s = 0)) : a = 0
                            }
                            l = 26
                        }
                        return i
                    }, P.prototype.convertTo = function(e) {
                        var t = e.umod(this.m);
                        return t === e ? t.clone() : t
                    }, P.prototype.convertFrom = function(e) {
                        var t = e.clone();
                        return t.red = null, t
                    }, o.mont = function(e) {
                        return new S(e)
                    }, i(S, P), S.prototype.convertTo = function(e) {
                        return this.imod(e.ushln(this.shift))
                    }, S.prototype.convertFrom = function(e) {
                        var t = this.imod(e.mul(this.rinv));
                        return t.red = null, t
                    }, S.prototype.imul = function(e, t) {
                        if (e.isZero() || t.isZero()) return e.words[0] = 0, e.length = 1, e;
                        var n = e.imul(t),
                            r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = n.isub(r).iushrn(this.shift),
                            o = i;
                        return i.cmp(this.m) >= 0 ? o = i.isub(this.m) : i.cmpn(0) < 0 && (o = i.iadd(this.m)), o._forceRed(this)
                    }, S.prototype.mul = function(e, t) {
                        if (e.isZero() || t.isZero()) return new o(0)._forceRed(this);
                        var n = e.mul(t),
                            r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = n.isub(r).iushrn(this.shift),
                            s = i;
                        return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
                    }, S.prototype.invm = function(e) {
                        return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)
                    }
                }(e = n.nmd(e), this)
            },
            7283: e => {
                "use strict";
                var t = Object.prototype.hasOwnProperty,
                    n = "~";

                function r() {}

                function i(e, t, n) {
                    this.fn = e, this.context = t, this.once = n || !1
                }

                function o(e, t, r, o, s) {
                    if ("function" !== typeof r) throw new TypeError("The listener must be a function");
                    var a = new i(r, o || e, s),
                        l = n ? n + t : t;
                    return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], a] : e._events[l].push(a) : (e._events[l] = a, e._eventsCount++), e
                }

                function s(e, t) {
                    0 === --e._eventsCount ? e._events = new r : delete e._events[t]
                }

                function a() {
                    this._events = new r, this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), a.prototype.eventNames = function() {
                    var e, r, i = [];
                    if (0 === this._eventsCount) return i;
                    for (r in e = this._events) t.call(e, r) && i.push(n ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
                }, a.prototype.listeners = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var i = 0, o = r.length, s = new Array(o); i < o; i++) s[i] = r[i].fn;
                    return s
                }, a.prototype.listenerCount = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    return r ? r.fn ? 1 : r.length : 0
                }, a.prototype.emit = function(e, t, r, i, o, s) {
                    var a = n ? n + e : e;
                    if (!this._events[a]) return !1;
                    var l, u, c = this._events[a],
                        d = arguments.length;
                    if (c.fn) {
                        switch (c.once && this.removeListener(e, c.fn, void 0, !0), d) {
                            case 1:
                                return c.fn.call(c.context), !0;
                            case 2:
                                return c.fn.call(c.context, t), !0;
                            case 3:
                                return c.fn.call(c.context, t, r), !0;
                            case 4:
                                return c.fn.call(c.context, t, r, i), !0;
                            case 5:
                                return c.fn.call(c.context, t, r, i, o), !0;
                            case 6:
                                return c.fn.call(c.context, t, r, i, o, s), !0
                        }
                        for (u = 1, l = new Array(d - 1); u < d; u++) l[u - 1] = arguments[u];
                        c.fn.apply(c.context, l)
                    } else {
                        var h, f = c.length;
                        for (u = 0; u < f; u++) switch (c[u].once && this.removeListener(e, c[u].fn, void 0, !0), d) {
                            case 1:
                                c[u].fn.call(c[u].context);
                                break;
                            case 2:
                                c[u].fn.call(c[u].context, t);
                                break;
                            case 3:
                                c[u].fn.call(c[u].context, t, r);
                                break;
                            case 4:
                                c[u].fn.call(c[u].context, t, r, i);
                                break;
                            default:
                                if (!l)
                                    for (h = 1, l = new Array(d - 1); h < d; h++) l[h - 1] = arguments[h];
                                c[u].fn.apply(c[u].context, l)
                        }
                    }
                    return !0
                }, a.prototype.on = function(e, t, n) {
                    return o(this, e, t, n, !1)
                }, a.prototype.once = function(e, t, n) {
                    return o(this, e, t, n, !0)
                }, a.prototype.removeListener = function(e, t, r, i) {
                    var o = n ? n + e : e;
                    if (!this._events[o]) return this;
                    if (!t) return s(this, o), this;
                    var a = this._events[o];
                    if (a.fn) a.fn !== t || i && !a.once || r && a.context !== r || s(this, o);
                    else {
                        for (var l = 0, u = [], c = a.length; l < c; l++)(a[l].fn !== t || i && !a[l].once || r && a[l].context !== r) && u.push(a[l]);
                        u.length ? this._events[o] = 1 === u.length ? u[0] : u : s(this, o)
                    }
                    return this
                }, a.prototype.removeAllListeners = function(e) {
                    var t;
                    return e ? (t = n ? n + e : e, this._events[t] && s(this, t)) : (this._events = new r, this._eventsCount = 0), this
                }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, e.exports = a
            },
            3697: (e, t, n) => {
                var r = t;
                r.utils = n(7643), r.common = n(2629), r.sha = n(2624), r.ripemd = n(1859), r.hmac = n(7355), r.sha1 = r.sha.sha1, r.sha256 = r.sha.sha256, r.sha224 = r.sha.sha224, r.sha384 = r.sha.sha384, r.sha512 = r.sha.sha512, r.ripemd160 = r.ripemd.ripemd160
            },
            2629: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(5482);

                function o() {
                    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
                }
                t.BlockHash = o, o.prototype.update = function(e, t) {
                    if (e = r.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
                        var n = (e = this.pending).length % this._delta8;
                        this.pending = e.slice(e.length - n, e.length), 0 === this.pending.length && (this.pending = null), e = r.join32(e, 0, e.length - n, this.endian);
                        for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
                    }
                    return this
                }, o.prototype.digest = function(e) {
                    return this.update(this._pad()), i(null === this.pending), this._digest(e)
                }, o.prototype._pad = function() {
                    var e = this.pendingTotal,
                        t = this._delta8,
                        n = t - (e + this.padLength) % t,
                        r = new Array(n + this.padLength);
                    r[0] = 128;
                    for (var i = 1; i < n; i++) r[i] = 0;
                    if (e <<= 3, "big" === this.endian) {
                        for (var o = 8; o < this.padLength; o++) r[i++] = 0;
                        r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = e >>> 24 & 255, r[i++] = e >>> 16 & 255, r[i++] = e >>> 8 & 255, r[i++] = 255 & e
                    } else
                        for (r[i++] = 255 & e, r[i++] = e >>> 8 & 255, r[i++] = e >>> 16 & 255, r[i++] = e >>> 24 & 255, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, o = 8; o < this.padLength; o++) r[i++] = 0;
                    return r
                }
            },
            7355: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(5482);

                function o(e, t, n) {
                    if (!(this instanceof o)) return new o(e, t, n);
                    this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(r.toArray(t, n))
                }
                e.exports = o, o.prototype._init = function(e) {
                    e.length > this.blockSize && (e = (new this.Hash).update(e).digest()), i(e.length <= this.blockSize);
                    for (var t = e.length; t < this.blockSize; t++) e.push(0);
                    for (t = 0; t < e.length; t++) e[t] ^= 54;
                    for (this.inner = (new this.Hash).update(e), t = 0; t < e.length; t++) e[t] ^= 106;
                    this.outer = (new this.Hash).update(e)
                }, o.prototype.update = function(e, t) {
                    return this.inner.update(e, t), this
                }, o.prototype.digest = function(e) {
                    return this.outer.update(this.inner.digest()), this.outer.digest(e)
                }
            },
            1859: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(2629),
                    o = r.rotl32,
                    s = r.sum32,
                    a = r.sum32_3,
                    l = r.sum32_4,
                    u = i.BlockHash;

                function c() {
                    if (!(this instanceof c)) return new c;
                    u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
                }

                function d(e, t, n, r) {
                    return e <= 15 ? t ^ n ^ r : e <= 31 ? t & n | ~t & r : e <= 47 ? (t | ~n) ^ r : e <= 63 ? t & r | n & ~r : t ^ (n | ~r)
                }

                function h(e) {
                    return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838
                }

                function f(e) {
                    return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0
                }
                r.inherits(c, u), t.ripemd160 = c, c.blockSize = 512, c.outSize = 160, c.hmacStrength = 192, c.padLength = 64, c.prototype._update = function(e, t) {
                    for (var n = this.h[0], r = this.h[1], i = this.h[2], u = this.h[3], c = this.h[4], v = n, b = r, w = i, E = u, x = c, A = 0; A < 80; A++) {
                        var k = s(o(l(n, d(A, r, i, u), e[p[A] + t], h(A)), g[A]), c);
                        n = c, c = u, u = o(i, 10), i = r, r = k, k = s(o(l(v, d(79 - A, b, w, E), e[m[A] + t], f(A)), y[A]), x), v = x, x = E, E = o(w, 10), w = b, b = k
                    }
                    k = a(this.h[1], i, E), this.h[1] = a(this.h[2], u, x), this.h[2] = a(this.h[3], c, v), this.h[3] = a(this.h[4], n, b), this.h[4] = a(this.h[0], r, w), this.h[0] = k
                }, c.prototype._digest = function(e) {
                    return "hex" === e ? r.toHex32(this.h, "little") : r.split32(this.h, "little")
                };
                var p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
                    m = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
                    g = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
                    y = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
            },
            2624: (e, t, n) => {
                "use strict";
                t.sha1 = n(2236), t.sha224 = n(3291), t.sha256 = n(3410), t.sha384 = n(4282), t.sha512 = n(2155)
            },
            2236: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(2629),
                    o = n(1510),
                    s = r.rotl32,
                    a = r.sum32,
                    l = r.sum32_5,
                    u = o.ft_1,
                    c = i.BlockHash,
                    d = [1518500249, 1859775393, 2400959708, 3395469782];

                function h() {
                    if (!(this instanceof h)) return new h;
                    c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
                }
                r.inherits(h, c), e.exports = h, h.blockSize = 512, h.outSize = 160, h.hmacStrength = 80, h.padLength = 64, h.prototype._update = function(e, t) {
                    for (var n = this.W, r = 0; r < 16; r++) n[r] = e[t + r];
                    for (; r < n.length; r++) n[r] = s(n[r - 3] ^ n[r - 8] ^ n[r - 14] ^ n[r - 16], 1);
                    var i = this.h[0],
                        o = this.h[1],
                        c = this.h[2],
                        h = this.h[3],
                        f = this.h[4];
                    for (r = 0; r < n.length; r++) {
                        var p = ~~(r / 20),
                            m = l(s(i, 5), u(p, o, c, h), f, n[r], d[p]);
                        f = h, h = c, c = s(o, 30), o = i, i = m
                    }
                    this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], o), this.h[2] = a(this.h[2], c), this.h[3] = a(this.h[3], h), this.h[4] = a(this.h[4], f)
                }, h.prototype._digest = function(e) {
                    return "hex" === e ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
                }
            },
            3291: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(3410);

                function o() {
                    if (!(this instanceof o)) return new o;
                    i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
                }
                r.inherits(o, i), e.exports = o, o.blockSize = 512, o.outSize = 224, o.hmacStrength = 192, o.padLength = 64, o.prototype._digest = function(e) {
                    return "hex" === e ? r.toHex32(this.h.slice(0, 7), "big") : r.split32(this.h.slice(0, 7), "big")
                }
            },
            3410: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(2629),
                    o = n(1510),
                    s = n(5482),
                    a = r.sum32,
                    l = r.sum32_4,
                    u = r.sum32_5,
                    c = o.ch32,
                    d = o.maj32,
                    h = o.s0_256,
                    f = o.s1_256,
                    p = o.g0_256,
                    m = o.g1_256,
                    g = i.BlockHash,
                    y = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

                function v() {
                    if (!(this instanceof v)) return new v;
                    g.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = y, this.W = new Array(64)
                }
                r.inherits(v, g), e.exports = v, v.blockSize = 512, v.outSize = 256, v.hmacStrength = 192, v.padLength = 64, v.prototype._update = function(e, t) {
                    for (var n = this.W, r = 0; r < 16; r++) n[r] = e[t + r];
                    for (; r < n.length; r++) n[r] = l(m(n[r - 2]), n[r - 7], p(n[r - 15]), n[r - 16]);
                    var i = this.h[0],
                        o = this.h[1],
                        g = this.h[2],
                        y = this.h[3],
                        v = this.h[4],
                        b = this.h[5],
                        w = this.h[6],
                        E = this.h[7];
                    for (s(this.k.length === n.length), r = 0; r < n.length; r++) {
                        var x = u(E, f(v), c(v, b, w), this.k[r], n[r]),
                            A = a(h(i), d(i, o, g));
                        E = w, w = b, b = v, v = a(y, x), y = g, g = o, o = i, i = a(x, A)
                    }
                    this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], o), this.h[2] = a(this.h[2], g), this.h[3] = a(this.h[3], y), this.h[4] = a(this.h[4], v), this.h[5] = a(this.h[5], b), this.h[6] = a(this.h[6], w), this.h[7] = a(this.h[7], E)
                }, v.prototype._digest = function(e) {
                    return "hex" === e ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
                }
            },
            4282: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(2155);

                function o() {
                    if (!(this instanceof o)) return new o;
                    i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
                }
                r.inherits(o, i), e.exports = o, o.blockSize = 1024, o.outSize = 384, o.hmacStrength = 192, o.padLength = 128, o.prototype._digest = function(e) {
                    return "hex" === e ? r.toHex32(this.h.slice(0, 12), "big") : r.split32(this.h.slice(0, 12), "big")
                }
            },
            2155: (e, t, n) => {
                "use strict";
                var r = n(7643),
                    i = n(2629),
                    o = n(5482),
                    s = r.rotr64_hi,
                    a = r.rotr64_lo,
                    l = r.shr64_hi,
                    u = r.shr64_lo,
                    c = r.sum64,
                    d = r.sum64_hi,
                    h = r.sum64_lo,
                    f = r.sum64_4_hi,
                    p = r.sum64_4_lo,
                    m = r.sum64_5_hi,
                    g = r.sum64_5_lo,
                    y = i.BlockHash,
                    v = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

                function b() {
                    if (!(this instanceof b)) return new b;
                    y.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = v, this.W = new Array(160)
                }

                function w(e, t, n, r, i) {
                    var o = e & n ^ ~e & i;
                    return o < 0 && (o += 4294967296), o
                }

                function E(e, t, n, r, i, o) {
                    var s = t & r ^ ~t & o;
                    return s < 0 && (s += 4294967296), s
                }

                function x(e, t, n, r, i) {
                    var o = e & n ^ e & i ^ n & i;
                    return o < 0 && (o += 4294967296), o
                }

                function A(e, t, n, r, i, o) {
                    var s = t & r ^ t & o ^ r & o;
                    return s < 0 && (s += 4294967296), s
                }

                function k(e, t) {
                    var n = s(e, t, 28) ^ s(t, e, 2) ^ s(t, e, 7);
                    return n < 0 && (n += 4294967296), n
                }

                function C(e, t) {
                    var n = a(e, t, 28) ^ a(t, e, 2) ^ a(t, e, 7);
                    return n < 0 && (n += 4294967296), n
                }

                function P(e, t) {
                    var n = s(e, t, 14) ^ s(e, t, 18) ^ s(t, e, 9);
                    return n < 0 && (n += 4294967296), n
                }

                function S(e, t) {
                    var n = a(e, t, 14) ^ a(e, t, 18) ^ a(t, e, 9);
                    return n < 0 && (n += 4294967296), n
                }

                function _(e, t) {
                    var n = s(e, t, 1) ^ s(e, t, 8) ^ l(e, t, 7);
                    return n < 0 && (n += 4294967296), n
                }

                function N(e, t) {
                    var n = a(e, t, 1) ^ a(e, t, 8) ^ u(e, t, 7);
                    return n < 0 && (n += 4294967296), n
                }

                function M(e, t) {
                    var n = s(e, t, 19) ^ s(t, e, 29) ^ l(e, t, 6);
                    return n < 0 && (n += 4294967296), n
                }

                function I(e, t) {
                    var n = a(e, t, 19) ^ a(t, e, 29) ^ u(e, t, 6);
                    return n < 0 && (n += 4294967296), n
                }
                r.inherits(b, y), e.exports = b, b.blockSize = 1024, b.outSize = 512, b.hmacStrength = 192, b.padLength = 128, b.prototype._prepareBlock = function(e, t) {
                    for (var n = this.W, r = 0; r < 32; r++) n[r] = e[t + r];
                    for (; r < n.length; r += 2) {
                        var i = M(n[r - 4], n[r - 3]),
                            o = I(n[r - 4], n[r - 3]),
                            s = n[r - 14],
                            a = n[r - 13],
                            l = _(n[r - 30], n[r - 29]),
                            u = N(n[r - 30], n[r - 29]),
                            c = n[r - 32],
                            d = n[r - 31];
                        n[r] = f(i, o, s, a, l, u, c, d), n[r + 1] = p(i, o, s, a, l, u, c, d)
                    }
                }, b.prototype._update = function(e, t) {
                    this._prepareBlock(e, t);
                    var n = this.W,
                        r = this.h[0],
                        i = this.h[1],
                        s = this.h[2],
                        a = this.h[3],
                        l = this.h[4],
                        u = this.h[5],
                        f = this.h[6],
                        p = this.h[7],
                        y = this.h[8],
                        v = this.h[9],
                        b = this.h[10],
                        _ = this.h[11],
                        N = this.h[12],
                        M = this.h[13],
                        I = this.h[14],
                        O = this.h[15];
                    o(this.k.length === n.length);
                    for (var T = 0; T < n.length; T += 2) {
                        var R = I,
                            L = O,
                            B = P(y, v),
                            F = S(y, v),
                            j = w(y, v, b, _, N),
                            D = E(y, v, b, _, N, M),
                            U = this.k[T],
                            z = this.k[T + 1],
                            q = n[T],
                            G = n[T + 1],
                            H = m(R, L, B, F, j, D, U, z, q, G),
                            $ = g(R, L, B, F, j, D, U, z, q, G);
                        R = k(r, i), L = C(r, i), B = x(r, i, s, a, l), F = A(r, i, s, a, l, u);
                        var Q = d(R, L, B, F),
                            V = h(R, L, B, F);
                        I = N, O = M, N = b, M = _, b = y, _ = v, y = d(f, p, H, $), v = h(p, p, H, $), f = l, p = u, l = s, u = a, s = r, a = i, r = d(H, $, Q, V), i = h(H, $, Q, V)
                    }
                    c(this.h, 0, r, i), c(this.h, 2, s, a), c(this.h, 4, l, u), c(this.h, 6, f, p), c(this.h, 8, y, v), c(this.h, 10, b, _), c(this.h, 12, N, M), c(this.h, 14, I, O)
                }, b.prototype._digest = function(e) {
                    return "hex" === e ? r.toHex32(this.h, "big") : r.split32(this.h, "big")
                }
            },
            1510: (e, t, n) => {
                "use strict";
                var r = n(7643).rotr32;

                function i(e, t, n) {
                    return e & t ^ ~e & n
                }

                function o(e, t, n) {
                    return e & t ^ e & n ^ t & n
                }

                function s(e, t, n) {
                    return e ^ t ^ n
                }
                t.ft_1 = function(e, t, n, r) {
                    return 0 === e ? i(t, n, r) : 1 === e || 3 === e ? s(t, n, r) : 2 === e ? o(t, n, r) : void 0
                }, t.ch32 = i, t.maj32 = o, t.p32 = s, t.s0_256 = function(e) {
                    return r(e, 2) ^ r(e, 13) ^ r(e, 22)
                }, t.s1_256 = function(e) {
                    return r(e, 6) ^ r(e, 11) ^ r(e, 25)
                }, t.g0_256 = function(e) {
                    return r(e, 7) ^ r(e, 18) ^ e >>> 3
                }, t.g1_256 = function(e) {
                    return r(e, 17) ^ r(e, 19) ^ e >>> 10
                }
            },
            7643: (e, t, n) => {
                "use strict";
                var r = n(5482),
                    i = n(6329);

                function o(e, t) {
                    return 55296 === (64512 & e.charCodeAt(t)) && (!(t < 0 || t + 1 >= e.length) && 56320 === (64512 & e.charCodeAt(t + 1)))
                }

                function s(e) {
                    return (e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (255 & e) << 24) >>> 0
                }

                function a(e) {
                    return 1 === e.length ? "0" + e : e
                }

                function l(e) {
                    return 7 === e.length ? "0" + e : 6 === e.length ? "00" + e : 5 === e.length ? "000" + e : 4 === e.length ? "0000" + e : 3 === e.length ? "00000" + e : 2 === e.length ? "000000" + e : 1 === e.length ? "0000000" + e : e
                }
                t.inherits = i, t.toArray = function(e, t) {
                    if (Array.isArray(e)) return e.slice();
                    if (!e) return [];
                    var n = [];
                    if ("string" === typeof e)
                        if (t) {
                            if ("hex" === t)
                                for ((e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 !== 0 && (e = "0" + e), i = 0; i < e.length; i += 2) n.push(parseInt(e[i] + e[i + 1], 16))
                        } else
                            for (var r = 0, i = 0; i < e.length; i++) {
                                var s = e.charCodeAt(i);
                                s < 128 ? n[r++] = s : s < 2048 ? (n[r++] = s >> 6 | 192, n[r++] = 63 & s | 128) : o(e, i) ? (s = 65536 + ((1023 & s) << 10) + (1023 & e.charCodeAt(++i)), n[r++] = s >> 18 | 240, n[r++] = s >> 12 & 63 | 128, n[r++] = s >> 6 & 63 | 128, n[r++] = 63 & s | 128) : (n[r++] = s >> 12 | 224, n[r++] = s >> 6 & 63 | 128, n[r++] = 63 & s | 128)
                            } else
                                for (i = 0; i < e.length; i++) n[i] = 0 | e[i];
                    return n
                }, t.toHex = function(e) {
                    for (var t = "", n = 0; n < e.length; n++) t += a(e[n].toString(16));
                    return t
                }, t.htonl = s, t.toHex32 = function(e, t) {
                    for (var n = "", r = 0; r < e.length; r++) {
                        var i = e[r];
                        "little" === t && (i = s(i)), n += l(i.toString(16))
                    }
                    return n
                }, t.zero2 = a, t.zero8 = l, t.join32 = function(e, t, n, i) {
                    var o = n - t;
                    r(o % 4 === 0);
                    for (var s = new Array(o / 4), a = 0, l = t; a < s.length; a++, l += 4) {
                        var u;
                        u = "big" === i ? e[l] << 24 | e[l + 1] << 16 | e[l + 2] << 8 | e[l + 3] : e[l + 3] << 24 | e[l + 2] << 16 | e[l + 1] << 8 | e[l], s[a] = u >>> 0
                    }
                    return s
                }, t.split32 = function(e, t) {
                    for (var n = new Array(4 * e.length), r = 0, i = 0; r < e.length; r++, i += 4) {
                        var o = e[r];
                        "big" === t ? (n[i] = o >>> 24, n[i + 1] = o >>> 16 & 255, n[i + 2] = o >>> 8 & 255, n[i + 3] = 255 & o) : (n[i + 3] = o >>> 24, n[i + 2] = o >>> 16 & 255, n[i + 1] = o >>> 8 & 255, n[i] = 255 & o)
                    }
                    return n
                }, t.rotr32 = function(e, t) {
                    return e >>> t | e << 32 - t
                }, t.rotl32 = function(e, t) {
                    return e << t | e >>> 32 - t
                }, t.sum32 = function(e, t) {
                    return e + t >>> 0
                }, t.sum32_3 = function(e, t, n) {
                    return e + t + n >>> 0
                }, t.sum32_4 = function(e, t, n, r) {
                    return e + t + n + r >>> 0
                }, t.sum32_5 = function(e, t, n, r, i) {
                    return e + t + n + r + i >>> 0
                }, t.sum64 = function(e, t, n, r) {
                    var i = e[t],
                        o = r + e[t + 1] >>> 0,
                        s = (o < r ? 1 : 0) + n + i;
                    e[t] = s >>> 0, e[t + 1] = o
                }, t.sum64_hi = function(e, t, n, r) {
                    return (t + r >>> 0 < t ? 1 : 0) + e + n >>> 0
                }, t.sum64_lo = function(e, t, n, r) {
                    return t + r >>> 0
                }, t.sum64_4_hi = function(e, t, n, r, i, o, s, a) {
                    var l = 0,
                        u = t;
                    return l += (u = u + r >>> 0) < t ? 1 : 0, l += (u = u + o >>> 0) < o ? 1 : 0, e + n + i + s + (l += (u = u + a >>> 0) < a ? 1 : 0) >>> 0
                }, t.sum64_4_lo = function(e, t, n, r, i, o, s, a) {
                    return t + r + o + a >>> 0
                }, t.sum64_5_hi = function(e, t, n, r, i, o, s, a, l, u) {
                    var c = 0,
                        d = t;
                    return c += (d = d + r >>> 0) < t ? 1 : 0, c += (d = d + o >>> 0) < o ? 1 : 0, c += (d = d + a >>> 0) < a ? 1 : 0, e + n + i + s + l + (c += (d = d + u >>> 0) < u ? 1 : 0) >>> 0
                }, t.sum64_5_lo = function(e, t, n, r, i, o, s, a, l, u) {
                    return t + r + o + a + u >>> 0
                }, t.rotr64_hi = function(e, t, n) {
                    return (t << 32 - n | e >>> n) >>> 0
                }, t.rotr64_lo = function(e, t, n) {
                    return (e << 32 - n | t >>> n) >>> 0
                }, t.shr64_hi = function(e, t, n) {
                    return e >>> n
                }, t.shr64_lo = function(e, t, n) {
                    return (e << 32 - n | t >>> n) >>> 0
                }
            },
            6329: e => {
                "function" === typeof Object.create ? e.exports = function(e, t) {
                    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }))
                } : e.exports = function(e, t) {
                    if (t) {
                        e.super_ = t;
                        var n = function() {};
                        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
                    }
                }
            },
            2161: (e, t, n) => {
                var r;
                ! function() {
                    "use strict";
                    var i = "input is invalid type",
                        o = "object" === typeof window,
                        s = o ? window : {};
                    s.JS_SHA3_NO_WINDOW && (o = !1);
                    var a = !o && "object" === typeof self;
                    !s.JS_SHA3_NO_NODE_JS && "object" === typeof process && process.versions && process.versions.node ? s = n.g : a && (s = self);
                    var l = !s.JS_SHA3_NO_COMMON_JS && e.exports,
                        u = n.amdO,
                        c = !s.JS_SHA3_NO_ARRAY_BUFFER && "undefined" !== typeof ArrayBuffer,
                        d = "0123456789abcdef".split(""),
                        h = [4, 1024, 262144, 67108864],
                        f = [0, 8, 16, 24],
                        p = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
                        m = [224, 256, 384, 512],
                        g = [128, 256],
                        y = ["hex", "buffer", "arrayBuffer", "array", "digest"],
                        v = {
                            128: 168,
                            256: 136
                        };
                    !s.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                        return "[object Array]" === Object.prototype.toString.call(e)
                    }), !c || !s.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                        return "object" === typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                    });
                    for (var b = function(e, t, n) {
                            return function(r) {
                                return new R(e, t, e).update(r)[n]()
                            }
                        }, w = function(e, t, n) {
                            return function(r, i) {
                                return new R(e, t, i).update(r)[n]()
                            }
                        }, E = function(e, t, n) {
                            return function(t, r, i, o) {
                                return P["cshake" + e].update(t, r, i, o)[n]()
                            }
                        }, x = function(e, t, n) {
                            return function(t, r, i, o) {
                                return P["kmac" + e].update(t, r, i, o)[n]()
                            }
                        }, A = function(e, t, n, r) {
                            for (var i = 0; i < y.length; ++i) {
                                var o = y[i];
                                e[o] = t(n, r, o)
                            }
                            return e
                        }, k = function(e, t) {
                            var n = b(e, t, "hex");
                            return n.create = function() {
                                return new R(e, t, e)
                            }, n.update = function(e) {
                                return n.create().update(e)
                            }, A(n, b, e, t)
                        }, C = [{
                            name: "keccak",
                            padding: [1, 256, 65536, 16777216],
                            bits: m,
                            createMethod: k
                        }, {
                            name: "sha3",
                            padding: [6, 1536, 393216, 100663296],
                            bits: m,
                            createMethod: k
                        }, {
                            name: "shake",
                            padding: [31, 7936, 2031616, 520093696],
                            bits: g,
                            createMethod: function(e, t) {
                                var n = w(e, t, "hex");
                                return n.create = function(n) {
                                    return new R(e, t, n)
                                }, n.update = function(e, t) {
                                    return n.create(t).update(e)
                                }, A(n, w, e, t)
                            }
                        }, {
                            name: "cshake",
                            padding: h,
                            bits: g,
                            createMethod: function(e, t) {
                                var n = v[e],
                                    r = E(e, 0, "hex");
                                return r.create = function(r, i, o) {
                                    return i || o ? new R(e, t, r).bytepad([i, o], n) : P["shake" + e].create(r)
                                }, r.update = function(e, t, n, i) {
                                    return r.create(t, n, i).update(e)
                                }, A(r, E, e, t)
                            }
                        }, {
                            name: "kmac",
                            padding: h,
                            bits: g,
                            createMethod: function(e, t) {
                                var n = v[e],
                                    r = x(e, 0, "hex");
                                return r.create = function(r, i, o) {
                                    return new L(e, t, i).bytepad(["KMAC", o], n).bytepad([r], n)
                                }, r.update = function(e, t, n, i) {
                                    return r.create(e, n, i).update(t)
                                }, A(r, x, e, t)
                            }
                        }], P = {}, S = [], _ = 0; _ < C.length; ++_)
                        for (var N = C[_], M = N.bits, I = 0; I < M.length; ++I) {
                            var O = N.name + "_" + M[I];
                            if (S.push(O), P[O] = N.createMethod(M[I], N.padding), "sha3" !== N.name) {
                                var T = N.name + M[I];
                                S.push(T), P[T] = P[O]
                            }
                        }

                    function R(e, t, n) {
                        this.blocks = [], this.s = [], this.padding = t, this.outputBits = n, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (e << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = n >> 5, this.extraBytes = (31 & n) >> 3;
                        for (var r = 0; r < 50; ++r) this.s[r] = 0
                    }

                    function L(e, t, n) {
                        R.call(this, e, t, n)
                    }
                    R.prototype.update = function(e) {
                        if (this.finalized) throw new Error("finalize already called");
                        var t, n = typeof e;
                        if ("string" !== n) {
                            if ("object" !== n) throw new Error(i);
                            if (null === e) throw new Error(i);
                            if (c && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                            else if (!Array.isArray(e) && (!c || !ArrayBuffer.isView(e))) throw new Error(i);
                            t = !0
                        }
                        for (var r, o, s = this.blocks, a = this.byteCount, l = e.length, u = this.blockCount, d = 0, h = this.s; d < l;) {
                            if (this.reset)
                                for (this.reset = !1, s[0] = this.block, r = 1; r < u + 1; ++r) s[r] = 0;
                            if (t)
                                for (r = this.start; d < l && r < a; ++d) s[r >> 2] |= e[d] << f[3 & r++];
                            else
                                for (r = this.start; d < l && r < a; ++d)(o = e.charCodeAt(d)) < 128 ? s[r >> 2] |= o << f[3 & r++] : o < 2048 ? (s[r >> 2] |= (192 | o >> 6) << f[3 & r++], s[r >> 2] |= (128 | 63 & o) << f[3 & r++]) : o < 55296 || o >= 57344 ? (s[r >> 2] |= (224 | o >> 12) << f[3 & r++], s[r >> 2] |= (128 | o >> 6 & 63) << f[3 & r++], s[r >> 2] |= (128 | 63 & o) << f[3 & r++]) : (o = 65536 + ((1023 & o) << 10 | 1023 & e.charCodeAt(++d)), s[r >> 2] |= (240 | o >> 18) << f[3 & r++], s[r >> 2] |= (128 | o >> 12 & 63) << f[3 & r++], s[r >> 2] |= (128 | o >> 6 & 63) << f[3 & r++], s[r >> 2] |= (128 | 63 & o) << f[3 & r++]);
                            if (this.lastByteIndex = r, r >= a) {
                                for (this.start = r - a, this.block = s[u], r = 0; r < u; ++r) h[r] ^= s[r];
                                B(h), this.reset = !0
                            } else this.start = r
                        }
                        return this
                    }, R.prototype.encode = function(e, t) {
                        var n = 255 & e,
                            r = 1,
                            i = [n];
                        for (n = 255 & (e >>= 8); n > 0;) i.unshift(n), n = 255 & (e >>= 8), ++r;
                        return t ? i.push(r) : i.unshift(r), this.update(i), i.length
                    }, R.prototype.encodeString = function(e) {
                        var t, n = typeof e;
                        if ("string" !== n) {
                            if ("object" !== n) throw new Error(i);
                            if (null === e) throw new Error(i);
                            if (c && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                            else if (!Array.isArray(e) && (!c || !ArrayBuffer.isView(e))) throw new Error(i);
                            t = !0
                        }
                        var r = 0,
                            o = e.length;
                        if (t) r = o;
                        else
                            for (var s = 0; s < e.length; ++s) {
                                var a = e.charCodeAt(s);
                                a < 128 ? r += 1 : a < 2048 ? r += 2 : a < 55296 || a >= 57344 ? r += 3 : (a = 65536 + ((1023 & a) << 10 | 1023 & e.charCodeAt(++s)), r += 4)
                            }
                        return r += this.encode(8 * r), this.update(e), r
                    }, R.prototype.bytepad = function(e, t) {
                        for (var n = this.encode(t), r = 0; r < e.length; ++r) n += this.encodeString(e[r]);
                        var i = t - n % t,
                            o = [];
                        return o.length = i, this.update(o), this
                    }, R.prototype.finalize = function() {
                        if (!this.finalized) {
                            this.finalized = !0;
                            var e = this.blocks,
                                t = this.lastByteIndex,
                                n = this.blockCount,
                                r = this.s;
                            if (e[t >> 2] |= this.padding[3 & t], this.lastByteIndex === this.byteCount)
                                for (e[0] = e[n], t = 1; t < n + 1; ++t) e[t] = 0;
                            for (e[n - 1] |= 2147483648, t = 0; t < n; ++t) r[t] ^= e[t];
                            B(r)
                        }
                    }, R.prototype.toString = R.prototype.hex = function() {
                        this.finalize();
                        for (var e, t = this.blockCount, n = this.s, r = this.outputBlocks, i = this.extraBytes, o = 0, s = 0, a = ""; s < r;) {
                            for (o = 0; o < t && s < r; ++o, ++s) e = n[o], a += d[e >> 4 & 15] + d[15 & e] + d[e >> 12 & 15] + d[e >> 8 & 15] + d[e >> 20 & 15] + d[e >> 16 & 15] + d[e >> 28 & 15] + d[e >> 24 & 15];
                            s % t === 0 && (B(n), o = 0)
                        }
                        return i && (e = n[o], a += d[e >> 4 & 15] + d[15 & e], i > 1 && (a += d[e >> 12 & 15] + d[e >> 8 & 15]), i > 2 && (a += d[e >> 20 & 15] + d[e >> 16 & 15])), a
                    }, R.prototype.arrayBuffer = function() {
                        this.finalize();
                        var e, t = this.blockCount,
                            n = this.s,
                            r = this.outputBlocks,
                            i = this.extraBytes,
                            o = 0,
                            s = 0,
                            a = this.outputBits >> 3;
                        e = i ? new ArrayBuffer(r + 1 << 2) : new ArrayBuffer(a);
                        for (var l = new Uint32Array(e); s < r;) {
                            for (o = 0; o < t && s < r; ++o, ++s) l[s] = n[o];
                            s % t === 0 && B(n)
                        }
                        return i && (l[o] = n[o], e = e.slice(0, a)), e
                    }, R.prototype.buffer = R.prototype.arrayBuffer, R.prototype.digest = R.prototype.array = function() {
                        this.finalize();
                        for (var e, t, n = this.blockCount, r = this.s, i = this.outputBlocks, o = this.extraBytes, s = 0, a = 0, l = []; a < i;) {
                            for (s = 0; s < n && a < i; ++s, ++a) e = a << 2, t = r[s], l[e] = 255 & t, l[e + 1] = t >> 8 & 255, l[e + 2] = t >> 16 & 255, l[e + 3] = t >> 24 & 255;
                            a % n === 0 && B(r)
                        }
                        return o && (e = a << 2, t = r[s], l[e] = 255 & t, o > 1 && (l[e + 1] = t >> 8 & 255), o > 2 && (l[e + 2] = t >> 16 & 255)), l
                    }, L.prototype = new R, L.prototype.finalize = function() {
                        return this.encode(this.outputBits, !0), R.prototype.finalize.call(this)
                    };
                    var B = function(e) {
                        var t, n, r, i, o, s, a, l, u, c, d, h, f, m, g, y, v, b, w, E, x, A, k, C, P, S, _, N, M, I, O, T, R, L, B, F, j, D, U, z, q, G, H, $, Q, V, K, W, J, Z, Y, X, ee, te, ne, re, ie, oe, se, ae, le, ue, ce;
                        for (r = 0; r < 48; r += 2) i = e[0] ^ e[10] ^ e[20] ^ e[30] ^ e[40], o = e[1] ^ e[11] ^ e[21] ^ e[31] ^ e[41], s = e[2] ^ e[12] ^ e[22] ^ e[32] ^ e[42], a = e[3] ^ e[13] ^ e[23] ^ e[33] ^ e[43], l = e[4] ^ e[14] ^ e[24] ^ e[34] ^ e[44], u = e[5] ^ e[15] ^ e[25] ^ e[35] ^ e[45], c = e[6] ^ e[16] ^ e[26] ^ e[36] ^ e[46], d = e[7] ^ e[17] ^ e[27] ^ e[37] ^ e[47], t = (h = e[8] ^ e[18] ^ e[28] ^ e[38] ^ e[48]) ^ (s << 1 | a >>> 31), n = (f = e[9] ^ e[19] ^ e[29] ^ e[39] ^ e[49]) ^ (a << 1 | s >>> 31), e[0] ^= t, e[1] ^= n, e[10] ^= t, e[11] ^= n, e[20] ^= t, e[21] ^= n, e[30] ^= t, e[31] ^= n, e[40] ^= t, e[41] ^= n, t = i ^ (l << 1 | u >>> 31), n = o ^ (u << 1 | l >>> 31), e[2] ^= t, e[3] ^= n, e[12] ^= t, e[13] ^= n, e[22] ^= t, e[23] ^= n, e[32] ^= t, e[33] ^= n, e[42] ^= t, e[43] ^= n, t = s ^ (c << 1 | d >>> 31), n = a ^ (d << 1 | c >>> 31), e[4] ^= t, e[5] ^= n, e[14] ^= t, e[15] ^= n, e[24] ^= t, e[25] ^= n, e[34] ^= t, e[35] ^= n, e[44] ^= t, e[45] ^= n, t = l ^ (h << 1 | f >>> 31), n = u ^ (f << 1 | h >>> 31), e[6] ^= t, e[7] ^= n, e[16] ^= t, e[17] ^= n, e[26] ^= t, e[27] ^= n, e[36] ^= t, e[37] ^= n, e[46] ^= t, e[47] ^= n, t = c ^ (i << 1 | o >>> 31), n = d ^ (o << 1 | i >>> 31), e[8] ^= t, e[9] ^= n, e[18] ^= t, e[19] ^= n, e[28] ^= t, e[29] ^= n, e[38] ^= t, e[39] ^= n, e[48] ^= t, e[49] ^= n, m = e[0], g = e[1], V = e[11] << 4 | e[10] >>> 28, K = e[10] << 4 | e[11] >>> 28, N = e[20] << 3 | e[21] >>> 29, M = e[21] << 3 | e[20] >>> 29, ae = e[31] << 9 | e[30] >>> 23, le = e[30] << 9 | e[31] >>> 23, G = e[40] << 18 | e[41] >>> 14, H = e[41] << 18 | e[40] >>> 14, L = e[2] << 1 | e[3] >>> 31, B = e[3] << 1 | e[2] >>> 31, y = e[13] << 12 | e[12] >>> 20, v = e[12] << 12 | e[13] >>> 20, W = e[22] << 10 | e[23] >>> 22, J = e[23] << 10 | e[22] >>> 22, I = e[33] << 13 | e[32] >>> 19, O = e[32] << 13 | e[33] >>> 19, ue = e[42] << 2 | e[43] >>> 30, ce = e[43] << 2 | e[42] >>> 30, te = e[5] << 30 | e[4] >>> 2, ne = e[4] << 30 | e[5] >>> 2, F = e[14] << 6 | e[15] >>> 26, j = e[15] << 6 | e[14] >>> 26, b = e[25] << 11 | e[24] >>> 21, w = e[24] << 11 | e[25] >>> 21, Z = e[34] << 15 | e[35] >>> 17, Y = e[35] << 15 | e[34] >>> 17, T = e[45] << 29 | e[44] >>> 3, R = e[44] << 29 | e[45] >>> 3, C = e[6] << 28 | e[7] >>> 4, P = e[7] << 28 | e[6] >>> 4, re = e[17] << 23 | e[16] >>> 9, ie = e[16] << 23 | e[17] >>> 9, D = e[26] << 25 | e[27] >>> 7, U = e[27] << 25 | e[26] >>> 7, E = e[36] << 21 | e[37] >>> 11, x = e[37] << 21 | e[36] >>> 11, X = e[47] << 24 | e[46] >>> 8, ee = e[46] << 24 | e[47] >>> 8, $ = e[8] << 27 | e[9] >>> 5, Q = e[9] << 27 | e[8] >>> 5, S = e[18] << 20 | e[19] >>> 12, _ = e[19] << 20 | e[18] >>> 12, oe = e[29] << 7 | e[28] >>> 25, se = e[28] << 7 | e[29] >>> 25, z = e[38] << 8 | e[39] >>> 24, q = e[39] << 8 | e[38] >>> 24, A = e[48] << 14 | e[49] >>> 18, k = e[49] << 14 | e[48] >>> 18, e[0] = m ^ ~y & b, e[1] = g ^ ~v & w, e[10] = C ^ ~S & N, e[11] = P ^ ~_ & M, e[20] = L ^ ~F & D, e[21] = B ^ ~j & U, e[30] = $ ^ ~V & W, e[31] = Q ^ ~K & J, e[40] = te ^ ~re & oe, e[41] = ne ^ ~ie & se, e[2] = y ^ ~b & E, e[3] = v ^ ~w & x, e[12] = S ^ ~N & I, e[13] = _ ^ ~M & O, e[22] = F ^ ~D & z, e[23] = j ^ ~U & q, e[32] = V ^ ~W & Z, e[33] = K ^ ~J & Y, e[42] = re ^ ~oe & ae, e[43] = ie ^ ~se & le, e[4] = b ^ ~E & A, e[5] = w ^ ~x & k, e[14] = N ^ ~I & T, e[15] = M ^ ~O & R, e[24] = D ^ ~z & G, e[25] = U ^ ~q & H, e[34] = W ^ ~Z & X, e[35] = J ^ ~Y & ee, e[44] = oe ^ ~ae & ue, e[45] = se ^ ~le & ce, e[6] = E ^ ~A & m, e[7] = x ^ ~k & g, e[16] = I ^ ~T & C, e[17] = O ^ ~R & P, e[26] = z ^ ~G & L, e[27] = q ^ ~H & B, e[36] = Z ^ ~X & $, e[37] = Y ^ ~ee & Q, e[46] = ae ^ ~ue & te, e[47] = le ^ ~ce & ne, e[8] = A ^ ~m & y, e[9] = k ^ ~g & v, e[18] = T ^ ~C & S, e[19] = R ^ ~P & _, e[28] = G ^ ~L & F, e[29] = H ^ ~B & j, e[38] = X ^ ~$ & V, e[39] = ee ^ ~Q & K, e[48] = ue ^ ~te & re, e[49] = ce ^ ~ne & ie, e[0] ^= p[r], e[1] ^= p[r + 1]
                    };
                    if (l) e.exports = P;
                    else {
                        for (_ = 0; _ < S.length; ++_) s[S[_]] = P[S[_]];
                        u && (void 0 === (r = function() {
                            return P
                        }.call(t, n, t, e)) || (e.exports = r))
                    }
                }()
            },
            5482: e => {
                function t(e, t) {
                    if (!e) throw new Error(t || "Assertion failed")
                }
                e.exports = t, t.equal = function(e, t, n) {
                    if (e != t) throw new Error(n || "Assertion failed: " + e + " != " + t)
                }
            },
            1497: (e, t, n) => {
                "use strict";
                var r = n(3218);

                function i() {}

                function o() {}
                o.resetWarningCache = i, e.exports = function() {
                    function e(e, t, n, i, o, s) {
                        if (s !== r) {
                            var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                            throw a.name = "Invariant Violation", a
                        }
                    }

                    function t() {
                        return e
                    }
                    e.isRequired = e;
                    var n = {
                        array: e,
                        bigint: e,
                        bool: e,
                        func: e,
                        number: e,
                        object: e,
                        string: e,
                        symbol: e,
                        any: e,
                        arrayOf: t,
                        element: e,
                        elementType: e,
                        instanceOf: t,
                        node: e,
                        objectOf: t,
                        oneOf: t,
                        oneOfType: t,
                        shape: t,
                        exact: t,
                        checkPropTypes: o,
                        resetWarningCache: i
                    };
                    return n.PropTypes = n, n
                }
            },
            5173: (e, t, n) => {
                e.exports = n(1497)()
            },
            3218: e => {
                "use strict";
                e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
            },
            2730: (e, t, n) => {
                "use strict";
                var r = n(5043),
                    i = n(8853);

                function o(e) {
                    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
                    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                }
                var s = new Set,
                    a = {};

                function l(e, t) {
                    u(e, t), u(e + "Capture", t)
                }

                function u(e, t) {
                    for (a[e] = t, e = 0; e < t.length; e++) s.add(t[e])
                }
                var c = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
                    d = Object.prototype.hasOwnProperty,
                    h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                    f = {},
                    p = {};

                function m(e, t, n, r, i, o, s) {
                    this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s
                }
                var g = {};
                "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e) {
                    g[e] = new m(e, 0, !1, e, null, !1, !1)
                })), [
                    ["acceptCharset", "accept-charset"],
                    ["className", "class"],
                    ["htmlFor", "for"],
                    ["httpEquiv", "http-equiv"]
                ].forEach((function(e) {
                    var t = e[0];
                    g[t] = new m(t, 1, !1, e[1], null, !1, !1)
                })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(e) {
                    g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1)
                })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(e) {
                    g[e] = new m(e, 2, !1, e, null, !1, !1)
                })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e) {
                    g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1)
                })), ["checked", "multiple", "muted", "selected"].forEach((function(e) {
                    g[e] = new m(e, 3, !0, e, null, !1, !1)
                })), ["capture", "download"].forEach((function(e) {
                    g[e] = new m(e, 4, !1, e, null, !1, !1)
                })), ["cols", "rows", "size", "span"].forEach((function(e) {
                    g[e] = new m(e, 6, !1, e, null, !1, !1)
                })), ["rowSpan", "start"].forEach((function(e) {
                    g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1)
                }));
                var y = /[\-:]([a-z])/g;

                function v(e) {
                    return e[1].toUpperCase()
                }

                function b(e, t, n, r) {
                    var i = g.hasOwnProperty(t) ? g[t] : null;
                    (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function(e, t, n, r) {
                        if (null === t || "undefined" === typeof t || function(e, t, n, r) {
                                if (null !== n && 0 === n.type) return !1;
                                switch (typeof t) {
                                    case "function":
                                    case "symbol":
                                        return !0;
                                    case "boolean":
                                        return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                                    default:
                                        return !1
                                }
                            }(e, t, n, r)) return !0;
                        if (r) return !1;
                        if (null !== n) switch (n.type) {
                            case 3:
                                return !t;
                            case 4:
                                return !1 === t;
                            case 5:
                                return isNaN(t);
                            case 6:
                                return isNaN(t) || 1 > t
                        }
                        return !1
                    }(t, n, i, r) && (n = null), r || null === i ? function(e) {
                        return !!d.call(p, e) || !d.call(f, e) && (h.test(e) ? p[e] = !0 : (f[e] = !0, !1))
                    }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
                }
                "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e) {
                    var t = e.replace(y, v);
                    g[t] = new m(t, 1, !1, e, null, !1, !1)
                })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e) {
                    var t = e.replace(y, v);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
                })), ["xml:base", "xml:lang", "xml:space"].forEach((function(e) {
                    var t = e.replace(y, v);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
                })), ["tabIndex", "crossOrigin"].forEach((function(e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1)
                })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function(e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0)
                }));
                var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                    E = Symbol.for("react.element"),
                    x = Symbol.for("react.portal"),
                    A = Symbol.for("react.fragment"),
                    k = Symbol.for("react.strict_mode"),
                    C = Symbol.for("react.profiler"),
                    P = Symbol.for("react.provider"),
                    S = Symbol.for("react.context"),
                    _ = Symbol.for("react.forward_ref"),
                    N = Symbol.for("react.suspense"),
                    M = Symbol.for("react.suspense_list"),
                    I = Symbol.for("react.memo"),
                    O = Symbol.for("react.lazy");
                Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
                var T = Symbol.for("react.offscreen");
                Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker");
                var R = Symbol.iterator;

                function L(e) {
                    return null === e || "object" !== typeof e ? null : "function" === typeof(e = R && e[R] || e["@@iterator"]) ? e : null
                }
                var B, F = Object.assign;

                function j(e) {
                    if (void 0 === B) try {
                        throw Error()
                    } catch (n) {
                        var t = n.stack.trim().match(/\n( *(at )?)/);
                        B = t && t[1] || ""
                    }
                    return "\n" + B + e
                }
                var D = !1;

                function U(e, t) {
                    if (!e || D) return "";
                    D = !0;
                    var n = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        if (t)
                            if (t = function() {
                                    throw Error()
                                }, Object.defineProperty(t.prototype, "props", {
                                    set: function() {
                                        throw Error()
                                    }
                                }), "object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(t, [])
                                } catch (u) {
                                    var r = u
                                }
                                Reflect.construct(e, [], t)
                            } else {
                                try {
                                    t.call()
                                } catch (u) {
                                    r = u
                                }
                                e.call(t.prototype)
                            }
                        else {
                            try {
                                throw Error()
                            } catch (u) {
                                r = u
                            }
                            e()
                        }
                    } catch (u) {
                        if (u && r && "string" === typeof u.stack) {
                            for (var i = u.stack.split("\n"), o = r.stack.split("\n"), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];) a--;
                            for (; 1 <= s && 0 <= a; s--, a--)
                                if (i[s] !== o[a]) {
                                    if (1 !== s || 1 !== a)
                                        do {
                                            if (s--, 0 > --a || i[s] !== o[a]) {
                                                var l = "\n" + i[s].replace(" at new ", " at ");
                                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                                            }
                                        } while (1 <= s && 0 <= a);
                                    break
                                }
                        }
                    } finally {
                        D = !1, Error.prepareStackTrace = n
                    }
                    return (e = e ? e.displayName || e.name : "") ? j(e) : ""
                }

                function z(e) {
                    switch (e.tag) {
                        case 5:
                            return j(e.type);
                        case 16:
                            return j("Lazy");
                        case 13:
                            return j("Suspense");
                        case 19:
                            return j("SuspenseList");
                        case 0:
                        case 2:
                        case 15:
                            return e = U(e.type, !1);
                        case 11:
                            return e = U(e.type.render, !1);
                        case 1:
                            return e = U(e.type, !0);
                        default:
                            return ""
                    }
                }

                function q(e) {
                    if (null == e) return null;
                    if ("function" === typeof e) return e.displayName || e.name || null;
                    if ("string" === typeof e) return e;
                    switch (e) {
                        case A:
                            return "Fragment";
                        case x:
                            return "Portal";
                        case C:
                            return "Profiler";
                        case k:
                            return "StrictMode";
                        case N:
                            return "Suspense";
                        case M:
                            return "SuspenseList"
                    }
                    if ("object" === typeof e) switch (e.$$typeof) {
                        case S:
                            return (e.displayName || "Context") + ".Consumer";
                        case P:
                            return (e._context.displayName || "Context") + ".Provider";
                        case _:
                            var t = e.render;
                            return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
                        case I:
                            return null !== (t = e.displayName || null) ? t : q(e.type) || "Memo";
                        case O:
                            t = e._payload, e = e._init;
                            try {
                                return q(e(t))
                            } catch (n) {}
                    }
                    return null
                }

                function G(e) {
                    var t = e.type;
                    switch (e.tag) {
                        case 24:
                            return "Cache";
                        case 9:
                            return (t.displayName || "Context") + ".Consumer";
                        case 10:
                            return (t._context.displayName || "Context") + ".Provider";
                        case 18:
                            return "DehydratedFragment";
                        case 11:
                            return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                        case 7:
                            return "Fragment";
                        case 5:
                            return t;
                        case 4:
                            return "Portal";
                        case 3:
                            return "Root";
                        case 6:
                            return "Text";
                        case 16:
                            return q(t);
                        case 8:
                            return t === k ? "StrictMode" : "Mode";
                        case 22:
                            return "Offscreen";
                        case 12:
                            return "Profiler";
                        case 21:
                            return "Scope";
                        case 13:
                            return "Suspense";
                        case 19:
                            return "SuspenseList";
                        case 25:
                            return "TracingMarker";
                        case 1:
                        case 0:
                        case 17:
                        case 2:
                        case 14:
                        case 15:
                            if ("function" === typeof t) return t.displayName || t.name || null;
                            if ("string" === typeof t) return t
                    }
                    return null
                }

                function H(e) {
                    switch (typeof e) {
                        case "boolean":
                        case "number":
                        case "string":
                        case "undefined":
                        case "object":
                            return e;
                        default:
                            return ""
                    }
                }

                function $(e) {
                    var t = e.type;
                    return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
                }

                function Q(e) {
                    e._valueTracker || (e._valueTracker = function(e) {
                        var t = $(e) ? "checked" : "value",
                            n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                            r = "" + e[t];
                        if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) {
                            var i = n.get,
                                o = n.set;
                            return Object.defineProperty(e, t, {
                                configurable: !0,
                                get: function() {
                                    return i.call(this)
                                },
                                set: function(e) {
                                    r = "" + e, o.call(this, e)
                                }
                            }), Object.defineProperty(e, t, {
                                enumerable: n.enumerable
                            }), {
                                getValue: function() {
                                    return r
                                },
                                setValue: function(e) {
                                    r = "" + e
                                },
                                stopTracking: function() {
                                    e._valueTracker = null, delete e[t]
                                }
                            }
                        }
                    }(e))
                }

                function V(e) {
                    if (!e) return !1;
                    var t = e._valueTracker;
                    if (!t) return !0;
                    var n = t.getValue(),
                        r = "";
                    return e && (r = $(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
                }

                function K(e) {
                    if ("undefined" === typeof(e = e || ("undefined" !== typeof document ? document : void 0))) return null;
                    try {
                        return e.activeElement || e.body
                    } catch (t) {
                        return e.body
                    }
                }

                function W(e, t) {
                    var n = t.checked;
                    return F({}, t, {
                        defaultChecked: void 0,
                        defaultValue: void 0,
                        value: void 0,
                        checked: null != n ? n : e._wrapperState.initialChecked
                    })
                }

                function J(e, t) {
                    var n = null == t.defaultValue ? "" : t.defaultValue,
                        r = null != t.checked ? t.checked : t.defaultChecked;
                    n = H(null != t.value ? t.value : n), e._wrapperState = {
                        initialChecked: r,
                        initialValue: n,
                        controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                    }
                }

                function Z(e, t) {
                    null != (t = t.checked) && b(e, "checked", t, !1)
                }

                function Y(e, t) {
                    Z(e, t);
                    var n = H(t.value),
                        r = t.type;
                    if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
                    else if ("submit" === r || "reset" === r) return void e.removeAttribute("value");
                    t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, H(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
                }

                function X(e, t, n) {
                    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                        var r = t.type;
                        if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return;
                        t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
                    }
                    "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n)
                }

                function ee(e, t, n) {
                    "number" === t && K(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
                }
                var te = Array.isArray;

                function ne(e, t, n, r) {
                    if (e = e.options, t) {
                        t = {};
                        for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
                        for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
                    } else {
                        for (n = "" + H(n), t = null, i = 0; i < e.length; i++) {
                            if (e[i].value === n) return e[i].selected = !0, void(r && (e[i].defaultSelected = !0));
                            null !== t || e[i].disabled || (t = e[i])
                        }
                        null !== t && (t.selected = !0)
                    }
                }

                function re(e, t) {
                    if (null != t.dangerouslySetInnerHTML) throw Error(o(91));
                    return F({}, t, {
                        value: void 0,
                        defaultValue: void 0,
                        children: "" + e._wrapperState.initialValue
                    })
                }

                function ie(e, t) {
                    var n = t.value;
                    if (null == n) {
                        if (n = t.children, t = t.defaultValue, null != n) {
                            if (null != t) throw Error(o(92));
                            if (te(n)) {
                                if (1 < n.length) throw Error(o(93));
                                n = n[0]
                            }
                            t = n
                        }
                        null == t && (t = ""), n = t
                    }
                    e._wrapperState = {
                        initialValue: H(n)
                    }
                }

                function oe(e, t) {
                    var n = H(t.value),
                        r = H(t.defaultValue);
                    null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r)
                }

                function se(e) {
                    var t = e.textContent;
                    t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
                }

                function ae(e) {
                    switch (e) {
                        case "svg":
                            return "http://www.w3.org/2000/svg";
                        case "math":
                            return "http://www.w3.org/1998/Math/MathML";
                        default:
                            return "http://www.w3.org/1999/xhtml"
                    }
                }

                function le(e, t) {
                    return null == e || "http://www.w3.org/1999/xhtml" === e ? ae(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
                }
                var ue, ce, de = (ce = function(e, t) {
                    if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t;
                    else {
                        for ((ue = ue || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ue.firstChild; e.firstChild;) e.removeChild(e.firstChild);
                        for (; t.firstChild;) e.appendChild(t.firstChild)
                    }
                }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(e, t, n, r) {
                    MSApp.execUnsafeLocalFunction((function() {
                        return ce(e, t)
                    }))
                } : ce);

                function he(e, t) {
                    if (t) {
                        var n = e.firstChild;
                        if (n && n === e.lastChild && 3 === n.nodeType) return void(n.nodeValue = t)
                    }
                    e.textContent = t
                }
                var fe = {
                        animationIterationCount: !0,
                        aspectRatio: !0,
                        borderImageOutset: !0,
                        borderImageSlice: !0,
                        borderImageWidth: !0,
                        boxFlex: !0,
                        boxFlexGroup: !0,
                        boxOrdinalGroup: !0,
                        columnCount: !0,
                        columns: !0,
                        flex: !0,
                        flexGrow: !0,
                        flexPositive: !0,
                        flexShrink: !0,
                        flexNegative: !0,
                        flexOrder: !0,
                        gridArea: !0,
                        gridRow: !0,
                        gridRowEnd: !0,
                        gridRowSpan: !0,
                        gridRowStart: !0,
                        gridColumn: !0,
                        gridColumnEnd: !0,
                        gridColumnSpan: !0,
                        gridColumnStart: !0,
                        fontWeight: !0,
                        lineClamp: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        tabSize: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0,
                        fillOpacity: !0,
                        floodOpacity: !0,
                        stopOpacity: !0,
                        strokeDasharray: !0,
                        strokeDashoffset: !0,
                        strokeMiterlimit: !0,
                        strokeOpacity: !0,
                        strokeWidth: !0
                    },
                    pe = ["Webkit", "ms", "Moz", "O"];

                function me(e, t, n) {
                    return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || fe.hasOwnProperty(e) && fe[e] ? ("" + t).trim() : t + "px"
                }

                function ge(e, t) {
                    for (var n in e = e.style, t)
                        if (t.hasOwnProperty(n)) {
                            var r = 0 === n.indexOf("--"),
                                i = me(n, t[n], r);
                            "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
                        }
                }
                Object.keys(fe).forEach((function(e) {
                    pe.forEach((function(t) {
                        t = t + e.charAt(0).toUpperCase() + e.substring(1), fe[t] = fe[e]
                    }))
                }));
                var ye = F({
                    menuitem: !0
                }, {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    embed: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0
                });

                function ve(e, t) {
                    if (t) {
                        if (ye[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(o(137, e));
                        if (null != t.dangerouslySetInnerHTML) {
                            if (null != t.children) throw Error(o(60));
                            if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61))
                        }
                        if (null != t.style && "object" !== typeof t.style) throw Error(o(62))
                    }
                }

                function be(e, t) {
                    if (-1 === e.indexOf("-")) return "string" === typeof t.is;
                    switch (e) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                    }
                }
                var we = null;

                function Ee(e) {
                    return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
                }
                var xe = null,
                    Ae = null,
                    ke = null;

                function Ce(e) {
                    if (e = bi(e)) {
                        if ("function" !== typeof xe) throw Error(o(280));
                        var t = e.stateNode;
                        t && (t = Ei(t), xe(e.stateNode, e.type, t))
                    }
                }

                function Pe(e) {
                    Ae ? ke ? ke.push(e) : ke = [e] : Ae = e
                }

                function Se() {
                    if (Ae) {
                        var e = Ae,
                            t = ke;
                        if (ke = Ae = null, Ce(e), t)
                            for (e = 0; e < t.length; e++) Ce(t[e])
                    }
                }

                function _e(e, t) {
                    return e(t)
                }

                function Ne() {}
                var Me = !1;

                function Ie(e, t, n) {
                    if (Me) return e(t, n);
                    Me = !0;
                    try {
                        return _e(e, t, n)
                    } finally {
                        Me = !1, (null !== Ae || null !== ke) && (Ne(), Se())
                    }
                }

                function Oe(e, t) {
                    var n = e.stateNode;
                    if (null === n) return null;
                    var r = Ei(n);
                    if (null === r) return null;
                    n = r[t];
                    e: switch (t) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                        case "onMouseEnter":
                            (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r;
                            break e;
                        default:
                            e = !1
                    }
                    if (e) return null;
                    if (n && "function" !== typeof n) throw Error(o(231, t, typeof n));
                    return n
                }
                var Te = !1;
                if (c) try {
                    var Re = {};
                    Object.defineProperty(Re, "passive", {
                        get: function() {
                            Te = !0
                        }
                    }), window.addEventListener("test", Re, Re), window.removeEventListener("test", Re, Re)
                } catch (ce) {
                    Te = !1
                }

                function Le(e, t, n, r, i, o, s, a, l) {
                    var u = Array.prototype.slice.call(arguments, 3);
                    try {
                        t.apply(n, u)
                    } catch (c) {
                        this.onError(c)
                    }
                }
                var Be = !1,
                    Fe = null,
                    je = !1,
                    De = null,
                    Ue = {
                        onError: function(e) {
                            Be = !0, Fe = e
                        }
                    };

                function ze(e, t, n, r, i, o, s, a, l) {
                    Be = !1, Fe = null, Le.apply(Ue, arguments)
                }

                function qe(e) {
                    var t = e,
                        n = e;
                    if (e.alternate)
                        for (; t.return;) t = t.return;
                    else {
                        e = t;
                        do {
                            0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return
                        } while (e)
                    }
                    return 3 === t.tag ? n : null
                }

                function Ge(e) {
                    if (13 === e.tag) {
                        var t = e.memoizedState;
                        if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated
                    }
                    return null
                }

                function He(e) {
                    if (qe(e) !== e) throw Error(o(188))
                }

                function $e(e) {
                    return null !== (e = function(e) {
                        var t = e.alternate;
                        if (!t) {
                            if (null === (t = qe(e))) throw Error(o(188));
                            return t !== e ? null : e
                        }
                        for (var n = e, r = t;;) {
                            var i = n.return;
                            if (null === i) break;
                            var s = i.alternate;
                            if (null === s) {
                                if (null !== (r = i.return)) {
                                    n = r;
                                    continue
                                }
                                break
                            }
                            if (i.child === s.child) {
                                for (s = i.child; s;) {
                                    if (s === n) return He(i), e;
                                    if (s === r) return He(i), t;
                                    s = s.sibling
                                }
                                throw Error(o(188))
                            }
                            if (n.return !== r.return) n = i, r = s;
                            else {
                                for (var a = !1, l = i.child; l;) {
                                    if (l === n) {
                                        a = !0, n = i, r = s;
                                        break
                                    }
                                    if (l === r) {
                                        a = !0, r = i, n = s;
                                        break
                                    }
                                    l = l.sibling
                                }
                                if (!a) {
                                    for (l = s.child; l;) {
                                        if (l === n) {
                                            a = !0, n = s, r = i;
                                            break
                                        }
                                        if (l === r) {
                                            a = !0, r = s, n = i;
                                            break
                                        }
                                        l = l.sibling
                                    }
                                    if (!a) throw Error(o(189))
                                }
                            }
                            if (n.alternate !== r) throw Error(o(190))
                        }
                        if (3 !== n.tag) throw Error(o(188));
                        return n.stateNode.current === n ? e : t
                    }(e)) ? Qe(e) : null
                }

                function Qe(e) {
                    if (5 === e.tag || 6 === e.tag) return e;
                    for (e = e.child; null !== e;) {
                        var t = Qe(e);
                        if (null !== t) return t;
                        e = e.sibling
                    }
                    return null
                }
                var Ve = i.unstable_scheduleCallback,
                    Ke = i.unstable_cancelCallback,
                    We = i.unstable_shouldYield,
                    Je = i.unstable_requestPaint,
                    Ze = i.unstable_now,
                    Ye = i.unstable_getCurrentPriorityLevel,
                    Xe = i.unstable_ImmediatePriority,
                    et = i.unstable_UserBlockingPriority,
                    tt = i.unstable_NormalPriority,
                    nt = i.unstable_LowPriority,
                    rt = i.unstable_IdlePriority,
                    it = null,
                    ot = null;
                var st = Math.clz32 ? Math.clz32 : function(e) {
                        return e >>>= 0, 0 === e ? 32 : 31 - (at(e) / lt | 0) | 0
                    },
                    at = Math.log,
                    lt = Math.LN2;
                var ut = 64,
                    ct = 4194304;

                function dt(e) {
                    switch (e & -e) {
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return 4194240 & e;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            return 130023424 & e;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 1073741824;
                        default:
                            return e
                    }
                }

                function ht(e, t) {
                    var n = e.pendingLanes;
                    if (0 === n) return 0;
                    var r = 0,
                        i = e.suspendedLanes,
                        o = e.pingedLanes,
                        s = 268435455 & n;
                    if (0 !== s) {
                        var a = s & ~i;
                        0 !== a ? r = dt(a) : 0 !== (o &= s) && (r = dt(o))
                    } else 0 !== (s = n & ~i) ? r = dt(s) : 0 !== o && (r = dt(o));
                    if (0 === r) return 0;
                    if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o))) return t;
                    if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes))
                        for (e = e.entanglements, t &= r; 0 < t;) i = 1 << (n = 31 - st(t)), r |= e[n], t &= ~i;
                    return r
                }

                function ft(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 4:
                            return t + 250;
                        case 8:
                        case 16:
                        case 32:
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return t + 5e3;
                        default:
                            return -1
                    }
                }

                function pt(e) {
                    return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
                }

                function mt() {
                    var e = ut;
                    return 0 === (4194240 & (ut <<= 1)) && (ut = 64), e
                }

                function gt(e) {
                    for (var t = [], n = 0; 31 > n; n++) t.push(e);
                    return t
                }

                function yt(e, t, n) {
                    e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - st(t)] = n
                }

                function vt(e, t) {
                    var n = e.entangledLanes |= t;
                    for (e = e.entanglements; n;) {
                        var r = 31 - st(n),
                            i = 1 << r;
                        i & t | e[r] & t && (e[r] |= t), n &= ~i
                    }
                }
                var bt = 0;

                function wt(e) {
                    return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
                }
                var Et, xt, At, kt, Ct, Pt = !1,
                    St = [],
                    _t = null,
                    Nt = null,
                    Mt = null,
                    It = new Map,
                    Ot = new Map,
                    Tt = [],
                    Rt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

                function Lt(e, t) {
                    switch (e) {
                        case "focusin":
                        case "focusout":
                            _t = null;
                            break;
                        case "dragenter":
                        case "dragleave":
                            Nt = null;
                            break;
                        case "mouseover":
                        case "mouseout":
                            Mt = null;
                            break;
                        case "pointerover":
                        case "pointerout":
                            It.delete(t.pointerId);
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                            Ot.delete(t.pointerId)
                    }
                }

                function Bt(e, t, n, r, i, o) {
                    return null === e || e.nativeEvent !== o ? (e = {
                        blockedOn: t,
                        domEventName: n,
                        eventSystemFlags: r,
                        nativeEvent: o,
                        targetContainers: [i]
                    }, null !== t && (null !== (t = bi(t)) && xt(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e)
                }

                function Ft(e) {
                    var t = vi(e.target);
                    if (null !== t) {
                        var n = qe(t);
                        if (null !== n)
                            if (13 === (t = n.tag)) {
                                if (null !== (t = Ge(n))) return e.blockedOn = t, void Ct(e.priority, (function() {
                                    At(n)
                                }))
                            } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void(e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                    }
                    e.blockedOn = null
                }

                function jt(e) {
                    if (null !== e.blockedOn) return !1;
                    for (var t = e.targetContainers; 0 < t.length;) {
                        var n = Wt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                        if (null !== n) return null !== (t = bi(n)) && xt(t), e.blockedOn = n, !1;
                        var r = new(n = e.nativeEvent).constructor(n.type, n);
                        we = r, n.target.dispatchEvent(r), we = null, t.shift()
                    }
                    return !0
                }

                function Dt(e, t, n) {
                    jt(e) && n.delete(t)
                }

                function Ut() {
                    Pt = !1, null !== _t && jt(_t) && (_t = null), null !== Nt && jt(Nt) && (Nt = null), null !== Mt && jt(Mt) && (Mt = null), It.forEach(Dt), Ot.forEach(Dt)
                }

                function zt(e, t) {
                    e.blockedOn === t && (e.blockedOn = null, Pt || (Pt = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Ut)))
                }

                function qt(e) {
                    function t(t) {
                        return zt(t, e)
                    }
                    if (0 < St.length) {
                        zt(St[0], e);
                        for (var n = 1; n < St.length; n++) {
                            var r = St[n];
                            r.blockedOn === e && (r.blockedOn = null)
                        }
                    }
                    for (null !== _t && zt(_t, e), null !== Nt && zt(Nt, e), null !== Mt && zt(Mt, e), It.forEach(t), Ot.forEach(t), n = 0; n < Tt.length; n++)(r = Tt[n]).blockedOn === e && (r.blockedOn = null);
                    for (; 0 < Tt.length && null === (n = Tt[0]).blockedOn;) Ft(n), null === n.blockedOn && Tt.shift()
                }
                var Gt = w.ReactCurrentBatchConfig,
                    Ht = !0;

                function $t(e, t, n, r) {
                    var i = bt,
                        o = Gt.transition;
                    Gt.transition = null;
                    try {
                        bt = 1, Vt(e, t, n, r)
                    } finally {
                        bt = i, Gt.transition = o
                    }
                }

                function Qt(e, t, n, r) {
                    var i = bt,
                        o = Gt.transition;
                    Gt.transition = null;
                    try {
                        bt = 4, Vt(e, t, n, r)
                    } finally {
                        bt = i, Gt.transition = o
                    }
                }

                function Vt(e, t, n, r) {
                    if (Ht) {
                        var i = Wt(e, t, n, r);
                        if (null === i) Hr(e, t, r, Kt, n), Lt(e, r);
                        else if (function(e, t, n, r, i) {
                                switch (t) {
                                    case "focusin":
                                        return _t = Bt(_t, e, t, n, r, i), !0;
                                    case "dragenter":
                                        return Nt = Bt(Nt, e, t, n, r, i), !0;
                                    case "mouseover":
                                        return Mt = Bt(Mt, e, t, n, r, i), !0;
                                    case "pointerover":
                                        var o = i.pointerId;
                                        return It.set(o, Bt(It.get(o) || null, e, t, n, r, i)), !0;
                                    case "gotpointercapture":
                                        return o = i.pointerId, Ot.set(o, Bt(Ot.get(o) || null, e, t, n, r, i)), !0
                                }
                                return !1
                            }(i, e, t, n, r)) r.stopPropagation();
                        else if (Lt(e, r), 4 & t && -1 < Rt.indexOf(e)) {
                            for (; null !== i;) {
                                var o = bi(i);
                                if (null !== o && Et(o), null === (o = Wt(e, t, n, r)) && Hr(e, t, r, Kt, n), o === i) break;
                                i = o
                            }
                            null !== i && r.stopPropagation()
                        } else Hr(e, t, r, null, n)
                    }
                }
                var Kt = null;

                function Wt(e, t, n, r) {
                    if (Kt = null, null !== (e = vi(e = Ee(r))))
                        if (null === (t = qe(e))) e = null;
                        else if (13 === (n = t.tag)) {
                        if (null !== (e = Ge(t))) return e;
                        e = null
                    } else if (3 === n) {
                        if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null;
                        e = null
                    } else t !== e && (e = null);
                    return Kt = e, null
                }

                function Jt(e) {
                    switch (e) {
                        case "cancel":
                        case "click":
                        case "close":
                        case "contextmenu":
                        case "copy":
                        case "cut":
                        case "auxclick":
                        case "dblclick":
                        case "dragend":
                        case "dragstart":
                        case "drop":
                        case "focusin":
                        case "focusout":
                        case "input":
                        case "invalid":
                        case "keydown":
                        case "keypress":
                        case "keyup":
                        case "mousedown":
                        case "mouseup":
                        case "paste":
                        case "pause":
                        case "play":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                        case "ratechange":
                        case "reset":
                        case "resize":
                        case "seeked":
                        case "submit":
                        case "touchcancel":
                        case "touchend":
                        case "touchstart":
                        case "volumechange":
                        case "change":
                        case "selectionchange":
                        case "textInput":
                        case "compositionstart":
                        case "compositionend":
                        case "compositionupdate":
                        case "beforeblur":
                        case "afterblur":
                        case "beforeinput":
                        case "blur":
                        case "fullscreenchange":
                        case "focus":
                        case "hashchange":
                        case "popstate":
                        case "select":
                        case "selectstart":
                            return 1;
                        case "drag":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "mousemove":
                        case "mouseout":
                        case "mouseover":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "scroll":
                        case "toggle":
                        case "touchmove":
                        case "wheel":
                        case "mouseenter":
                        case "mouseleave":
                        case "pointerenter":
                        case "pointerleave":
                            return 4;
                        case "message":
                            switch (Ye()) {
                                case Xe:
                                    return 1;
                                case et:
                                    return 4;
                                case tt:
                                case nt:
                                    return 16;
                                case rt:
                                    return 536870912;
                                default:
                                    return 16
                            }
                        default:
                            return 16
                    }
                }
                var Zt = null,
                    Yt = null,
                    Xt = null;

                function en() {
                    if (Xt) return Xt;
                    var e, t, n = Yt,
                        r = n.length,
                        i = "value" in Zt ? Zt.value : Zt.textContent,
                        o = i.length;
                    for (e = 0; e < r && n[e] === i[e]; e++);
                    var s = r - e;
                    for (t = 1; t <= s && n[r - t] === i[o - t]; t++);
                    return Xt = i.slice(e, 1 < t ? 1 - t : void 0)
                }

                function tn(e) {
                    var t = e.keyCode;
                    return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
                }

                function nn() {
                    return !0
                }

                function rn() {
                    return !1
                }

                function on(e) {
                    function t(t, n, r, i, o) {
                        for (var s in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(s) && (t = e[s], this[s] = t ? t(i) : i[s]);
                        return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this
                    }
                    return F(t.prototype, {
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                            var e = this.nativeEvent;
                            e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn)
                        },
                        stopPropagation: function() {
                            var e = this.nativeEvent;
                            e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn)
                        },
                        persist: function() {},
                        isPersistent: nn
                    }), t
                }
                var sn, an, ln, un = {
                        eventPhase: 0,
                        bubbles: 0,
                        cancelable: 0,
                        timeStamp: function(e) {
                            return e.timeStamp || Date.now()
                        },
                        defaultPrevented: 0,
                        isTrusted: 0
                    },
                    cn = on(un),
                    dn = F({}, un, {
                        view: 0,
                        detail: 0
                    }),
                    hn = on(dn),
                    fn = F({}, dn, {
                        screenX: 0,
                        screenY: 0,
                        clientX: 0,
                        clientY: 0,
                        pageX: 0,
                        pageY: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        getModifierState: Cn,
                        button: 0,
                        buttons: 0,
                        relatedTarget: function(e) {
                            return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                        },
                        movementX: function(e) {
                            return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (sn = e.screenX - ln.screenX, an = e.screenY - ln.screenY) : an = sn = 0, ln = e), sn)
                        },
                        movementY: function(e) {
                            return "movementY" in e ? e.movementY : an
                        }
                    }),
                    pn = on(fn),
                    mn = on(F({}, fn, {
                        dataTransfer: 0
                    })),
                    gn = on(F({}, dn, {
                        relatedTarget: 0
                    })),
                    yn = on(F({}, un, {
                        animationName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    vn = F({}, un, {
                        clipboardData: function(e) {
                            return "clipboardData" in e ? e.clipboardData : window.clipboardData
                        }
                    }),
                    bn = on(vn),
                    wn = on(F({}, un, {
                        data: 0
                    })),
                    En = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    },
                    xn = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    },
                    An = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };

                function kn(e) {
                    var t = this.nativeEvent;
                    return t.getModifierState ? t.getModifierState(e) : !!(e = An[e]) && !!t[e]
                }

                function Cn() {
                    return kn
                }
                var Pn = F({}, dn, {
                        key: function(e) {
                            if (e.key) {
                                var t = En[e.key] || e.key;
                                if ("Unidentified" !== t) return t
                            }
                            return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? xn[e.keyCode] || "Unidentified" : ""
                        },
                        code: 0,
                        location: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        repeat: 0,
                        locale: 0,
                        getModifierState: Cn,
                        charCode: function(e) {
                            return "keypress" === e.type ? tn(e) : 0
                        },
                        keyCode: function(e) {
                            return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        },
                        which: function(e) {
                            return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        }
                    }),
                    Sn = on(Pn),
                    _n = on(F({}, fn, {
                        pointerId: 0,
                        width: 0,
                        height: 0,
                        pressure: 0,
                        tangentialPressure: 0,
                        tiltX: 0,
                        tiltY: 0,
                        twist: 0,
                        pointerType: 0,
                        isPrimary: 0
                    })),
                    Nn = on(F({}, dn, {
                        touches: 0,
                        targetTouches: 0,
                        changedTouches: 0,
                        altKey: 0,
                        metaKey: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        getModifierState: Cn
                    })),
                    Mn = on(F({}, un, {
                        propertyName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    In = F({}, fn, {
                        deltaX: function(e) {
                            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                        },
                        deltaY: function(e) {
                            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                        },
                        deltaZ: 0,
                        deltaMode: 0
                    }),
                    On = on(In),
                    Tn = [9, 13, 27, 32],
                    Rn = c && "CompositionEvent" in window,
                    Ln = null;
                c && "documentMode" in document && (Ln = document.documentMode);
                var Bn = c && "TextEvent" in window && !Ln,
                    Fn = c && (!Rn || Ln && 8 < Ln && 11 >= Ln),
                    jn = String.fromCharCode(32),
                    Dn = !1;

                function Un(e, t) {
                    switch (e) {
                        case "keyup":
                            return -1 !== Tn.indexOf(t.keyCode);
                        case "keydown":
                            return 229 !== t.keyCode;
                        case "keypress":
                        case "mousedown":
                        case "focusout":
                            return !0;
                        default:
                            return !1
                    }
                }

                function zn(e) {
                    return "object" === typeof(e = e.detail) && "data" in e ? e.data : null
                }
                var qn = !1;
                var Gn = {
                    color: !0,
                    date: !0,
                    datetime: !0,
                    "datetime-local": !0,
                    email: !0,
                    month: !0,
                    number: !0,
                    password: !0,
                    range: !0,
                    search: !0,
                    tel: !0,
                    text: !0,
                    time: !0,
                    url: !0,
                    week: !0
                };

                function Hn(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return "input" === t ? !!Gn[e.type] : "textarea" === t
                }

                function $n(e, t, n, r) {
                    Pe(r), 0 < (t = Qr(t, "onChange")).length && (n = new cn("onChange", "change", null, n, r), e.push({
                        event: n,
                        listeners: t
                    }))
                }
                var Qn = null,
                    Vn = null;

                function Kn(e) {
                    jr(e, 0)
                }

                function Wn(e) {
                    if (V(wi(e))) return e
                }

                function Jn(e, t) {
                    if ("change" === e) return t
                }
                var Zn = !1;
                if (c) {
                    var Yn;
                    if (c) {
                        var Xn = "oninput" in document;
                        if (!Xn) {
                            var er = document.createElement("div");
                            er.setAttribute("oninput", "return;"), Xn = "function" === typeof er.oninput
                        }
                        Yn = Xn
                    } else Yn = !1;
                    Zn = Yn && (!document.documentMode || 9 < document.documentMode)
                }

                function tr() {
                    Qn && (Qn.detachEvent("onpropertychange", nr), Vn = Qn = null)
                }

                function nr(e) {
                    if ("value" === e.propertyName && Wn(Vn)) {
                        var t = [];
                        $n(t, Vn, e, Ee(e)), Ie(Kn, t)
                    }
                }

                function rr(e, t, n) {
                    "focusin" === e ? (tr(), Vn = n, (Qn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr()
                }

                function ir(e) {
                    if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Wn(Vn)
                }

                function or(e, t) {
                    if ("click" === e) return Wn(t)
                }

                function sr(e, t) {
                    if ("input" === e || "change" === e) return Wn(t)
                }
                var ar = "function" === typeof Object.is ? Object.is : function(e, t) {
                    return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                };

                function lr(e, t) {
                    if (ar(e, t)) return !0;
                    if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1;
                    var n = Object.keys(e),
                        r = Object.keys(t);
                    if (n.length !== r.length) return !1;
                    for (r = 0; r < n.length; r++) {
                        var i = n[r];
                        if (!d.call(t, i) || !ar(e[i], t[i])) return !1
                    }
                    return !0
                }

                function ur(e) {
                    for (; e && e.firstChild;) e = e.firstChild;
                    return e
                }

                function cr(e, t) {
                    var n, r = ur(e);
                    for (e = 0; r;) {
                        if (3 === r.nodeType) {
                            if (n = e + r.textContent.length, e <= t && n >= t) return {
                                node: r,
                                offset: t - e
                            };
                            e = n
                        }
                        e: {
                            for (; r;) {
                                if (r.nextSibling) {
                                    r = r.nextSibling;
                                    break e
                                }
                                r = r.parentNode
                            }
                            r = void 0
                        }
                        r = ur(r)
                    }
                }

                function dr(e, t) {
                    return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
                }

                function hr() {
                    for (var e = window, t = K(); t instanceof e.HTMLIFrameElement;) {
                        try {
                            var n = "string" === typeof t.contentWindow.location.href
                        } catch (r) {
                            n = !1
                        }
                        if (!n) break;
                        t = K((e = t.contentWindow).document)
                    }
                    return t
                }

                function fr(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
                }

                function pr(e) {
                    var t = hr(),
                        n = e.focusedElem,
                        r = e.selectionRange;
                    if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) {
                        if (null !== r && fr(n))
                            if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
                            else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
                            e = e.getSelection();
                            var i = n.textContent.length,
                                o = Math.min(r.start, i);
                            r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = cr(n, o);
                            var s = cr(n, r);
                            i && s && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t)))
                        }
                        for (t = [], e = n; e = e.parentNode;) 1 === e.nodeType && t.push({
                            element: e,
                            left: e.scrollLeft,
                            top: e.scrollTop
                        });
                        for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top
                    }
                }
                var mr = c && "documentMode" in document && 11 >= document.documentMode,
                    gr = null,
                    yr = null,
                    vr = null,
                    br = !1;

                function wr(e, t, n) {
                    var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                    br || null == gr || gr !== K(r) || ("selectionStart" in (r = gr) && fr(r) ? r = {
                        start: r.selectionStart,
                        end: r.selectionEnd
                    } : r = {
                        anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                        anchorOffset: r.anchorOffset,
                        focusNode: r.focusNode,
                        focusOffset: r.focusOffset
                    }, vr && lr(vr, r) || (vr = r, 0 < (r = Qr(yr, "onSelect")).length && (t = new cn("onSelect", "select", null, t, n), e.push({
                        event: t,
                        listeners: r
                    }), t.target = gr)))
                }

                function Er(e, t) {
                    var n = {};
                    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
                }
                var xr = {
                        animationend: Er("Animation", "AnimationEnd"),
                        animationiteration: Er("Animation", "AnimationIteration"),
                        animationstart: Er("Animation", "AnimationStart"),
                        transitionend: Er("Transition", "TransitionEnd")
                    },
                    Ar = {},
                    kr = {};

                function Cr(e) {
                    if (Ar[e]) return Ar[e];
                    if (!xr[e]) return e;
                    var t, n = xr[e];
                    for (t in n)
                        if (n.hasOwnProperty(t) && t in kr) return Ar[e] = n[t];
                    return e
                }
                c && (kr = document.createElement("div").style, "AnimationEvent" in window || (delete xr.animationend.animation, delete xr.animationiteration.animation, delete xr.animationstart.animation), "TransitionEvent" in window || delete xr.transitionend.transition);
                var Pr = Cr("animationend"),
                    Sr = Cr("animationiteration"),
                    _r = Cr("animationstart"),
                    Nr = Cr("transitionend"),
                    Mr = new Map,
                    Ir = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

                function Or(e, t) {
                    Mr.set(e, t), l(t, [e])
                }
                for (var Tr = 0; Tr < Ir.length; Tr++) {
                    var Rr = Ir[Tr];
                    Or(Rr.toLowerCase(), "on" + (Rr[0].toUpperCase() + Rr.slice(1)))
                }
                Or(Pr, "onAnimationEnd"), Or(Sr, "onAnimationIteration"), Or(_r, "onAnimationStart"), Or("dblclick", "onDoubleClick"), Or("focusin", "onFocus"), Or("focusout", "onBlur"), Or(Nr, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                var Lr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
                    Br = new Set("cancel close invalid load scroll toggle".split(" ").concat(Lr));

                function Fr(e, t, n) {
                    var r = e.type || "unknown-event";
                    e.currentTarget = n,
                        function(e, t, n, r, i, s, a, l, u) {
                            if (ze.apply(this, arguments), Be) {
                                if (!Be) throw Error(o(198));
                                var c = Fe;
                                Be = !1, Fe = null, je || (je = !0, De = c)
                            }
                        }(r, t, void 0, e), e.currentTarget = null
                }

                function jr(e, t) {
                    t = 0 !== (4 & t);
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = r.event;
                        r = r.listeners;
                        e: {
                            var o = void 0;
                            if (t)
                                for (var s = r.length - 1; 0 <= s; s--) {
                                    var a = r[s],
                                        l = a.instance,
                                        u = a.currentTarget;
                                    if (a = a.listener, l !== o && i.isPropagationStopped()) break e;
                                    Fr(i, a, u), o = l
                                } else
                                    for (s = 0; s < r.length; s++) {
                                        if (l = (a = r[s]).instance, u = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e;
                                        Fr(i, a, u), o = l
                                    }
                        }
                    }
                    if (je) throw e = De, je = !1, De = null, e
                }

                function Dr(e, t) {
                    var n = t[mi];
                    void 0 === n && (n = t[mi] = new Set);
                    var r = e + "__bubble";
                    n.has(r) || (Gr(t, e, 2, !1), n.add(r))
                }

                function Ur(e, t, n) {
                    var r = 0;
                    t && (r |= 4), Gr(n, e, r, t)
                }
                var zr = "_reactListening" + Math.random().toString(36).slice(2);

                function qr(e) {
                    if (!e[zr]) {
                        e[zr] = !0, s.forEach((function(t) {
                            "selectionchange" !== t && (Br.has(t) || Ur(t, !1, e), Ur(t, !0, e))
                        }));
                        var t = 9 === e.nodeType ? e : e.ownerDocument;
                        null === t || t[zr] || (t[zr] = !0, Ur("selectionchange", !1, t))
                    }
                }

                function Gr(e, t, n, r) {
                    switch (Jt(t)) {
                        case 1:
                            var i = $t;
                            break;
                        case 4:
                            i = Qt;
                            break;
                        default:
                            i = Vt
                    }
                    n = i.bind(null, t, n, e), i = void 0, !Te || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, {
                        capture: !0,
                        passive: i
                    }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {
                        passive: i
                    }) : e.addEventListener(t, n, !1)
                }

                function Hr(e, t, n, r, i) {
                    var o = r;
                    if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (;;) {
                        if (null === r) return;
                        var s = r.tag;
                        if (3 === s || 4 === s) {
                            var a = r.stateNode.containerInfo;
                            if (a === i || 8 === a.nodeType && a.parentNode === i) break;
                            if (4 === s)
                                for (s = r.return; null !== s;) {
                                    var l = s.tag;
                                    if ((3 === l || 4 === l) && ((l = s.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return;
                                    s = s.return
                                }
                            for (; null !== a;) {
                                if (null === (s = vi(a))) return;
                                if (5 === (l = s.tag) || 6 === l) {
                                    r = o = s;
                                    continue e
                                }
                                a = a.parentNode
                            }
                        }
                        r = r.return
                    }
                    Ie((function() {
                        var r = o,
                            i = Ee(n),
                            s = [];
                        e: {
                            var a = Mr.get(e);
                            if (void 0 !== a) {
                                var l = cn,
                                    u = e;
                                switch (e) {
                                    case "keypress":
                                        if (0 === tn(n)) break e;
                                    case "keydown":
                                    case "keyup":
                                        l = Sn;
                                        break;
                                    case "focusin":
                                        u = "focus", l = gn;
                                        break;
                                    case "focusout":
                                        u = "blur", l = gn;
                                        break;
                                    case "beforeblur":
                                    case "afterblur":
                                        l = gn;
                                        break;
                                    case "click":
                                        if (2 === n.button) break e;
                                    case "auxclick":
                                    case "dblclick":
                                    case "mousedown":
                                    case "mousemove":
                                    case "mouseup":
                                    case "mouseout":
                                    case "mouseover":
                                    case "contextmenu":
                                        l = pn;
                                        break;
                                    case "drag":
                                    case "dragend":
                                    case "dragenter":
                                    case "dragexit":
                                    case "dragleave":
                                    case "dragover":
                                    case "dragstart":
                                    case "drop":
                                        l = mn;
                                        break;
                                    case "touchcancel":
                                    case "touchend":
                                    case "touchmove":
                                    case "touchstart":
                                        l = Nn;
                                        break;
                                    case Pr:
                                    case Sr:
                                    case _r:
                                        l = yn;
                                        break;
                                    case Nr:
                                        l = Mn;
                                        break;
                                    case "scroll":
                                        l = hn;
                                        break;
                                    case "wheel":
                                        l = On;
                                        break;
                                    case "copy":
                                    case "cut":
                                    case "paste":
                                        l = bn;
                                        break;
                                    case "gotpointercapture":
                                    case "lostpointercapture":
                                    case "pointercancel":
                                    case "pointerdown":
                                    case "pointermove":
                                    case "pointerout":
                                    case "pointerover":
                                    case "pointerup":
                                        l = _n
                                }
                                var c = 0 !== (4 & t),
                                    d = !c && "scroll" === e,
                                    h = c ? null !== a ? a + "Capture" : null : a;
                                c = [];
                                for (var f, p = r; null !== p;) {
                                    var m = (f = p).stateNode;
                                    if (5 === f.tag && null !== m && (f = m, null !== h && (null != (m = Oe(p, h)) && c.push($r(p, m, f)))), d) break;
                                    p = p.return
                                }
                                0 < c.length && (a = new l(a, u, null, n, i), s.push({
                                    event: a,
                                    listeners: c
                                }))
                            }
                        }
                        if (0 === (7 & t)) {
                            if (l = "mouseout" === e || "pointerout" === e, (!(a = "mouseover" === e || "pointerover" === e) || n === we || !(u = n.relatedTarget || n.fromElement) || !vi(u) && !u[pi]) && (l || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window, l ? (l = r, null !== (u = (u = n.relatedTarget || n.toElement) ? vi(u) : null) && (u !== (d = qe(u)) || 5 !== u.tag && 6 !== u.tag) && (u = null)) : (l = null, u = r), l !== u)) {
                                if (c = pn, m = "onMouseLeave", h = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (c = _n, m = "onPointerLeave", h = "onPointerEnter", p = "pointer"), d = null == l ? a : wi(l), f = null == u ? a : wi(u), (a = new c(m, p + "leave", l, n, i)).target = d, a.relatedTarget = f, m = null, vi(i) === r && ((c = new c(h, p + "enter", u, n, i)).target = f, c.relatedTarget = d, m = c), d = m, l && u) e: {
                                    for (h = u, p = 0, f = c = l; f; f = Vr(f)) p++;
                                    for (f = 0, m = h; m; m = Vr(m)) f++;
                                    for (; 0 < p - f;) c = Vr(c),
                                    p--;
                                    for (; 0 < f - p;) h = Vr(h),
                                    f--;
                                    for (; p--;) {
                                        if (c === h || null !== h && c === h.alternate) break e;
                                        c = Vr(c), h = Vr(h)
                                    }
                                    c = null
                                }
                                else c = null;
                                null !== l && Kr(s, a, l, c, !1), null !== u && null !== d && Kr(s, d, u, c, !0)
                            }
                            if ("select" === (l = (a = r ? wi(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === l && "file" === a.type) var g = Jn;
                            else if (Hn(a))
                                if (Zn) g = sr;
                                else {
                                    g = ir;
                                    var y = rr
                                }
                            else(l = a.nodeName) && "input" === l.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (g = or);
                            switch (g && (g = g(e, r)) ? $n(s, g, n, i) : (y && y(e, a, r), "focusout" === e && (y = a._wrapperState) && y.controlled && "number" === a.type && ee(a, "number", a.value)), y = r ? wi(r) : window, e) {
                                case "focusin":
                                    (Hn(y) || "true" === y.contentEditable) && (gr = y, yr = r, vr = null);
                                    break;
                                case "focusout":
                                    vr = yr = gr = null;
                                    break;
                                case "mousedown":
                                    br = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    br = !1, wr(s, n, i);
                                    break;
                                case "selectionchange":
                                    if (mr) break;
                                case "keydown":
                                case "keyup":
                                    wr(s, n, i)
                            }
                            var v;
                            if (Rn) e: {
                                switch (e) {
                                    case "compositionstart":
                                        var b = "onCompositionStart";
                                        break e;
                                    case "compositionend":
                                        b = "onCompositionEnd";
                                        break e;
                                    case "compositionupdate":
                                        b = "onCompositionUpdate";
                                        break e
                                }
                                b = void 0
                            }
                            else qn ? Un(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart");
                            b && (Fn && "ko" !== n.locale && (qn || "onCompositionStart" !== b ? "onCompositionEnd" === b && qn && (v = en()) : (Yt = "value" in (Zt = i) ? Zt.value : Zt.textContent, qn = !0)), 0 < (y = Qr(r, b)).length && (b = new wn(b, e, null, n, i), s.push({
                                event: b,
                                listeners: y
                            }), v ? b.data = v : null !== (v = zn(n)) && (b.data = v))), (v = Bn ? function(e, t) {
                                switch (e) {
                                    case "compositionend":
                                        return zn(t);
                                    case "keypress":
                                        return 32 !== t.which ? null : (Dn = !0, jn);
                                    case "textInput":
                                        return (e = t.data) === jn && Dn ? null : e;
                                    default:
                                        return null
                                }
                            }(e, n) : function(e, t) {
                                if (qn) return "compositionend" === e || !Rn && Un(e, t) ? (e = en(), Xt = Yt = Zt = null, qn = !1, e) : null;
                                switch (e) {
                                    case "paste":
                                    default:
                                        return null;
                                    case "keypress":
                                        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                            if (t.char && 1 < t.char.length) return t.char;
                                            if (t.which) return String.fromCharCode(t.which)
                                        }
                                        return null;
                                    case "compositionend":
                                        return Fn && "ko" !== t.locale ? null : t.data
                                }
                            }(e, n)) && (0 < (r = Qr(r, "onBeforeInput")).length && (i = new wn("onBeforeInput", "beforeinput", null, n, i), s.push({
                                event: i,
                                listeners: r
                            }), i.data = v))
                        }
                        jr(s, t)
                    }))
                }

                function $r(e, t, n) {
                    return {
                        instance: e,
                        listener: t,
                        currentTarget: n
                    }
                }

                function Qr(e, t) {
                    for (var n = t + "Capture", r = []; null !== e;) {
                        var i = e,
                            o = i.stateNode;
                        5 === i.tag && null !== o && (i = o, null != (o = Oe(e, n)) && r.unshift($r(e, o, i)), null != (o = Oe(e, t)) && r.push($r(e, o, i))), e = e.return
                    }
                    return r
                }

                function Vr(e) {
                    if (null === e) return null;
                    do {
                        e = e.return
                    } while (e && 5 !== e.tag);
                    return e || null
                }

                function Kr(e, t, n, r, i) {
                    for (var o = t._reactName, s = []; null !== n && n !== r;) {
                        var a = n,
                            l = a.alternate,
                            u = a.stateNode;
                        if (null !== l && l === r) break;
                        5 === a.tag && null !== u && (a = u, i ? null != (l = Oe(n, o)) && s.unshift($r(n, l, a)) : i || null != (l = Oe(n, o)) && s.push($r(n, l, a))), n = n.return
                    }
                    0 !== s.length && e.push({
                        event: t,
                        listeners: s
                    })
                }
                var Wr = /\r\n?/g,
                    Jr = /\u0000|\uFFFD/g;

                function Zr(e) {
                    return ("string" === typeof e ? e : "" + e).replace(Wr, "\n").replace(Jr, "")
                }

                function Yr(e, t, n) {
                    if (t = Zr(t), Zr(e) !== t && n) throw Error(o(425))
                }

                function Xr() {}
                var ei = null,
                    ti = null;

                function ni(e, t) {
                    return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
                }
                var ri = "function" === typeof setTimeout ? setTimeout : void 0,
                    ii = "function" === typeof clearTimeout ? clearTimeout : void 0,
                    oi = "function" === typeof Promise ? Promise : void 0,
                    si = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof oi ? function(e) {
                        return oi.resolve(null).then(e).catch(ai)
                    } : ri;

                function ai(e) {
                    setTimeout((function() {
                        throw e
                    }))
                }

                function li(e, t) {
                    var n = t,
                        r = 0;
                    do {
                        var i = n.nextSibling;
                        if (e.removeChild(n), i && 8 === i.nodeType)
                            if ("/$" === (n = i.data)) {
                                if (0 === r) return e.removeChild(i), void qt(t);
                                r--
                            } else "$" !== n && "$?" !== n && "$!" !== n || r++;
                        n = i
                    } while (n);
                    qt(t)
                }

                function ui(e) {
                    for (; null != e; e = e.nextSibling) {
                        var t = e.nodeType;
                        if (1 === t || 3 === t) break;
                        if (8 === t) {
                            if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
                            if ("/$" === t) return null
                        }
                    }
                    return e
                }

                function ci(e) {
                    e = e.previousSibling;
                    for (var t = 0; e;) {
                        if (8 === e.nodeType) {
                            var n = e.data;
                            if ("$" === n || "$!" === n || "$?" === n) {
                                if (0 === t) return e;
                                t--
                            } else "/$" === n && t++
                        }
                        e = e.previousSibling
                    }
                    return null
                }
                var di = Math.random().toString(36).slice(2),
                    hi = "__reactFiber$" + di,
                    fi = "__reactProps$" + di,
                    pi = "__reactContainer$" + di,
                    mi = "__reactEvents$" + di,
                    gi = "__reactListeners$" + di,
                    yi = "__reactHandles$" + di;

                function vi(e) {
                    var t = e[hi];
                    if (t) return t;
                    for (var n = e.parentNode; n;) {
                        if (t = n[pi] || n[hi]) {
                            if (n = t.alternate, null !== t.child || null !== n && null !== n.child)
                                for (e = ci(e); null !== e;) {
                                    if (n = e[hi]) return n;
                                    e = ci(e)
                                }
                            return t
                        }
                        n = (e = n).parentNode
                    }
                    return null
                }

                function bi(e) {
                    return !(e = e[hi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
                }

                function wi(e) {
                    if (5 === e.tag || 6 === e.tag) return e.stateNode;
                    throw Error(o(33))
                }

                function Ei(e) {
                    return e[fi] || null
                }
                var xi = [],
                    Ai = -1;

                function ki(e) {
                    return {
                        current: e
                    }
                }

                function Ci(e) {
                    0 > Ai || (e.current = xi[Ai], xi[Ai] = null, Ai--)
                }

                function Pi(e, t) {
                    Ai++, xi[Ai] = e.current, e.current = t
                }
                var Si = {},
                    _i = ki(Si),
                    Ni = ki(!1),
                    Mi = Si;

                function Ii(e, t) {
                    var n = e.type.contextTypes;
                    if (!n) return Si;
                    var r = e.stateNode;
                    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
                    var i, o = {};
                    for (i in n) o[i] = t[i];
                    return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o
                }

                function Oi(e) {
                    return null !== (e = e.childContextTypes) && void 0 !== e
                }

                function Ti() {
                    Ci(Ni), Ci(_i)
                }

                function Ri(e, t, n) {
                    if (_i.current !== Si) throw Error(o(168));
                    Pi(_i, t), Pi(Ni, n)
                }

                function Li(e, t, n) {
                    var r = e.stateNode;
                    if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n;
                    for (var i in r = r.getChildContext())
                        if (!(i in t)) throw Error(o(108, G(e) || "Unknown", i));
                    return F({}, n, r)
                }

                function Bi(e) {
                    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Si, Mi = _i.current, Pi(_i, e), Pi(Ni, Ni.current), !0
                }

                function Fi(e, t, n) {
                    var r = e.stateNode;
                    if (!r) throw Error(o(169));
                    n ? (e = Li(e, t, Mi), r.__reactInternalMemoizedMergedChildContext = e, Ci(Ni), Ci(_i), Pi(_i, e)) : Ci(Ni), Pi(Ni, n)
                }
                var ji = null,
                    Di = !1,
                    Ui = !1;

                function zi(e) {
                    null === ji ? ji = [e] : ji.push(e)
                }

                function qi() {
                    if (!Ui && null !== ji) {
                        Ui = !0;
                        var e = 0,
                            t = bt;
                        try {
                            var n = ji;
                            for (bt = 1; e < n.length; e++) {
                                var r = n[e];
                                do {
                                    r = r(!0)
                                } while (null !== r)
                            }
                            ji = null, Di = !1
                        } catch (i) {
                            throw null !== ji && (ji = ji.slice(e + 1)), Ve(Xe, qi), i
                        } finally {
                            bt = t, Ui = !1
                        }
                    }
                    return null
                }
                var Gi = [],
                    Hi = 0,
                    $i = null,
                    Qi = 0,
                    Vi = [],
                    Ki = 0,
                    Wi = null,
                    Ji = 1,
                    Zi = "";

                function Yi(e, t) {
                    Gi[Hi++] = Qi, Gi[Hi++] = $i, $i = e, Qi = t
                }

                function Xi(e, t, n) {
                    Vi[Ki++] = Ji, Vi[Ki++] = Zi, Vi[Ki++] = Wi, Wi = e;
                    var r = Ji;
                    e = Zi;
                    var i = 32 - st(r) - 1;
                    r &= ~(1 << i), n += 1;
                    var o = 32 - st(t) + i;
                    if (30 < o) {
                        var s = i - i % 5;
                        o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Ji = 1 << 32 - st(t) + i | n << i | r, Zi = o + e
                    } else Ji = 1 << o | n << i | r, Zi = e
                }

                function eo(e) {
                    null !== e.return && (Yi(e, 1), Xi(e, 1, 0))
                }

                function to(e) {
                    for (; e === $i;) $i = Gi[--Hi], Gi[Hi] = null, Qi = Gi[--Hi], Gi[Hi] = null;
                    for (; e === Wi;) Wi = Vi[--Ki], Vi[Ki] = null, Zi = Vi[--Ki], Vi[Ki] = null, Ji = Vi[--Ki], Vi[Ki] = null
                }
                var no = null,
                    ro = null,
                    io = !1,
                    oo = null;

                function so(e, t) {
                    var n = Iu(5, null, null, 0);
                    n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n)
                }

                function ao(e, t) {
                    switch (e.tag) {
                        case 5:
                            var n = e.type;
                            return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, no = e, ro = ui(t.firstChild), !0);
                        case 6:
                            return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, no = e, ro = null, !0);
                        case 13:
                            return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Wi ? {
                                id: Ji,
                                overflow: Zi
                            } : null, e.memoizedState = {
                                dehydrated: t,
                                treeContext: n,
                                retryLane: 1073741824
                            }, (n = Iu(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, no = e, ro = null, !0);
                        default:
                            return !1
                    }
                }

                function lo(e) {
                    return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
                }

                function uo(e) {
                    if (io) {
                        var t = ro;
                        if (t) {
                            var n = t;
                            if (!ao(e, t)) {
                                if (lo(e)) throw Error(o(418));
                                t = ui(n.nextSibling);
                                var r = no;
                                t && ao(e, t) ? so(r, n) : (e.flags = -4097 & e.flags | 2, io = !1, no = e)
                            }
                        } else {
                            if (lo(e)) throw Error(o(418));
                            e.flags = -4097 & e.flags | 2, io = !1, no = e
                        }
                    }
                }

                function co(e) {
                    for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;) e = e.return;
                    no = e
                }

                function ho(e) {
                    if (e !== no) return !1;
                    if (!io) return co(e), io = !0, !1;
                    var t;
                    if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ro)) {
                        if (lo(e)) throw fo(), Error(o(418));
                        for (; t;) so(e, t), t = ui(t.nextSibling)
                    }
                    if (co(e), 13 === e.tag) {
                        if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317));
                        e: {
                            for (e = e.nextSibling, t = 0; e;) {
                                if (8 === e.nodeType) {
                                    var n = e.data;
                                    if ("/$" === n) {
                                        if (0 === t) {
                                            ro = ui(e.nextSibling);
                                            break e
                                        }
                                        t--
                                    } else "$" !== n && "$!" !== n && "$?" !== n || t++
                                }
                                e = e.nextSibling
                            }
                            ro = null
                        }
                    } else ro = no ? ui(e.stateNode.nextSibling) : null;
                    return !0
                }

                function fo() {
                    for (var e = ro; e;) e = ui(e.nextSibling)
                }

                function po() {
                    ro = no = null, io = !1
                }

                function mo(e) {
                    null === oo ? oo = [e] : oo.push(e)
                }
                var go = w.ReactCurrentBatchConfig;

                function yo(e, t, n) {
                    if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                        if (n._owner) {
                            if (n = n._owner) {
                                if (1 !== n.tag) throw Error(o(309));
                                var r = n.stateNode
                            }
                            if (!r) throw Error(o(147, e));
                            var i = r,
                                s = "" + e;
                            return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === s ? t.ref : (t = function(e) {
                                var t = i.refs;
                                null === e ? delete t[s] : t[s] = e
                            }, t._stringRef = s, t)
                        }
                        if ("string" !== typeof e) throw Error(o(284));
                        if (!n._owner) throw Error(o(290, e))
                    }
                    return e
                }

                function vo(e, t) {
                    throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
                }

                function bo(e) {
                    return (0, e._init)(e._payload)
                }

                function wo(e) {
                    function t(t, n) {
                        if (e) {
                            var r = t.deletions;
                            null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n)
                        }
                    }

                    function n(n, r) {
                        if (!e) return null;
                        for (; null !== r;) t(n, r), r = r.sibling;
                        return null
                    }

                    function r(e, t) {
                        for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
                        return e
                    }

                    function i(e, t) {
                        return (e = Tu(e, t)).index = 0, e.sibling = null, e
                    }

                    function s(t, n, r) {
                        return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n)
                    }

                    function a(t) {
                        return e && null === t.alternate && (t.flags |= 2), t
                    }

                    function l(e, t, n, r) {
                        return null === t || 6 !== t.tag ? ((t = Fu(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function u(e, t, n, r) {
                        var o = n.type;
                        return o === A ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === O && bo(o) === t.type) ? ((r = i(t, n.props)).ref = yo(e, t, n), r.return = e, r) : ((r = Ru(n.type, n.key, n.props, null, e.mode, r)).ref = yo(e, t, n), r.return = e, r)
                    }

                    function c(e, t, n, r) {
                        return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = ju(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
                    }

                    function d(e, t, n, r, o) {
                        return null === t || 7 !== t.tag ? ((t = Lu(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function h(e, t, n) {
                        if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Fu("" + t, e.mode, n)).return = e, t;
                        if ("object" === typeof t && null !== t) {
                            switch (t.$$typeof) {
                                case E:
                                    return (n = Ru(t.type, t.key, t.props, null, e.mode, n)).ref = yo(e, null, t), n.return = e, n;
                                case x:
                                    return (t = ju(t, e.mode, n)).return = e, t;
                                case O:
                                    return h(e, (0, t._init)(t._payload), n)
                            }
                            if (te(t) || L(t)) return (t = Lu(t, e.mode, n, null)).return = e, t;
                            vo(e, t)
                        }
                        return null
                    }

                    function f(e, t, n, r) {
                        var i = null !== t ? t.key : null;
                        if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r);
                        if ("object" === typeof n && null !== n) {
                            switch (n.$$typeof) {
                                case E:
                                    return n.key === i ? u(e, t, n, r) : null;
                                case x:
                                    return n.key === i ? c(e, t, n, r) : null;
                                case O:
                                    return f(e, t, (i = n._init)(n._payload), r)
                            }
                            if (te(n) || L(n)) return null !== i ? null : d(e, t, n, r, null);
                            vo(e, n)
                        }
                        return null
                    }

                    function p(e, t, n, r, i) {
                        if ("string" === typeof r && "" !== r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i);
                        if ("object" === typeof r && null !== r) {
                            switch (r.$$typeof) {
                                case E:
                                    return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case x:
                                    return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case O:
                                    return p(e, t, n, (0, r._init)(r._payload), i)
                            }
                            if (te(r) || L(r)) return d(t, e = e.get(n) || null, r, i, null);
                            vo(t, r)
                        }
                        return null
                    }

                    function m(i, o, a, l) {
                        for (var u = null, c = null, d = o, m = o = 0, g = null; null !== d && m < a.length; m++) {
                            d.index > m ? (g = d, d = null) : g = d.sibling;
                            var y = f(i, d, a[m], l);
                            if (null === y) {
                                null === d && (d = g);
                                break
                            }
                            e && d && null === y.alternate && t(i, d), o = s(y, o, m), null === c ? u = y : c.sibling = y, c = y, d = g
                        }
                        if (m === a.length) return n(i, d), io && Yi(i, m), u;
                        if (null === d) {
                            for (; m < a.length; m++) null !== (d = h(i, a[m], l)) && (o = s(d, o, m), null === c ? u = d : c.sibling = d, c = d);
                            return io && Yi(i, m), u
                        }
                        for (d = r(i, d); m < a.length; m++) null !== (g = p(d, i, m, a[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), o = s(g, o, m), null === c ? u = g : c.sibling = g, c = g);
                        return e && d.forEach((function(e) {
                            return t(i, e)
                        })), io && Yi(i, m), u
                    }

                    function g(i, a, l, u) {
                        var c = L(l);
                        if ("function" !== typeof c) throw Error(o(150));
                        if (null == (l = c.call(l))) throw Error(o(151));
                        for (var d = c = null, m = a, g = a = 0, y = null, v = l.next(); null !== m && !v.done; g++, v = l.next()) {
                            m.index > g ? (y = m, m = null) : y = m.sibling;
                            var b = f(i, m, v.value, u);
                            if (null === b) {
                                null === m && (m = y);
                                break
                            }
                            e && m && null === b.alternate && t(i, m), a = s(b, a, g), null === d ? c = b : d.sibling = b, d = b, m = y
                        }
                        if (v.done) return n(i, m), io && Yi(i, g), c;
                        if (null === m) {
                            for (; !v.done; g++, v = l.next()) null !== (v = h(i, v.value, u)) && (a = s(v, a, g), null === d ? c = v : d.sibling = v, d = v);
                            return io && Yi(i, g), c
                        }
                        for (m = r(i, m); !v.done; g++, v = l.next()) null !== (v = p(m, i, g, v.value, u)) && (e && null !== v.alternate && m.delete(null === v.key ? g : v.key), a = s(v, a, g), null === d ? c = v : d.sibling = v, d = v);
                        return e && m.forEach((function(e) {
                            return t(i, e)
                        })), io && Yi(i, g), c
                    }
                    return function e(r, o, s, l) {
                        if ("object" === typeof s && null !== s && s.type === A && null === s.key && (s = s.props.children), "object" === typeof s && null !== s) {
                            switch (s.$$typeof) {
                                case E:
                                    e: {
                                        for (var u = s.key, c = o; null !== c;) {
                                            if (c.key === u) {
                                                if ((u = s.type) === A) {
                                                    if (7 === c.tag) {
                                                        n(r, c.sibling), (o = i(c, s.props.children)).return = r, r = o;
                                                        break e
                                                    }
                                                } else if (c.elementType === u || "object" === typeof u && null !== u && u.$$typeof === O && bo(u) === c.type) {
                                                    n(r, c.sibling), (o = i(c, s.props)).ref = yo(r, c, s), o.return = r, r = o;
                                                    break e
                                                }
                                                n(r, c);
                                                break
                                            }
                                            t(r, c), c = c.sibling
                                        }
                                        s.type === A ? ((o = Lu(s.props.children, r.mode, l, s.key)).return = r, r = o) : ((l = Ru(s.type, s.key, s.props, null, r.mode, l)).ref = yo(r, o, s), l.return = r, r = l)
                                    }
                                    return a(r);
                                case x:
                                    e: {
                                        for (c = s.key; null !== o;) {
                                            if (o.key === c) {
                                                if (4 === o.tag && o.stateNode.containerInfo === s.containerInfo && o.stateNode.implementation === s.implementation) {
                                                    n(r, o.sibling), (o = i(o, s.children || [])).return = r, r = o;
                                                    break e
                                                }
                                                n(r, o);
                                                break
                                            }
                                            t(r, o), o = o.sibling
                                        }(o = ju(s, r.mode, l)).return = r,
                                        r = o
                                    }
                                    return a(r);
                                case O:
                                    return e(r, o, (c = s._init)(s._payload), l)
                            }
                            if (te(s)) return m(r, o, s, l);
                            if (L(s)) return g(r, o, s, l);
                            vo(r, s)
                        }
                        return "string" === typeof s && "" !== s || "number" === typeof s ? (s = "" + s, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, s)).return = r, r = o) : (n(r, o), (o = Fu(s, r.mode, l)).return = r, r = o), a(r)) : n(r, o)
                    }
                }
                var Eo = wo(!0),
                    xo = wo(!1),
                    Ao = ki(null),
                    ko = null,
                    Co = null,
                    Po = null;

                function So() {
                    Po = Co = ko = null
                }

                function _o(e) {
                    var t = Ao.current;
                    Ci(Ao), e._currentValue = t
                }

                function No(e, t, n) {
                    for (; null !== e;) {
                        var r = e.alternate;
                        if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
                        e = e.return
                    }
                }

                function Mo(e, t) {
                    ko = e, Po = Co = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (ba = !0), e.firstContext = null)
                }

                function Io(e) {
                    var t = e._currentValue;
                    if (Po !== e)
                        if (e = {
                                context: e,
                                memoizedValue: t,
                                next: null
                            }, null === Co) {
                            if (null === ko) throw Error(o(308));
                            Co = e, ko.dependencies = {
                                lanes: 0,
                                firstContext: e
                            }
                        } else Co = Co.next = e;
                    return t
                }
                var Oo = null;

                function To(e) {
                    null === Oo ? Oo = [e] : Oo.push(e)
                }

                function Ro(e, t, n, r) {
                    var i = t.interleaved;
                    return null === i ? (n.next = n, To(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Lo(e, r)
                }

                function Lo(e, t) {
                    e.lanes |= t;
                    var n = e.alternate;
                    for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;) e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return;
                    return 3 === n.tag ? n.stateNode : null
                }
                var Bo = !1;

                function Fo(e) {
                    e.updateQueue = {
                        baseState: e.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null,
                            interleaved: null,
                            lanes: 0
                        },
                        effects: null
                    }
                }

                function jo(e, t) {
                    e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
                        baseState: e.baseState,
                        firstBaseUpdate: e.firstBaseUpdate,
                        lastBaseUpdate: e.lastBaseUpdate,
                        shared: e.shared,
                        effects: e.effects
                    })
                }

                function Do(e, t) {
                    return {
                        eventTime: e,
                        lane: t,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null
                    }
                }

                function Uo(e, t, n) {
                    var r = e.updateQueue;
                    if (null === r) return null;
                    if (r = r.shared, 0 !== (2 & _l)) {
                        var i = r.pending;
                        return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Lo(e, n)
                    }
                    return null === (i = r.interleaved) ? (t.next = t, To(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Lo(e, n)
                }

                function zo(e, t, n) {
                    if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, vt(e, n)
                    }
                }

                function qo(e, t) {
                    var n = e.updateQueue,
                        r = e.alternate;
                    if (null !== r && n === (r = r.updateQueue)) {
                        var i = null,
                            o = null;
                        if (null !== (n = n.firstBaseUpdate)) {
                            do {
                                var s = {
                                    eventTime: n.eventTime,
                                    lane: n.lane,
                                    tag: n.tag,
                                    payload: n.payload,
                                    callback: n.callback,
                                    next: null
                                };
                                null === o ? i = o = s : o = o.next = s, n = n.next
                            } while (null !== n);
                            null === o ? i = o = t : o = o.next = t
                        } else i = o = t;
                        return n = {
                            baseState: r.baseState,
                            firstBaseUpdate: i,
                            lastBaseUpdate: o,
                            shared: r.shared,
                            effects: r.effects
                        }, void(e.updateQueue = n)
                    }
                    null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
                }

                function Go(e, t, n, r) {
                    var i = e.updateQueue;
                    Bo = !1;
                    var o = i.firstBaseUpdate,
                        s = i.lastBaseUpdate,
                        a = i.shared.pending;
                    if (null !== a) {
                        i.shared.pending = null;
                        var l = a,
                            u = l.next;
                        l.next = null, null === s ? o = u : s.next = u, s = l;
                        var c = e.alternate;
                        null !== c && ((a = (c = c.updateQueue).lastBaseUpdate) !== s && (null === a ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l))
                    }
                    if (null !== o) {
                        var d = i.baseState;
                        for (s = 0, c = u = l = null, a = o;;) {
                            var h = a.lane,
                                f = a.eventTime;
                            if ((r & h) === h) {
                                null !== c && (c = c.next = {
                                    eventTime: f,
                                    lane: 0,
                                    tag: a.tag,
                                    payload: a.payload,
                                    callback: a.callback,
                                    next: null
                                });
                                e: {
                                    var p = e,
                                        m = a;
                                    switch (h = t, f = n, m.tag) {
                                        case 1:
                                            if ("function" === typeof(p = m.payload)) {
                                                d = p.call(f, d, h);
                                                break e
                                            }
                                            d = p;
                                            break e;
                                        case 3:
                                            p.flags = -65537 & p.flags | 128;
                                        case 0:
                                            if (null === (h = "function" === typeof(p = m.payload) ? p.call(f, d, h) : p) || void 0 === h) break e;
                                            d = F({}, d, h);
                                            break e;
                                        case 2:
                                            Bo = !0
                                    }
                                }
                                null !== a.callback && 0 !== a.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [a] : h.push(a))
                            } else f = {
                                eventTime: f,
                                lane: h,
                                tag: a.tag,
                                payload: a.payload,
                                callback: a.callback,
                                next: null
                            }, null === c ? (u = c = f, l = d) : c = c.next = f, s |= h;
                            if (null === (a = a.next)) {
                                if (null === (a = i.shared.pending)) break;
                                a = (h = a).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null
                            }
                        }
                        if (null === c && (l = d), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, null !== (t = i.shared.interleaved)) {
                            i = t;
                            do {
                                s |= i.lane, i = i.next
                            } while (i !== t)
                        } else null === o && (i.shared.lanes = 0);
                        Bl |= s, e.lanes = s, e.memoizedState = d
                    }
                }

                function Ho(e, t, n) {
                    if (e = t.effects, t.effects = null, null !== e)
                        for (t = 0; t < e.length; t++) {
                            var r = e[t],
                                i = r.callback;
                            if (null !== i) {
                                if (r.callback = null, r = n, "function" !== typeof i) throw Error(o(191, i));
                                i.call(r)
                            }
                        }
                }
                var $o = {},
                    Qo = ki($o),
                    Vo = ki($o),
                    Ko = ki($o);

                function Wo(e) {
                    if (e === $o) throw Error(o(174));
                    return e
                }

                function Jo(e, t) {
                    switch (Pi(Ko, t), Pi(Vo, e), Pi(Qo, $o), e = t.nodeType) {
                        case 9:
                        case 11:
                            t = (t = t.documentElement) ? t.namespaceURI : le(null, "");
                            break;
                        default:
                            t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
                    }
                    Ci(Qo), Pi(Qo, t)
                }

                function Zo() {
                    Ci(Qo), Ci(Vo), Ci(Ko)
                }

                function Yo(e) {
                    Wo(Ko.current);
                    var t = Wo(Qo.current),
                        n = le(t, e.type);
                    t !== n && (Pi(Vo, e), Pi(Qo, n))
                }

                function Xo(e) {
                    Vo.current === e && (Ci(Qo), Ci(Vo))
                }
                var es = ki(0);

                function ts(e) {
                    for (var t = e; null !== t;) {
                        if (13 === t.tag) {
                            var n = t.memoizedState;
                            if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t
                        } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                            if (0 !== (128 & t.flags)) return t
                        } else if (null !== t.child) {
                            t.child.return = t, t = t.child;
                            continue
                        }
                        if (t === e) break;
                        for (; null === t.sibling;) {
                            if (null === t.return || t.return === e) return null;
                            t = t.return
                        }
                        t.sibling.return = t.return, t = t.sibling
                    }
                    return null
                }
                var ns = [];

                function rs() {
                    for (var e = 0; e < ns.length; e++) ns[e]._workInProgressVersionPrimary = null;
                    ns.length = 0
                }
                var is = w.ReactCurrentDispatcher,
                    os = w.ReactCurrentBatchConfig,
                    ss = 0,
                    as = null,
                    ls = null,
                    us = null,
                    cs = !1,
                    ds = !1,
                    hs = 0,
                    fs = 0;

                function ps() {
                    throw Error(o(321))
                }

                function ms(e, t) {
                    if (null === t) return !1;
                    for (var n = 0; n < t.length && n < e.length; n++)
                        if (!ar(e[n], t[n])) return !1;
                    return !0
                }

                function gs(e, t, n, r, i, s) {
                    if (ss = s, as = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, is.current = null === e || null === e.memoizedState ? Xs : ea, e = n(r, i), ds) {
                        s = 0;
                        do {
                            if (ds = !1, hs = 0, 25 <= s) throw Error(o(301));
                            s += 1, us = ls = null, t.updateQueue = null, is.current = ta, e = n(r, i)
                        } while (ds)
                    }
                    if (is.current = Ys, t = null !== ls && null !== ls.next, ss = 0, us = ls = as = null, cs = !1, t) throw Error(o(300));
                    return e
                }

                function ys() {
                    var e = 0 !== hs;
                    return hs = 0, e
                }

                function vs() {
                    var e = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    return null === us ? as.memoizedState = us = e : us = us.next = e, us
                }

                function bs() {
                    if (null === ls) {
                        var e = as.alternate;
                        e = null !== e ? e.memoizedState : null
                    } else e = ls.next;
                    var t = null === us ? as.memoizedState : us.next;
                    if (null !== t) us = t, ls = e;
                    else {
                        if (null === e) throw Error(o(310));
                        e = {
                            memoizedState: (ls = e).memoizedState,
                            baseState: ls.baseState,
                            baseQueue: ls.baseQueue,
                            queue: ls.queue,
                            next: null
                        }, null === us ? as.memoizedState = us = e : us = us.next = e
                    }
                    return us
                }

                function ws(e, t) {
                    return "function" === typeof t ? t(e) : t
                }

                function Es(e) {
                    var t = bs(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = ls,
                        i = r.baseQueue,
                        s = n.pending;
                    if (null !== s) {
                        if (null !== i) {
                            var a = i.next;
                            i.next = s.next, s.next = a
                        }
                        r.baseQueue = i = s, n.pending = null
                    }
                    if (null !== i) {
                        s = i.next, r = r.baseState;
                        var l = a = null,
                            u = null,
                            c = s;
                        do {
                            var d = c.lane;
                            if ((ss & d) === d) null !== u && (u = u.next = {
                                lane: 0,
                                action: c.action,
                                hasEagerState: c.hasEagerState,
                                eagerState: c.eagerState,
                                next: null
                            }), r = c.hasEagerState ? c.eagerState : e(r, c.action);
                            else {
                                var h = {
                                    lane: d,
                                    action: c.action,
                                    hasEagerState: c.hasEagerState,
                                    eagerState: c.eagerState,
                                    next: null
                                };
                                null === u ? (l = u = h, a = r) : u = u.next = h, as.lanes |= d, Bl |= d
                            }
                            c = c.next
                        } while (null !== c && c !== s);
                        null === u ? a = r : u.next = l, ar(r, t.memoizedState) || (ba = !0), t.memoizedState = r, t.baseState = a, t.baseQueue = u, n.lastRenderedState = r
                    }
                    if (null !== (e = n.interleaved)) {
                        i = e;
                        do {
                            s = i.lane, as.lanes |= s, Bl |= s, i = i.next
                        } while (i !== e)
                    } else null === i && (n.lanes = 0);
                    return [t.memoizedState, n.dispatch]
                }

                function xs(e) {
                    var t = bs(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = n.dispatch,
                        i = n.pending,
                        s = t.memoizedState;
                    if (null !== i) {
                        n.pending = null;
                        var a = i = i.next;
                        do {
                            s = e(s, a.action), a = a.next
                        } while (a !== i);
                        ar(s, t.memoizedState) || (ba = !0), t.memoizedState = s, null === t.baseQueue && (t.baseState = s), n.lastRenderedState = s
                    }
                    return [s, r]
                }

                function As() {}

                function ks(e, t) {
                    var n = as,
                        r = bs(),
                        i = t(),
                        s = !ar(r.memoizedState, i);
                    if (s && (r.memoizedState = i, ba = !0), r = r.queue, Bs(Ss.bind(null, n, r, e), [e]), r.getSnapshot !== t || s || null !== us && 1 & us.memoizedState.tag) {
                        if (n.flags |= 2048, Is(9, Ps.bind(null, n, r, i, t), void 0, null), null === Nl) throw Error(o(349));
                        0 !== (30 & ss) || Cs(n, t, i)
                    }
                    return i
                }

                function Cs(e, t, n) {
                    e.flags |= 16384, e = {
                        getSnapshot: t,
                        value: n
                    }, null === (t = as.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, as.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
                }

                function Ps(e, t, n, r) {
                    t.value = n, t.getSnapshot = r, _s(t) && Ns(e)
                }

                function Ss(e, t, n) {
                    return n((function() {
                        _s(t) && Ns(e)
                    }))
                }

                function _s(e) {
                    var t = e.getSnapshot;
                    e = e.value;
                    try {
                        var n = t();
                        return !ar(e, n)
                    } catch (r) {
                        return !0
                    }
                }

                function Ns(e) {
                    var t = Lo(e, 1);
                    null !== t && nu(t, e, 1, -1)
                }

                function Ms(e) {
                    var t = vs();
                    return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: ws,
                        lastRenderedState: e
                    }, t.queue = e, e = e.dispatch = Ks.bind(null, as, e), [t.memoizedState, e]
                }

                function Is(e, t, n, r) {
                    return e = {
                        tag: e,
                        create: t,
                        destroy: n,
                        deps: r,
                        next: null
                    }, null === (t = as.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, as.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
                }

                function Os() {
                    return bs().memoizedState
                }

                function Ts(e, t, n, r) {
                    var i = vs();
                    as.flags |= e, i.memoizedState = Is(1 | t, n, void 0, void 0 === r ? null : r)
                }

                function Rs(e, t, n, r) {
                    var i = bs();
                    r = void 0 === r ? null : r;
                    var o = void 0;
                    if (null !== ls) {
                        var s = ls.memoizedState;
                        if (o = s.destroy, null !== r && ms(r, s.deps)) return void(i.memoizedState = Is(t, n, o, r))
                    }
                    as.flags |= e, i.memoizedState = Is(1 | t, n, o, r)
                }

                function Ls(e, t) {
                    return Ts(8390656, 8, e, t)
                }

                function Bs(e, t) {
                    return Rs(2048, 8, e, t)
                }

                function Fs(e, t) {
                    return Rs(4, 2, e, t)
                }

                function js(e, t) {
                    return Rs(4, 4, e, t)
                }

                function Ds(e, t) {
                    return "function" === typeof t ? (e = e(), t(e), function() {
                        t(null)
                    }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function() {
                        t.current = null
                    }) : void 0
                }

                function Us(e, t, n) {
                    return n = null !== n && void 0 !== n ? n.concat([e]) : null, Rs(4, 4, Ds.bind(null, t, e), n)
                }

                function zs() {}

                function qs(e, t) {
                    var n = bs();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && ms(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
                }

                function Gs(e, t) {
                    var n = bs();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && ms(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
                }

                function Hs(e, t, n) {
                    return 0 === (21 & ss) ? (e.baseState && (e.baseState = !1, ba = !0), e.memoizedState = n) : (ar(n, t) || (n = mt(), as.lanes |= n, Bl |= n, e.baseState = !0), t)
                }

                function $s(e, t) {
                    var n = bt;
                    bt = 0 !== n && 4 > n ? n : 4, e(!0);
                    var r = os.transition;
                    os.transition = {};
                    try {
                        e(!1), t()
                    } finally {
                        bt = n, os.transition = r
                    }
                }

                function Qs() {
                    return bs().memoizedState
                }

                function Vs(e, t, n) {
                    var r = tu(e);
                    if (n = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        }, Ws(e)) Js(t, n);
                    else if (null !== (n = Ro(e, t, n, r))) {
                        nu(n, e, r, eu()), Zs(n, t, r)
                    }
                }

                function Ks(e, t, n) {
                    var r = tu(e),
                        i = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        };
                    if (Ws(e)) Js(t, i);
                    else {
                        var o = e.alternate;
                        if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try {
                            var s = t.lastRenderedState,
                                a = o(s, n);
                            if (i.hasEagerState = !0, i.eagerState = a, ar(a, s)) {
                                var l = t.interleaved;
                                return null === l ? (i.next = i, To(t)) : (i.next = l.next, l.next = i), void(t.interleaved = i)
                            }
                        } catch (u) {}
                        null !== (n = Ro(e, t, i, r)) && (nu(n, e, r, i = eu()), Zs(n, t, r))
                    }
                }

                function Ws(e) {
                    var t = e.alternate;
                    return e === as || null !== t && t === as
                }

                function Js(e, t) {
                    ds = cs = !0;
                    var n = e.pending;
                    null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
                }

                function Zs(e, t, n) {
                    if (0 !== (4194240 & n)) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, vt(e, n)
                    }
                }
                var Ys = {
                        readContext: Io,
                        useCallback: ps,
                        useContext: ps,
                        useEffect: ps,
                        useImperativeHandle: ps,
                        useInsertionEffect: ps,
                        useLayoutEffect: ps,
                        useMemo: ps,
                        useReducer: ps,
                        useRef: ps,
                        useState: ps,
                        useDebugValue: ps,
                        useDeferredValue: ps,
                        useTransition: ps,
                        useMutableSource: ps,
                        useSyncExternalStore: ps,
                        useId: ps,
                        unstable_isNewReconciler: !1
                    },
                    Xs = {
                        readContext: Io,
                        useCallback: function(e, t) {
                            return vs().memoizedState = [e, void 0 === t ? null : t], e
                        },
                        useContext: Io,
                        useEffect: Ls,
                        useImperativeHandle: function(e, t, n) {
                            return n = null !== n && void 0 !== n ? n.concat([e]) : null, Ts(4194308, 4, Ds.bind(null, t, e), n)
                        },
                        useLayoutEffect: function(e, t) {
                            return Ts(4194308, 4, e, t)
                        },
                        useInsertionEffect: function(e, t) {
                            return Ts(4, 2, e, t)
                        },
                        useMemo: function(e, t) {
                            var n = vs();
                            return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
                        },
                        useReducer: function(e, t, n) {
                            var r = vs();
                            return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = {
                                pending: null,
                                interleaved: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: e,
                                lastRenderedState: t
                            }, r.queue = e, e = e.dispatch = Vs.bind(null, as, e), [r.memoizedState, e]
                        },
                        useRef: function(e) {
                            return e = {
                                current: e
                            }, vs().memoizedState = e
                        },
                        useState: Ms,
                        useDebugValue: zs,
                        useDeferredValue: function(e) {
                            return vs().memoizedState = e
                        },
                        useTransition: function() {
                            var e = Ms(!1),
                                t = e[0];
                            return e = $s.bind(null, e[1]), vs().memoizedState = e, [t, e]
                        },
                        useMutableSource: function() {},
                        useSyncExternalStore: function(e, t, n) {
                            var r = as,
                                i = vs();
                            if (io) {
                                if (void 0 === n) throw Error(o(407));
                                n = n()
                            } else {
                                if (n = t(), null === Nl) throw Error(o(349));
                                0 !== (30 & ss) || Cs(r, t, n)
                            }
                            i.memoizedState = n;
                            var s = {
                                value: n,
                                getSnapshot: t
                            };
                            return i.queue = s, Ls(Ss.bind(null, r, s, e), [e]), r.flags |= 2048, Is(9, Ps.bind(null, r, s, n, t), void 0, null), n
                        },
                        useId: function() {
                            var e = vs(),
                                t = Nl.identifierPrefix;
                            if (io) {
                                var n = Zi;
                                t = ":" + t + "R" + (n = (Ji & ~(1 << 32 - st(Ji) - 1)).toString(32) + n), 0 < (n = hs++) && (t += "H" + n.toString(32)), t += ":"
                            } else t = ":" + t + "r" + (n = fs++).toString(32) + ":";
                            return e.memoizedState = t
                        },
                        unstable_isNewReconciler: !1
                    },
                    ea = {
                        readContext: Io,
                        useCallback: qs,
                        useContext: Io,
                        useEffect: Bs,
                        useImperativeHandle: Us,
                        useInsertionEffect: Fs,
                        useLayoutEffect: js,
                        useMemo: Gs,
                        useReducer: Es,
                        useRef: Os,
                        useState: function() {
                            return Es(ws)
                        },
                        useDebugValue: zs,
                        useDeferredValue: function(e) {
                            return Hs(bs(), ls.memoizedState, e)
                        },
                        useTransition: function() {
                            return [Es(ws)[0], bs().memoizedState]
                        },
                        useMutableSource: As,
                        useSyncExternalStore: ks,
                        useId: Qs,
                        unstable_isNewReconciler: !1
                    },
                    ta = {
                        readContext: Io,
                        useCallback: qs,
                        useContext: Io,
                        useEffect: Bs,
                        useImperativeHandle: Us,
                        useInsertionEffect: Fs,
                        useLayoutEffect: js,
                        useMemo: Gs,
                        useReducer: xs,
                        useRef: Os,
                        useState: function() {
                            return xs(ws)
                        },
                        useDebugValue: zs,
                        useDeferredValue: function(e) {
                            var t = bs();
                            return null === ls ? t.memoizedState = e : Hs(t, ls.memoizedState, e)
                        },
                        useTransition: function() {
                            return [xs(ws)[0], bs().memoizedState]
                        },
                        useMutableSource: As,
                        useSyncExternalStore: ks,
                        useId: Qs,
                        unstable_isNewReconciler: !1
                    };

                function na(e, t) {
                    if (e && e.defaultProps) {
                        for (var n in t = F({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
                        return t
                    }
                    return t
                }

                function ra(e, t, n, r) {
                    n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : F({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
                }
                var ia = {
                    isMounted: function(e) {
                        return !!(e = e._reactInternals) && qe(e) === e
                    },
                    enqueueSetState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = eu(),
                            i = tu(e),
                            o = Do(r, i);
                        o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Uo(e, o, i)) && (nu(t, e, i, r), zo(t, e, i))
                    },
                    enqueueReplaceState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = eu(),
                            i = tu(e),
                            o = Do(r, i);
                        o.tag = 1, o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Uo(e, o, i)) && (nu(t, e, i, r), zo(t, e, i))
                    },
                    enqueueForceUpdate: function(e, t) {
                        e = e._reactInternals;
                        var n = eu(),
                            r = tu(e),
                            i = Do(n, r);
                        i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = Uo(e, i, r)) && (nu(t, e, r, n), zo(t, e, r))
                    }
                };

                function oa(e, t, n, r, i, o, s) {
                    return "function" === typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, o))
                }

                function sa(e, t, n) {
                    var r = !1,
                        i = Si,
                        o = t.contextType;
                    return "object" === typeof o && null !== o ? o = Io(o) : (i = Oi(t) ? Mi : _i.current, o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Ii(e, i) : Si), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = ia, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t
                }

                function aa(e, t, n, r) {
                    e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && ia.enqueueReplaceState(t, t.state, null)
                }

                function la(e, t, n, r) {
                    var i = e.stateNode;
                    i.props = n, i.state = e.memoizedState, i.refs = {}, Fo(e);
                    var o = t.contextType;
                    "object" === typeof o && null !== o ? i.context = Io(o) : (o = Oi(t) ? Mi : _i.current, i.context = Ii(e, o)), i.state = e.memoizedState, "function" === typeof(o = t.getDerivedStateFromProps) && (ra(e, t, o, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && ia.enqueueReplaceState(i, i.state, null), Go(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308)
                }

                function ua(e, t) {
                    try {
                        var n = "",
                            r = t;
                        do {
                            n += z(r), r = r.return
                        } while (r);
                        var i = n
                    } catch (o) {
                        i = "\nError generating stack: " + o.message + "\n" + o.stack
                    }
                    return {
                        value: e,
                        source: t,
                        stack: i,
                        digest: null
                    }
                }

                function ca(e, t, n) {
                    return {
                        value: e,
                        source: null,
                        stack: null != n ? n : null,
                        digest: null != t ? t : null
                    }
                }

                function da(e, t) {
                    try {
                        console.error(t.value)
                    } catch (n) {
                        setTimeout((function() {
                            throw n
                        }))
                    }
                }
                var ha = "function" === typeof WeakMap ? WeakMap : Map;

                function fa(e, t, n) {
                    (n = Do(-1, n)).tag = 3, n.payload = {
                        element: null
                    };
                    var r = t.value;
                    return n.callback = function() {
                        Hl || (Hl = !0, $l = r), da(0, t)
                    }, n
                }

                function pa(e, t, n) {
                    (n = Do(-1, n)).tag = 3;
                    var r = e.type.getDerivedStateFromError;
                    if ("function" === typeof r) {
                        var i = t.value;
                        n.payload = function() {
                            return r(i)
                        }, n.callback = function() {
                            da(0, t)
                        }
                    }
                    var o = e.stateNode;
                    return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
                        da(0, t), "function" !== typeof r && (null === Ql ? Ql = new Set([this]) : Ql.add(this));
                        var e = t.stack;
                        this.componentDidCatch(t.value, {
                            componentStack: null !== e ? e : ""
                        })
                    }), n
                }

                function ma(e, t, n) {
                    var r = e.pingCache;
                    if (null === r) {
                        r = e.pingCache = new ha;
                        var i = new Set;
                        r.set(t, i)
                    } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i));
                    i.has(n) || (i.add(n), e = Cu.bind(null, e, t, n), t.then(e, e))
                }

                function ga(e) {
                    do {
                        var t;
                        if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e;
                        e = e.return
                    } while (null !== e);
                    return null
                }

                function ya(e, t, n, r, i) {
                    return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Do(-1, 1)).tag = 2, Uo(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e)
                }
                var va = w.ReactCurrentOwner,
                    ba = !1;

                function wa(e, t, n, r) {
                    t.child = null === e ? xo(t, null, n, r) : Eo(t, e.child, n, r)
                }

                function Ea(e, t, n, r, i) {
                    n = n.render;
                    var o = t.ref;
                    return Mo(t, i), r = gs(e, t, n, r, o, i), n = ys(), null === e || ba ? (io && n && eo(t), t.flags |= 1, wa(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ha(e, t, i))
                }

                function xa(e, t, n, r, i) {
                    if (null === e) {
                        var o = n.type;
                        return "function" !== typeof o || Ou(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Ru(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, Aa(e, t, o, r, i))
                    }
                    if (o = e.child, 0 === (e.lanes & i)) {
                        var s = o.memoizedProps;
                        if ((n = null !== (n = n.compare) ? n : lr)(s, r) && e.ref === t.ref) return Ha(e, t, i)
                    }
                    return t.flags |= 1, (e = Tu(o, r)).ref = t.ref, e.return = t, t.child = e
                }

                function Aa(e, t, n, r, i) {
                    if (null !== e) {
                        var o = e.memoizedProps;
                        if (lr(o, r) && e.ref === t.ref) {
                            if (ba = !1, t.pendingProps = r = o, 0 === (e.lanes & i)) return t.lanes = e.lanes, Ha(e, t, i);
                            0 !== (131072 & e.flags) && (ba = !0)
                        }
                    }
                    return Pa(e, t, n, r, i)
                }

                function ka(e, t, n) {
                    var r = t.pendingProps,
                        i = r.children,
                        o = null !== e ? e.memoizedState : null;
                    if ("hidden" === r.mode)
                        if (0 === (1 & t.mode)) t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        }, Pi(Tl, Ol), Ol |= n;
                        else {
                            if (0 === (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                                baseLanes: e,
                                cachePool: null,
                                transitions: null
                            }, t.updateQueue = null, Pi(Tl, Ol), Ol |= e, null;
                            t.memoizedState = {
                                baseLanes: 0,
                                cachePool: null,
                                transitions: null
                            }, r = null !== o ? o.baseLanes : n, Pi(Tl, Ol), Ol |= r
                        }
                    else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Pi(Tl, Ol), Ol |= r;
                    return wa(e, t, i, n), t.child
                }

                function Ca(e, t) {
                    var n = t.ref;
                    (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
                }

                function Pa(e, t, n, r, i) {
                    var o = Oi(n) ? Mi : _i.current;
                    return o = Ii(t, o), Mo(t, i), n = gs(e, t, n, r, o, i), r = ys(), null === e || ba ? (io && r && eo(t), t.flags |= 1, wa(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ha(e, t, i))
                }

                function Sa(e, t, n, r, i) {
                    if (Oi(n)) {
                        var o = !0;
                        Bi(t)
                    } else o = !1;
                    if (Mo(t, i), null === t.stateNode) Ga(e, t), sa(t, n, r), la(t, n, r, i), r = !0;
                    else if (null === e) {
                        var s = t.stateNode,
                            a = t.memoizedProps;
                        s.props = a;
                        var l = s.context,
                            u = n.contextType;
                        "object" === typeof u && null !== u ? u = Io(u) : u = Ii(t, u = Oi(n) ? Mi : _i.current);
                        var c = n.getDerivedStateFromProps,
                            d = "function" === typeof c || "function" === typeof s.getSnapshotBeforeUpdate;
                        d || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== r || l !== u) && aa(t, s, r, u), Bo = !1;
                        var h = t.memoizedState;
                        s.state = h, Go(t, r, s, i), l = t.memoizedState, a !== r || h !== l || Ni.current || Bo ? ("function" === typeof c && (ra(t, n, c, r), l = t.memoizedState), (a = Bo || oa(t, n, a, r, h, l, u)) ? (d || "function" !== typeof s.UNSAFE_componentWillMount && "function" !== typeof s.componentWillMount || ("function" === typeof s.componentWillMount && s.componentWillMount(), "function" === typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()), "function" === typeof s.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = u, r = a) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), r = !1)
                    } else {
                        s = t.stateNode, jo(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : na(t.type, a), s.props = u, d = t.pendingProps, h = s.context, "object" === typeof(l = n.contextType) && null !== l ? l = Io(l) : l = Ii(t, l = Oi(n) ? Mi : _i.current);
                        var f = n.getDerivedStateFromProps;
                        (c = "function" === typeof f || "function" === typeof s.getSnapshotBeforeUpdate) || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== d || h !== l) && aa(t, s, r, l), Bo = !1, h = t.memoizedState, s.state = h, Go(t, r, s, i);
                        var p = t.memoizedState;
                        a !== d || h !== p || Ni.current || Bo ? ("function" === typeof f && (ra(t, n, f, r), p = t.memoizedState), (u = Bo || oa(t, n, u, r, h, p, l) || !1) ? (c || "function" !== typeof s.UNSAFE_componentWillUpdate && "function" !== typeof s.componentWillUpdate || ("function" === typeof s.componentWillUpdate && s.componentWillUpdate(r, p, l), "function" === typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, p, l)), "function" === typeof s.componentDidUpdate && (t.flags |= 4), "function" === typeof s.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), s.props = r, s.state = p, s.context = l, r = u) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1)
                    }
                    return _a(e, t, n, r, o, i)
                }

                function _a(e, t, n, r, i, o) {
                    Ca(e, t);
                    var s = 0 !== (128 & t.flags);
                    if (!r && !s) return i && Fi(t, n, !1), Ha(e, t, o);
                    r = t.stateNode, va.current = t;
                    var a = s && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                    return t.flags |= 1, null !== e && s ? (t.child = Eo(t, e.child, null, o), t.child = Eo(t, null, a, o)) : wa(e, t, a, o), t.memoizedState = r.state, i && Fi(t, n, !0), t.child
                }

                function Na(e) {
                    var t = e.stateNode;
                    t.pendingContext ? Ri(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Ri(0, t.context, !1), Jo(e, t.containerInfo)
                }

                function Ma(e, t, n, r, i) {
                    return po(), mo(i), t.flags |= 256, wa(e, t, n, r), t.child
                }
                var Ia, Oa, Ta, Ra, La = {
                    dehydrated: null,
                    treeContext: null,
                    retryLane: 0
                };

                function Ba(e) {
                    return {
                        baseLanes: e,
                        cachePool: null,
                        transitions: null
                    }
                }

                function Fa(e, t, n) {
                    var r, i = t.pendingProps,
                        s = es.current,
                        a = !1,
                        l = 0 !== (128 & t.flags);
                    if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & s)), r ? (a = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (s |= 1), Pi(es, 1 & s), null === e) return uo(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, a ? (i = t.mode, a = t.child, l = {
                        mode: "hidden",
                        children: l
                    }, 0 === (1 & i) && null !== a ? (a.childLanes = 0, a.pendingProps = l) : a = Bu(l, i, 0, null), e = Lu(e, i, n, null), a.return = t, e.return = t, a.sibling = e, t.child = a, t.child.memoizedState = Ba(n), t.memoizedState = La, e) : ja(t, l));
                    if (null !== (s = e.memoizedState) && null !== (r = s.dehydrated)) return function(e, t, n, r, i, s, a) {
                        if (n) return 256 & t.flags ? (t.flags &= -257, Da(e, t, a, r = ca(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (s = r.fallback, i = t.mode, r = Bu({
                            mode: "visible",
                            children: r.children
                        }, i, 0, null), (s = Lu(s, i, a, null)).flags |= 2, r.return = t, s.return = t, r.sibling = s, t.child = r, 0 !== (1 & t.mode) && Eo(t, e.child, null, a), t.child.memoizedState = Ba(a), t.memoizedState = La, s);
                        if (0 === (1 & t.mode)) return Da(e, t, a, null);
                        if ("$!" === i.data) {
                            if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst;
                            return r = l, Da(e, t, a, r = ca(s = Error(o(419)), r, void 0))
                        }
                        if (l = 0 !== (a & e.childLanes), ba || l) {
                            if (null !== (r = Nl)) {
                                switch (a & -a) {
                                    case 4:
                                        i = 2;
                                        break;
                                    case 16:
                                        i = 8;
                                        break;
                                    case 64:
                                    case 128:
                                    case 256:
                                    case 512:
                                    case 1024:
                                    case 2048:
                                    case 4096:
                                    case 8192:
                                    case 16384:
                                    case 32768:
                                    case 65536:
                                    case 131072:
                                    case 262144:
                                    case 524288:
                                    case 1048576:
                                    case 2097152:
                                    case 4194304:
                                    case 8388608:
                                    case 16777216:
                                    case 33554432:
                                    case 67108864:
                                        i = 32;
                                        break;
                                    case 536870912:
                                        i = 268435456;
                                        break;
                                    default:
                                        i = 0
                                }
                                0 !== (i = 0 !== (i & (r.suspendedLanes | a)) ? 0 : i) && i !== s.retryLane && (s.retryLane = i, Lo(e, i), nu(r, e, i, -1))
                            }
                            return mu(), Da(e, t, a, r = ca(Error(o(421))))
                        }
                        return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Su.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, ro = ui(i.nextSibling), no = t, io = !0, oo = null, null !== e && (Vi[Ki++] = Ji, Vi[Ki++] = Zi, Vi[Ki++] = Wi, Ji = e.id, Zi = e.overflow, Wi = t), t = ja(t, r.children), t.flags |= 4096, t)
                    }(e, t, l, i, r, s, n);
                    if (a) {
                        a = i.fallback, l = t.mode, r = (s = e.child).sibling;
                        var u = {
                            mode: "hidden",
                            children: i.children
                        };
                        return 0 === (1 & l) && t.child !== s ? ((i = t.child).childLanes = 0, i.pendingProps = u, t.deletions = null) : (i = Tu(s, u)).subtreeFlags = 14680064 & s.subtreeFlags, null !== r ? a = Tu(r, a) : (a = Lu(a, l, n, null)).flags |= 2, a.return = t, i.return = t, i.sibling = a, t.child = i, i = a, a = t.child, l = null === (l = e.child.memoizedState) ? Ba(n) : {
                            baseLanes: l.baseLanes | n,
                            cachePool: null,
                            transitions: l.transitions
                        }, a.memoizedState = l, a.childLanes = e.childLanes & ~n, t.memoizedState = La, i
                    }
                    return e = (a = e.child).sibling, i = Tu(a, {
                        mode: "visible",
                        children: i.children
                    }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i
                }

                function ja(e, t) {
                    return (t = Bu({
                        mode: "visible",
                        children: t
                    }, e.mode, 0, null)).return = e, e.child = t
                }

                function Da(e, t, n, r) {
                    return null !== r && mo(r), Eo(t, e.child, null, n), (e = ja(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e
                }

                function Ua(e, t, n) {
                    e.lanes |= t;
                    var r = e.alternate;
                    null !== r && (r.lanes |= t), No(e.return, t, n)
                }

                function za(e, t, n, r, i) {
                    var o = e.memoizedState;
                    null === o ? e.memoizedState = {
                        isBackwards: t,
                        rendering: null,
                        renderingStartTime: 0,
                        last: r,
                        tail: n,
                        tailMode: i
                    } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i)
                }

                function qa(e, t, n) {
                    var r = t.pendingProps,
                        i = r.revealOrder,
                        o = r.tail;
                    if (wa(e, t, r.children, n), 0 !== (2 & (r = es.current))) r = 1 & r | 2, t.flags |= 128;
                    else {
                        if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) {
                            if (13 === e.tag) null !== e.memoizedState && Ua(e, n, t);
                            else if (19 === e.tag) Ua(e, n, t);
                            else if (null !== e.child) {
                                e.child.return = e, e = e.child;
                                continue
                            }
                            if (e === t) break e;
                            for (; null === e.sibling;) {
                                if (null === e.return || e.return === t) break e;
                                e = e.return
                            }
                            e.sibling.return = e.return, e = e.sibling
                        }
                        r &= 1
                    }
                    if (Pi(es, r), 0 === (1 & t.mode)) t.memoizedState = null;
                    else switch (i) {
                        case "forwards":
                            for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === ts(e) && (i = n), n = n.sibling;
                            null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), za(t, !1, i, n, o);
                            break;
                        case "backwards":
                            for (n = null, i = t.child, t.child = null; null !== i;) {
                                if (null !== (e = i.alternate) && null === ts(e)) {
                                    t.child = i;
                                    break
                                }
                                e = i.sibling, i.sibling = n, n = i, i = e
                            }
                            za(t, !0, n, null, o);
                            break;
                        case "together":
                            za(t, !1, null, null, void 0);
                            break;
                        default:
                            t.memoizedState = null
                    }
                    return t.child
                }

                function Ga(e, t) {
                    0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2)
                }

                function Ha(e, t, n) {
                    if (null !== e && (t.dependencies = e.dependencies), Bl |= t.lanes, 0 === (n & t.childLanes)) return null;
                    if (null !== e && t.child !== e.child) throw Error(o(153));
                    if (null !== t.child) {
                        for (n = Tu(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Tu(e, e.pendingProps)).return = t;
                        n.sibling = null
                    }
                    return t.child
                }

                function $a(e, t) {
                    if (!io) switch (e.tailMode) {
                        case "hidden":
                            t = e.tail;
                            for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
                            null === n ? e.tail = null : n.sibling = null;
                            break;
                        case "collapsed":
                            n = e.tail;
                            for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
                            null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                    }
                }

                function Qa(e) {
                    var t = null !== e.alternate && e.alternate.child === e.child,
                        n = 0,
                        r = 0;
                    if (t)
                        for (var i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling;
                    else
                        for (i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
                    return e.subtreeFlags |= r, e.childLanes = n, t
                }

                function Va(e, t, n) {
                    var r = t.pendingProps;
                    switch (to(t), t.tag) {
                        case 2:
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return Qa(t), null;
                        case 1:
                        case 17:
                            return Oi(t.type) && Ti(), Qa(t), null;
                        case 3:
                            return r = t.stateNode, Zo(), Ci(Ni), Ci(_i), rs(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (ho(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== oo && (su(oo), oo = null))), Oa(e, t), Qa(t), null;
                        case 5:
                            Xo(t);
                            var i = Wo(Ko.current);
                            if (n = t.type, null !== e && null != t.stateNode) Ta(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
                            else {
                                if (!r) {
                                    if (null === t.stateNode) throw Error(o(166));
                                    return Qa(t), null
                                }
                                if (e = Wo(Qo.current), ho(t)) {
                                    r = t.stateNode, n = t.type;
                                    var s = t.memoizedProps;
                                    switch (r[hi] = t, r[fi] = s, e = 0 !== (1 & t.mode), n) {
                                        case "dialog":
                                            Dr("cancel", r), Dr("close", r);
                                            break;
                                        case "iframe":
                                        case "object":
                                        case "embed":
                                            Dr("load", r);
                                            break;
                                        case "video":
                                        case "audio":
                                            for (i = 0; i < Lr.length; i++) Dr(Lr[i], r);
                                            break;
                                        case "source":
                                            Dr("error", r);
                                            break;
                                        case "img":
                                        case "image":
                                        case "link":
                                            Dr("error", r), Dr("load", r);
                                            break;
                                        case "details":
                                            Dr("toggle", r);
                                            break;
                                        case "input":
                                            J(r, s), Dr("invalid", r);
                                            break;
                                        case "select":
                                            r._wrapperState = {
                                                wasMultiple: !!s.multiple
                                            }, Dr("invalid", r);
                                            break;
                                        case "textarea":
                                            ie(r, s), Dr("invalid", r)
                                    }
                                    for (var l in ve(n, s), i = null, s)
                                        if (s.hasOwnProperty(l)) {
                                            var u = s[l];
                                            "children" === l ? "string" === typeof u ? r.textContent !== u && (!0 !== s.suppressHydrationWarning && Yr(r.textContent, u, e), i = ["children", u]) : "number" === typeof u && r.textContent !== "" + u && (!0 !== s.suppressHydrationWarning && Yr(r.textContent, u, e), i = ["children", "" + u]) : a.hasOwnProperty(l) && null != u && "onScroll" === l && Dr("scroll", r)
                                        }
                                    switch (n) {
                                        case "input":
                                            Q(r), X(r, s, !0);
                                            break;
                                        case "textarea":
                                            Q(r), se(r);
                                            break;
                                        case "select":
                                        case "option":
                                            break;
                                        default:
                                            "function" === typeof s.onClick && (r.onclick = Xr)
                                    }
                                    r = i, t.updateQueue = r, null !== r && (t.flags |= 4)
                                } else {
                                    l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = ae(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, {
                                        is: r.is
                                    }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[fi] = r, Ia(e, t, !1, !1), t.stateNode = e;
                                    e: {
                                        switch (l = be(n, r), n) {
                                            case "dialog":
                                                Dr("cancel", e), Dr("close", e), i = r;
                                                break;
                                            case "iframe":
                                            case "object":
                                            case "embed":
                                                Dr("load", e), i = r;
                                                break;
                                            case "video":
                                            case "audio":
                                                for (i = 0; i < Lr.length; i++) Dr(Lr[i], e);
                                                i = r;
                                                break;
                                            case "source":
                                                Dr("error", e), i = r;
                                                break;
                                            case "img":
                                            case "image":
                                            case "link":
                                                Dr("error", e), Dr("load", e), i = r;
                                                break;
                                            case "details":
                                                Dr("toggle", e), i = r;
                                                break;
                                            case "input":
                                                J(e, r), i = W(e, r), Dr("invalid", e);
                                                break;
                                            case "option":
                                            default:
                                                i = r;
                                                break;
                                            case "select":
                                                e._wrapperState = {
                                                    wasMultiple: !!r.multiple
                                                }, i = F({}, r, {
                                                    value: void 0
                                                }), Dr("invalid", e);
                                                break;
                                            case "textarea":
                                                ie(e, r), i = re(e, r), Dr("invalid", e)
                                        }
                                        for (s in ve(n, i), u = i)
                                            if (u.hasOwnProperty(s)) {
                                                var c = u[s];
                                                "style" === s ? ge(e, c) : "dangerouslySetInnerHTML" === s ? null != (c = c ? c.__html : void 0) && de(e, c) : "children" === s ? "string" === typeof c ? ("textarea" !== n || "" !== c) && he(e, c) : "number" === typeof c && he(e, "" + c) : "suppressContentEditableWarning" !== s && "suppressHydrationWarning" !== s && "autoFocus" !== s && (a.hasOwnProperty(s) ? null != c && "onScroll" === s && Dr("scroll", e) : null != c && b(e, s, c, l))
                                            }
                                        switch (n) {
                                            case "input":
                                                Q(e), X(e, r, !1);
                                                break;
                                            case "textarea":
                                                Q(e), se(e);
                                                break;
                                            case "option":
                                                null != r.value && e.setAttribute("value", "" + H(r.value));
                                                break;
                                            case "select":
                                                e.multiple = !!r.multiple, null != (s = r.value) ? ne(e, !!r.multiple, s, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0);
                                                break;
                                            default:
                                                "function" === typeof i.onClick && (e.onclick = Xr)
                                        }
                                        switch (n) {
                                            case "button":
                                            case "input":
                                            case "select":
                                            case "textarea":
                                                r = !!r.autoFocus;
                                                break e;
                                            case "img":
                                                r = !0;
                                                break e;
                                            default:
                                                r = !1
                                        }
                                    }
                                    r && (t.flags |= 4)
                                }
                                null !== t.ref && (t.flags |= 512, t.flags |= 2097152)
                            }
                            return Qa(t), null;
                        case 6:
                            if (e && null != t.stateNode) Ra(e, t, e.memoizedProps, r);
                            else {
                                if ("string" !== typeof r && null === t.stateNode) throw Error(o(166));
                                if (n = Wo(Ko.current), Wo(Qo.current), ho(t)) {
                                    if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (s = r.nodeValue !== n) && null !== (e = no)) switch (e.tag) {
                                        case 3:
                                            Yr(r.nodeValue, n, 0 !== (1 & e.mode));
                                            break;
                                        case 5:
                                            !0 !== e.memoizedProps.suppressHydrationWarning && Yr(r.nodeValue, n, 0 !== (1 & e.mode))
                                    }
                                    s && (t.flags |= 4)
                                } else(r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r
                            }
                            return Qa(t), null;
                        case 13:
                            if (Ci(es), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                                if (io && null !== ro && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) fo(), po(), t.flags |= 98560, s = !1;
                                else if (s = ho(t), null !== r && null !== r.dehydrated) {
                                    if (null === e) {
                                        if (!s) throw Error(o(318));
                                        if (!(s = null !== (s = t.memoizedState) ? s.dehydrated : null)) throw Error(o(317));
                                        s[hi] = t
                                    } else po(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                                    Qa(t), s = !1
                                } else null !== oo && (su(oo), oo = null), s = !0;
                                if (!s) return 65536 & t.flags ? t : null
                            }
                            return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & es.current) ? 0 === Rl && (Rl = 3) : mu())), null !== t.updateQueue && (t.flags |= 4), Qa(t), null);
                        case 4:
                            return Zo(), Oa(e, t), null === e && qr(t.stateNode.containerInfo), Qa(t), null;
                        case 10:
                            return _o(t.type._context), Qa(t), null;
                        case 19:
                            if (Ci(es), null === (s = t.memoizedState)) return Qa(t), null;
                            if (r = 0 !== (128 & t.flags), null === (l = s.rendering))
                                if (r) $a(s, !1);
                                else {
                                    if (0 !== Rl || null !== e && 0 !== (128 & e.flags))
                                        for (e = t.child; null !== e;) {
                                            if (null !== (l = ts(e))) {
                                                for (t.flags |= 128, $a(s, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;) e = r, (s = n).flags &= 14680066, null === (l = s.alternate) ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = l.childLanes, s.lanes = l.lanes, s.child = l.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = l.memoizedProps, s.memoizedState = l.memoizedState, s.updateQueue = l.updateQueue, s.type = l.type, e = l.dependencies, s.dependencies = null === e ? null : {
                                                    lanes: e.lanes,
                                                    firstContext: e.firstContext
                                                }), n = n.sibling;
                                                return Pi(es, 1 & es.current | 2), t.child
                                            }
                                            e = e.sibling
                                        }
                                    null !== s.tail && Ze() > ql && (t.flags |= 128, r = !0, $a(s, !1), t.lanes = 4194304)
                                }
                            else {
                                if (!r)
                                    if (null !== (e = ts(l))) {
                                        if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), $a(s, !0), null === s.tail && "hidden" === s.tailMode && !l.alternate && !io) return Qa(t), null
                                    } else 2 * Ze() - s.renderingStartTime > ql && 1073741824 !== n && (t.flags |= 128, r = !0, $a(s, !1), t.lanes = 4194304);
                                s.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = s.last) ? n.sibling = l : t.child = l, s.last = l)
                            }
                            return null !== s.tail ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = Ze(), t.sibling = null, n = es.current, Pi(es, r ? 1 & n | 2 : 1 & n), t) : (Qa(t), null);
                        case 22:
                        case 23:
                            return du(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Ol) && (Qa(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Qa(t), null;
                        case 24:
                        case 25:
                            return null
                    }
                    throw Error(o(156, t.tag))
                }

                function Ka(e, t) {
                    switch (to(t), t.tag) {
                        case 1:
                            return Oi(t.type) && Ti(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 3:
                            return Zo(), Ci(Ni), Ci(_i), rs(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null;
                        case 5:
                            return Xo(t), null;
                        case 13:
                            if (Ci(es), null !== (e = t.memoizedState) && null !== e.dehydrated) {
                                if (null === t.alternate) throw Error(o(340));
                                po()
                            }
                            return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 19:
                            return Ci(es), null;
                        case 4:
                            return Zo(), null;
                        case 10:
                            return _o(t.type._context), null;
                        case 22:
                        case 23:
                            return du(), null;
                        default:
                            return null
                    }
                }
                Ia = function(e, t) {
                    for (var n = t.child; null !== n;) {
                        if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
                        else if (4 !== n.tag && null !== n.child) {
                            n.child.return = n, n = n.child;
                            continue
                        }
                        if (n === t) break;
                        for (; null === n.sibling;) {
                            if (null === n.return || n.return === t) return;
                            n = n.return
                        }
                        n.sibling.return = n.return, n = n.sibling
                    }
                }, Oa = function() {}, Ta = function(e, t, n, r) {
                    var i = e.memoizedProps;
                    if (i !== r) {
                        e = t.stateNode, Wo(Qo.current);
                        var o, s = null;
                        switch (n) {
                            case "input":
                                i = W(e, i), r = W(e, r), s = [];
                                break;
                            case "select":
                                i = F({}, i, {
                                    value: void 0
                                }), r = F({}, r, {
                                    value: void 0
                                }), s = [];
                                break;
                            case "textarea":
                                i = re(e, i), r = re(e, r), s = [];
                                break;
                            default:
                                "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = Xr)
                        }
                        for (c in ve(n, r), n = null, i)
                            if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && null != i[c])
                                if ("style" === c) {
                                    var l = i[c];
                                    for (o in l) l.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
                                } else "dangerouslySetInnerHTML" !== c && "children" !== c && "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && "autoFocus" !== c && (a.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
                        for (c in r) {
                            var u = r[c];
                            if (l = null != i ? i[c] : void 0, r.hasOwnProperty(c) && u !== l && (null != u || null != l))
                                if ("style" === c)
                                    if (l) {
                                        for (o in l) !l.hasOwnProperty(o) || u && u.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                                        for (o in u) u.hasOwnProperty(o) && l[o] !== u[o] && (n || (n = {}), n[o] = u[o])
                                    } else n || (s || (s = []), s.push(c, n)), n = u;
                            else "dangerouslySetInnerHTML" === c ? (u = u ? u.__html : void 0, l = l ? l.__html : void 0, null != u && l !== u && (s = s || []).push(c, u)) : "children" === c ? "string" !== typeof u && "number" !== typeof u || (s = s || []).push(c, "" + u) : "suppressContentEditableWarning" !== c && "suppressHydrationWarning" !== c && (a.hasOwnProperty(c) ? (null != u && "onScroll" === c && Dr("scroll", e), s || l === u || (s = [])) : (s = s || []).push(c, u))
                        }
                        n && (s = s || []).push("style", n);
                        var c = s;
                        (t.updateQueue = c) && (t.flags |= 4)
                    }
                }, Ra = function(e, t, n, r) {
                    n !== r && (t.flags |= 4)
                };
                var Wa = !1,
                    Ja = !1,
                    Za = "function" === typeof WeakSet ? WeakSet : Set,
                    Ya = null;

                function Xa(e, t) {
                    var n = e.ref;
                    if (null !== n)
                        if ("function" === typeof n) try {
                            n(null)
                        } catch (r) {
                            ku(e, t, r)
                        } else n.current = null
                }

                function el(e, t, n) {
                    try {
                        n()
                    } catch (r) {
                        ku(e, t, r)
                    }
                }
                var tl = !1;

                function nl(e, t, n) {
                    var r = t.updateQueue;
                    if (null !== (r = null !== r ? r.lastEffect : null)) {
                        var i = r = r.next;
                        do {
                            if ((i.tag & e) === e) {
                                var o = i.destroy;
                                i.destroy = void 0, void 0 !== o && el(t, n, o)
                            }
                            i = i.next
                        } while (i !== r)
                    }
                }

                function rl(e, t) {
                    if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                        var n = t = t.next;
                        do {
                            if ((n.tag & e) === e) {
                                var r = n.create;
                                n.destroy = r()
                            }
                            n = n.next
                        } while (n !== t)
                    }
                }

                function il(e) {
                    var t = e.ref;
                    if (null !== t) {
                        var n = e.stateNode;
                        e.tag, e = n, "function" === typeof t ? t(e) : t.current = e
                    }
                }

                function ol(e) {
                    var t = e.alternate;
                    null !== t && (e.alternate = null, ol(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi], delete t[fi], delete t[mi], delete t[gi], delete t[yi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
                }

                function sl(e) {
                    return 5 === e.tag || 3 === e.tag || 4 === e.tag
                }

                function al(e) {
                    e: for (;;) {
                        for (; null === e.sibling;) {
                            if (null === e.return || sl(e.return)) return null;
                            e = e.return
                        }
                        for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
                            if (2 & e.flags) continue e;
                            if (null === e.child || 4 === e.tag) continue e;
                            e.child.return = e, e = e.child
                        }
                        if (!(2 & e.flags)) return e.stateNode
                    }
                }

                function ll(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = Xr));
                    else if (4 !== r && null !== (e = e.child))
                        for (ll(e, t, n), e = e.sibling; null !== e;) ll(e, t, n), e = e.sibling
                }

                function ul(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
                    else if (4 !== r && null !== (e = e.child))
                        for (ul(e, t, n), e = e.sibling; null !== e;) ul(e, t, n), e = e.sibling
                }
                var cl = null,
                    dl = !1;

                function hl(e, t, n) {
                    for (n = n.child; null !== n;) fl(e, t, n), n = n.sibling
                }

                function fl(e, t, n) {
                    if (ot && "function" === typeof ot.onCommitFiberUnmount) try {
                        ot.onCommitFiberUnmount(it, n)
                    } catch (a) {}
                    switch (n.tag) {
                        case 5:
                            Ja || Xa(n, t);
                        case 6:
                            var r = cl,
                                i = dl;
                            cl = null, hl(e, t, n), dl = i, null !== (cl = r) && (dl ? (e = cl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : cl.removeChild(n.stateNode));
                            break;
                        case 18:
                            null !== cl && (dl ? (e = cl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), qt(e)) : li(cl, n.stateNode));
                            break;
                        case 4:
                            r = cl, i = dl, cl = n.stateNode.containerInfo, dl = !0, hl(e, t, n), cl = r, dl = i;
                            break;
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (!Ja && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) {
                                i = r = r.next;
                                do {
                                    var o = i,
                                        s = o.destroy;
                                    o = o.tag, void 0 !== s && (0 !== (2 & o) || 0 !== (4 & o)) && el(n, t, s), i = i.next
                                } while (i !== r)
                            }
                            hl(e, t, n);
                            break;
                        case 1:
                            if (!Ja && (Xa(n, t), "function" === typeof(r = n.stateNode).componentWillUnmount)) try {
                                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
                            } catch (a) {
                                ku(n, t, a)
                            }
                            hl(e, t, n);
                            break;
                        case 21:
                            hl(e, t, n);
                            break;
                        case 22:
                            1 & n.mode ? (Ja = (r = Ja) || null !== n.memoizedState, hl(e, t, n), Ja = r) : hl(e, t, n);
                            break;
                        default:
                            hl(e, t, n)
                    }
                }

                function pl(e) {
                    var t = e.updateQueue;
                    if (null !== t) {
                        e.updateQueue = null;
                        var n = e.stateNode;
                        null === n && (n = e.stateNode = new Za), t.forEach((function(t) {
                            var r = _u.bind(null, e, t);
                            n.has(t) || (n.add(t), t.then(r, r))
                        }))
                    }
                }

                function ml(e, t) {
                    var n = t.deletions;
                    if (null !== n)
                        for (var r = 0; r < n.length; r++) {
                            var i = n[r];
                            try {
                                var s = e,
                                    a = t,
                                    l = a;
                                e: for (; null !== l;) {
                                    switch (l.tag) {
                                        case 5:
                                            cl = l.stateNode, dl = !1;
                                            break e;
                                        case 3:
                                        case 4:
                                            cl = l.stateNode.containerInfo, dl = !0;
                                            break e
                                    }
                                    l = l.return
                                }
                                if (null === cl) throw Error(o(160));
                                fl(s, a, i), cl = null, dl = !1;
                                var u = i.alternate;
                                null !== u && (u.return = null), i.return = null
                            } catch (c) {
                                ku(i, t, c)
                            }
                        }
                    if (12854 & t.subtreeFlags)
                        for (t = t.child; null !== t;) gl(t, e), t = t.sibling
                }

                function gl(e, t) {
                    var n = e.alternate,
                        r = e.flags;
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (ml(t, e), yl(e), 4 & r) {
                                try {
                                    nl(3, e, e.return), rl(3, e)
                                } catch (g) {
                                    ku(e, e.return, g)
                                }
                                try {
                                    nl(5, e, e.return)
                                } catch (g) {
                                    ku(e, e.return, g)
                                }
                            }
                            break;
                        case 1:
                            ml(t, e), yl(e), 512 & r && null !== n && Xa(n, n.return);
                            break;
                        case 5:
                            if (ml(t, e), yl(e), 512 & r && null !== n && Xa(n, n.return), 32 & e.flags) {
                                var i = e.stateNode;
                                try {
                                    he(i, "")
                                } catch (g) {
                                    ku(e, e.return, g)
                                }
                            }
                            if (4 & r && null != (i = e.stateNode)) {
                                var s = e.memoizedProps,
                                    a = null !== n ? n.memoizedProps : s,
                                    l = e.type,
                                    u = e.updateQueue;
                                if (e.updateQueue = null, null !== u) try {
                                    "input" === l && "radio" === s.type && null != s.name && Z(i, s), be(l, a);
                                    var c = be(l, s);
                                    for (a = 0; a < u.length; a += 2) {
                                        var d = u[a],
                                            h = u[a + 1];
                                        "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : b(i, d, h, c)
                                    }
                                    switch (l) {
                                        case "input":
                                            Y(i, s);
                                            break;
                                        case "textarea":
                                            oe(i, s);
                                            break;
                                        case "select":
                                            var f = i._wrapperState.wasMultiple;
                                            i._wrapperState.wasMultiple = !!s.multiple;
                                            var p = s.value;
                                            null != p ? ne(i, !!s.multiple, p, !1) : f !== !!s.multiple && (null != s.defaultValue ? ne(i, !!s.multiple, s.defaultValue, !0) : ne(i, !!s.multiple, s.multiple ? [] : "", !1))
                                    }
                                    i[fi] = s
                                } catch (g) {
                                    ku(e, e.return, g)
                                }
                            }
                            break;
                        case 6:
                            if (ml(t, e), yl(e), 4 & r) {
                                if (null === e.stateNode) throw Error(o(162));
                                i = e.stateNode, s = e.memoizedProps;
                                try {
                                    i.nodeValue = s
                                } catch (g) {
                                    ku(e, e.return, g)
                                }
                            }
                            break;
                        case 3:
                            if (ml(t, e), yl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try {
                                qt(t.containerInfo)
                            } catch (g) {
                                ku(e, e.return, g)
                            }
                            break;
                        case 4:
                        default:
                            ml(t, e), yl(e);
                            break;
                        case 13:
                            ml(t, e), yl(e), 8192 & (i = e.child).flags && (s = null !== i.memoizedState, i.stateNode.isHidden = s, !s || null !== i.alternate && null !== i.alternate.memoizedState || (zl = Ze())), 4 & r && pl(e);
                            break;
                        case 22:
                            if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Ja = (c = Ja) || d, ml(t, e), Ja = c) : ml(t, e), yl(e), 8192 & r) {
                                if (c = null !== e.memoizedState, (e.stateNode.isHidden = c) && !d && 0 !== (1 & e.mode))
                                    for (Ya = e, d = e.child; null !== d;) {
                                        for (h = Ya = d; null !== Ya;) {
                                            switch (p = (f = Ya).child, f.tag) {
                                                case 0:
                                                case 11:
                                                case 14:
                                                case 15:
                                                    nl(4, f, f.return);
                                                    break;
                                                case 1:
                                                    Xa(f, f.return);
                                                    var m = f.stateNode;
                                                    if ("function" === typeof m.componentWillUnmount) {
                                                        r = f, n = f.return;
                                                        try {
                                                            t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount()
                                                        } catch (g) {
                                                            ku(r, n, g)
                                                        }
                                                    }
                                                    break;
                                                case 5:
                                                    Xa(f, f.return);
                                                    break;
                                                case 22:
                                                    if (null !== f.memoizedState) {
                                                        El(h);
                                                        continue
                                                    }
                                            }
                                            null !== p ? (p.return = f, Ya = p) : El(h)
                                        }
                                        d = d.sibling
                                    }
                                e: for (d = null, h = e;;) {
                                    if (5 === h.tag) {
                                        if (null === d) {
                                            d = h;
                                            try {
                                                i = h.stateNode, c ? "function" === typeof(s = i.style).setProperty ? s.setProperty("display", "none", "important") : s.display = "none" : (l = h.stateNode, a = void 0 !== (u = h.memoizedProps.style) && null !== u && u.hasOwnProperty("display") ? u.display : null, l.style.display = me("display", a))
                                            } catch (g) {
                                                ku(e, e.return, g)
                                            }
                                        }
                                    } else if (6 === h.tag) {
                                        if (null === d) try {
                                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                                        } catch (g) {
                                            ku(e, e.return, g)
                                        }
                                    } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) {
                                        h.child.return = h, h = h.child;
                                        continue
                                    }
                                    if (h === e) break e;
                                    for (; null === h.sibling;) {
                                        if (null === h.return || h.return === e) break e;
                                        d === h && (d = null), h = h.return
                                    }
                                    d === h && (d = null), h.sibling.return = h.return, h = h.sibling
                                }
                            }
                            break;
                        case 19:
                            ml(t, e), yl(e), 4 & r && pl(e);
                        case 21:
                    }
                }

                function yl(e) {
                    var t = e.flags;
                    if (2 & t) {
                        try {
                            e: {
                                for (var n = e.return; null !== n;) {
                                    if (sl(n)) {
                                        var r = n;
                                        break e
                                    }
                                    n = n.return
                                }
                                throw Error(o(160))
                            }
                            switch (r.tag) {
                                case 5:
                                    var i = r.stateNode;
                                    32 & r.flags && (he(i, ""), r.flags &= -33), ul(e, al(e), i);
                                    break;
                                case 3:
                                case 4:
                                    var s = r.stateNode.containerInfo;
                                    ll(e, al(e), s);
                                    break;
                                default:
                                    throw Error(o(161))
                            }
                        }
                        catch (a) {
                            ku(e, e.return, a)
                        }
                        e.flags &= -3
                    }
                    4096 & t && (e.flags &= -4097)
                }

                function vl(e, t, n) {
                    Ya = e, bl(e, t, n)
                }

                function bl(e, t, n) {
                    for (var r = 0 !== (1 & e.mode); null !== Ya;) {
                        var i = Ya,
                            o = i.child;
                        if (22 === i.tag && r) {
                            var s = null !== i.memoizedState || Wa;
                            if (!s) {
                                var a = i.alternate,
                                    l = null !== a && null !== a.memoizedState || Ja;
                                a = Wa;
                                var u = Ja;
                                if (Wa = s, (Ja = l) && !u)
                                    for (Ya = i; null !== Ya;) l = (s = Ya).child, 22 === s.tag && null !== s.memoizedState ? xl(i) : null !== l ? (l.return = s, Ya = l) : xl(i);
                                for (; null !== o;) Ya = o, bl(o, t, n), o = o.sibling;
                                Ya = i, Wa = a, Ja = u
                            }
                            wl(e)
                        } else 0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i, Ya = o) : wl(e)
                    }
                }

                function wl(e) {
                    for (; null !== Ya;) {
                        var t = Ya;
                        if (0 !== (8772 & t.flags)) {
                            var n = t.alternate;
                            try {
                                if (0 !== (8772 & t.flags)) switch (t.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ja || rl(5, t);
                                        break;
                                    case 1:
                                        var r = t.stateNode;
                                        if (4 & t.flags && !Ja)
                                            if (null === n) r.componentDidMount();
                                            else {
                                                var i = t.elementType === t.type ? n.memoizedProps : na(t.type, n.memoizedProps);
                                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                            }
                                        var s = t.updateQueue;
                                        null !== s && Ho(t, s, r);
                                        break;
                                    case 3:
                                        var a = t.updateQueue;
                                        if (null !== a) {
                                            if (n = null, null !== t.child) switch (t.child.tag) {
                                                case 5:
                                                case 1:
                                                    n = t.child.stateNode
                                            }
                                            Ho(t, a, n)
                                        }
                                        break;
                                    case 5:
                                        var l = t.stateNode;
                                        if (null === n && 4 & t.flags) {
                                            n = l;
                                            var u = t.memoizedProps;
                                            switch (t.type) {
                                                case "button":
                                                case "input":
                                                case "select":
                                                case "textarea":
                                                    u.autoFocus && n.focus();
                                                    break;
                                                case "img":
                                                    u.src && (n.src = u.src)
                                            }
                                        }
                                        break;
                                    case 6:
                                    case 4:
                                    case 12:
                                    case 19:
                                    case 17:
                                    case 21:
                                    case 22:
                                    case 23:
                                    case 25:
                                        break;
                                    case 13:
                                        if (null === t.memoizedState) {
                                            var c = t.alternate;
                                            if (null !== c) {
                                                var d = c.memoizedState;
                                                if (null !== d) {
                                                    var h = d.dehydrated;
                                                    null !== h && qt(h)
                                                }
                                            }
                                        }
                                        break;
                                    default:
                                        throw Error(o(163))
                                }
                                Ja || 512 & t.flags && il(t)
                            } catch (f) {
                                ku(t, t.return, f)
                            }
                        }
                        if (t === e) {
                            Ya = null;
                            break
                        }
                        if (null !== (n = t.sibling)) {
                            n.return = t.return, Ya = n;
                            break
                        }
                        Ya = t.return
                    }
                }

                function El(e) {
                    for (; null !== Ya;) {
                        var t = Ya;
                        if (t === e) {
                            Ya = null;
                            break
                        }
                        var n = t.sibling;
                        if (null !== n) {
                            n.return = t.return, Ya = n;
                            break
                        }
                        Ya = t.return
                    }
                }

                function xl(e) {
                    for (; null !== Ya;) {
                        var t = Ya;
                        try {
                            switch (t.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    var n = t.return;
                                    try {
                                        rl(4, t)
                                    } catch (l) {
                                        ku(t, n, l)
                                    }
                                    break;
                                case 1:
                                    var r = t.stateNode;
                                    if ("function" === typeof r.componentDidMount) {
                                        var i = t.return;
                                        try {
                                            r.componentDidMount()
                                        } catch (l) {
                                            ku(t, i, l)
                                        }
                                    }
                                    var o = t.return;
                                    try {
                                        il(t)
                                    } catch (l) {
                                        ku(t, o, l)
                                    }
                                    break;
                                case 5:
                                    var s = t.return;
                                    try {
                                        il(t)
                                    } catch (l) {
                                        ku(t, s, l)
                                    }
                            }
                        } catch (l) {
                            ku(t, t.return, l)
                        }
                        if (t === e) {
                            Ya = null;
                            break
                        }
                        var a = t.sibling;
                        if (null !== a) {
                            a.return = t.return, Ya = a;
                            break
                        }
                        Ya = t.return
                    }
                }
                var Al, kl = Math.ceil,
                    Cl = w.ReactCurrentDispatcher,
                    Pl = w.ReactCurrentOwner,
                    Sl = w.ReactCurrentBatchConfig,
                    _l = 0,
                    Nl = null,
                    Ml = null,
                    Il = 0,
                    Ol = 0,
                    Tl = ki(0),
                    Rl = 0,
                    Ll = null,
                    Bl = 0,
                    Fl = 0,
                    jl = 0,
                    Dl = null,
                    Ul = null,
                    zl = 0,
                    ql = 1 / 0,
                    Gl = null,
                    Hl = !1,
                    $l = null,
                    Ql = null,
                    Vl = !1,
                    Kl = null,
                    Wl = 0,
                    Jl = 0,
                    Zl = null,
                    Yl = -1,
                    Xl = 0;

                function eu() {
                    return 0 !== (6 & _l) ? Ze() : -1 !== Yl ? Yl : Yl = Ze()
                }

                function tu(e) {
                    return 0 === (1 & e.mode) ? 1 : 0 !== (2 & _l) && 0 !== Il ? Il & -Il : null !== go.transition ? (0 === Xl && (Xl = mt()), Xl) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Jt(e.type)
                }

                function nu(e, t, n, r) {
                    if (50 < Jl) throw Jl = 0, Zl = null, Error(o(185));
                    yt(e, n, r), 0 !== (2 & _l) && e === Nl || (e === Nl && (0 === (2 & _l) && (Fl |= n), 4 === Rl && au(e, Il)), ru(e, r), 1 === n && 0 === _l && 0 === (1 & t.mode) && (ql = Ze() + 500, Di && qi()))
                }

                function ru(e, t) {
                    var n = e.callbackNode;
                    ! function(e, t) {
                        for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) {
                            var s = 31 - st(o),
                                a = 1 << s,
                                l = i[s]; - 1 === l ? 0 !== (a & n) && 0 === (a & r) || (i[s] = ft(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a
                        }
                    }(e, t);
                    var r = ht(e, e === Nl ? Il : 0);
                    if (0 === r) null !== n && Ke(n), e.callbackNode = null, e.callbackPriority = 0;
                    else if (t = r & -r, e.callbackPriority !== t) {
                        if (null != n && Ke(n), 1 === t) 0 === e.tag ? function(e) {
                            Di = !0, zi(e)
                        }(lu.bind(null, e)) : zi(lu.bind(null, e)), si((function() {
                            0 === (6 & _l) && qi()
                        })), n = null;
                        else {
                            switch (wt(r)) {
                                case 1:
                                    n = Xe;
                                    break;
                                case 4:
                                    n = et;
                                    break;
                                case 16:
                                default:
                                    n = tt;
                                    break;
                                case 536870912:
                                    n = rt
                            }
                            n = Nu(n, iu.bind(null, e))
                        }
                        e.callbackPriority = t, e.callbackNode = n
                    }
                }

                function iu(e, t) {
                    if (Yl = -1, Xl = 0, 0 !== (6 & _l)) throw Error(o(327));
                    var n = e.callbackNode;
                    if (xu() && e.callbackNode !== n) return null;
                    var r = ht(e, e === Nl ? Il : 0);
                    if (0 === r) return null;
                    if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = gu(e, r);
                    else {
                        t = r;
                        var i = _l;
                        _l |= 2;
                        var s = pu();
                        for (Nl === e && Il === t || (Gl = null, ql = Ze() + 500, hu(e, t));;) try {
                            vu();
                            break
                        } catch (l) {
                            fu(e, l)
                        }
                        So(), Cl.current = s, _l = i, null !== Ml ? t = 0 : (Nl = null, Il = 0, t = Rl)
                    }
                    if (0 !== t) {
                        if (2 === t && (0 !== (i = pt(e)) && (r = i, t = ou(e, i))), 1 === t) throw n = Ll, hu(e, 0), au(e, r), ru(e, Ze()), n;
                        if (6 === t) au(e, r);
                        else {
                            if (i = e.current.alternate, 0 === (30 & r) && ! function(e) {
                                    for (var t = e;;) {
                                        if (16384 & t.flags) {
                                            var n = t.updateQueue;
                                            if (null !== n && null !== (n = n.stores))
                                                for (var r = 0; r < n.length; r++) {
                                                    var i = n[r],
                                                        o = i.getSnapshot;
                                                    i = i.value;
                                                    try {
                                                        if (!ar(o(), i)) return !1
                                                    } catch (a) {
                                                        return !1
                                                    }
                                                }
                                        }
                                        if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n;
                                        else {
                                            if (t === e) break;
                                            for (; null === t.sibling;) {
                                                if (null === t.return || t.return === e) return !0;
                                                t = t.return
                                            }
                                            t.sibling.return = t.return, t = t.sibling
                                        }
                                    }
                                    return !0
                                }(i) && (2 === (t = gu(e, r)) && (0 !== (s = pt(e)) && (r = s, t = ou(e, s))), 1 === t)) throw n = Ll, hu(e, 0), au(e, r), ru(e, Ze()), n;
                            switch (e.finishedWork = i, e.finishedLanes = r, t) {
                                case 0:
                                case 1:
                                    throw Error(o(345));
                                case 2:
                                case 5:
                                    Eu(e, Ul, Gl);
                                    break;
                                case 3:
                                    if (au(e, r), (130023424 & r) === r && 10 < (t = zl + 500 - Ze())) {
                                        if (0 !== ht(e, 0)) break;
                                        if (((i = e.suspendedLanes) & r) !== r) {
                                            eu(), e.pingedLanes |= e.suspendedLanes & i;
                                            break
                                        }
                                        e.timeoutHandle = ri(Eu.bind(null, e, Ul, Gl), t);
                                        break
                                    }
                                    Eu(e, Ul, Gl);
                                    break;
                                case 4:
                                    if (au(e, r), (4194240 & r) === r) break;
                                    for (t = e.eventTimes, i = -1; 0 < r;) {
                                        var a = 31 - st(r);
                                        s = 1 << a, (a = t[a]) > i && (i = a), r &= ~s
                                    }
                                    if (r = i, 10 < (r = (120 > (r = Ze() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * kl(r / 1960)) - r)) {
                                        e.timeoutHandle = ri(Eu.bind(null, e, Ul, Gl), r);
                                        break
                                    }
                                    Eu(e, Ul, Gl);
                                    break;
                                default:
                                    throw Error(o(329))
                            }
                        }
                    }
                    return ru(e, Ze()), e.callbackNode === n ? iu.bind(null, e) : null
                }

                function ou(e, t) {
                    var n = Dl;
                    return e.current.memoizedState.isDehydrated && (hu(e, t).flags |= 256), 2 !== (e = gu(e, t)) && (t = Ul, Ul = n, null !== t && su(t)), e
                }

                function su(e) {
                    null === Ul ? Ul = e : Ul.push.apply(Ul, e)
                }

                function au(e, t) {
                    for (t &= ~jl, t &= ~Fl, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
                        var n = 31 - st(t),
                            r = 1 << n;
                        e[n] = -1, t &= ~r
                    }
                }

                function lu(e) {
                    if (0 !== (6 & _l)) throw Error(o(327));
                    xu();
                    var t = ht(e, 0);
                    if (0 === (1 & t)) return ru(e, Ze()), null;
                    var n = gu(e, t);
                    if (0 !== e.tag && 2 === n) {
                        var r = pt(e);
                        0 !== r && (t = r, n = ou(e, r))
                    }
                    if (1 === n) throw n = Ll, hu(e, 0), au(e, t), ru(e, Ze()), n;
                    if (6 === n) throw Error(o(345));
                    return e.finishedWork = e.current.alternate, e.finishedLanes = t, Eu(e, Ul, Gl), ru(e, Ze()), null
                }

                function uu(e, t) {
                    var n = _l;
                    _l |= 1;
                    try {
                        return e(t)
                    } finally {
                        0 === (_l = n) && (ql = Ze() + 500, Di && qi())
                    }
                }

                function cu(e) {
                    null !== Kl && 0 === Kl.tag && 0 === (6 & _l) && xu();
                    var t = _l;
                    _l |= 1;
                    var n = Sl.transition,
                        r = bt;
                    try {
                        if (Sl.transition = null, bt = 1, e) return e()
                    } finally {
                        bt = r, Sl.transition = n, 0 === (6 & (_l = t)) && qi()
                    }
                }

                function du() {
                    Ol = Tl.current, Ci(Tl)
                }

                function hu(e, t) {
                    e.finishedWork = null, e.finishedLanes = 0;
                    var n = e.timeoutHandle;
                    if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Ml)
                        for (n = Ml.return; null !== n;) {
                            var r = n;
                            switch (to(r), r.tag) {
                                case 1:
                                    null !== (r = r.type.childContextTypes) && void 0 !== r && Ti();
                                    break;
                                case 3:
                                    Zo(), Ci(Ni), Ci(_i), rs();
                                    break;
                                case 5:
                                    Xo(r);
                                    break;
                                case 4:
                                    Zo();
                                    break;
                                case 13:
                                case 19:
                                    Ci(es);
                                    break;
                                case 10:
                                    _o(r.type._context);
                                    break;
                                case 22:
                                case 23:
                                    du()
                            }
                            n = n.return
                        }
                    if (Nl = e, Ml = e = Tu(e.current, null), Il = Ol = t, Rl = 0, Ll = null, jl = Fl = Bl = 0, Ul = Dl = null, null !== Oo) {
                        for (t = 0; t < Oo.length; t++)
                            if (null !== (r = (n = Oo[t]).interleaved)) {
                                n.interleaved = null;
                                var i = r.next,
                                    o = n.pending;
                                if (null !== o) {
                                    var s = o.next;
                                    o.next = i, r.next = s
                                }
                                n.pending = r
                            }
                        Oo = null
                    }
                    return e
                }

                function fu(e, t) {
                    for (;;) {
                        var n = Ml;
                        try {
                            if (So(), is.current = Ys, cs) {
                                for (var r = as.memoizedState; null !== r;) {
                                    var i = r.queue;
                                    null !== i && (i.pending = null), r = r.next
                                }
                                cs = !1
                            }
                            if (ss = 0, us = ls = as = null, ds = !1, hs = 0, Pl.current = null, null === n || null === n.return) {
                                Rl = 1, Ll = t, Ml = null;
                                break
                            }
                            e: {
                                var s = e,
                                    a = n.return,
                                    l = n,
                                    u = t;
                                if (t = Il, l.flags |= 32768, null !== u && "object" === typeof u && "function" === typeof u.then) {
                                    var c = u,
                                        d = l,
                                        h = d.tag;
                                    if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) {
                                        var f = d.alternate;
                                        f ? (d.updateQueue = f.updateQueue, d.memoizedState = f.memoizedState, d.lanes = f.lanes) : (d.updateQueue = null, d.memoizedState = null)
                                    }
                                    var p = ga(a);
                                    if (null !== p) {
                                        p.flags &= -257, ya(p, a, l, 0, t), 1 & p.mode && ma(s, c, t), u = c;
                                        var m = (t = p).updateQueue;
                                        if (null === m) {
                                            var g = new Set;
                                            g.add(u), t.updateQueue = g
                                        } else m.add(u);
                                        break e
                                    }
                                    if (0 === (1 & t)) {
                                        ma(s, c, t), mu();
                                        break e
                                    }
                                    u = Error(o(426))
                                } else if (io && 1 & l.mode) {
                                    var y = ga(a);
                                    if (null !== y) {
                                        0 === (65536 & y.flags) && (y.flags |= 256), ya(y, a, l, 0, t), mo(ua(u, l));
                                        break e
                                    }
                                }
                                s = u = ua(u, l),
                                4 !== Rl && (Rl = 2),
                                null === Dl ? Dl = [s] : Dl.push(s),
                                s = a;do {
                                    switch (s.tag) {
                                        case 3:
                                            s.flags |= 65536, t &= -t, s.lanes |= t, qo(s, fa(0, u, t));
                                            break e;
                                        case 1:
                                            l = u;
                                            var v = s.type,
                                                b = s.stateNode;
                                            if (0 === (128 & s.flags) && ("function" === typeof v.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Ql || !Ql.has(b)))) {
                                                s.flags |= 65536, t &= -t, s.lanes |= t, qo(s, pa(s, l, t));
                                                break e
                                            }
                                    }
                                    s = s.return
                                } while (null !== s)
                            }
                            wu(n)
                        } catch (w) {
                            t = w, Ml === n && null !== n && (Ml = n = n.return);
                            continue
                        }
                        break
                    }
                }

                function pu() {
                    var e = Cl.current;
                    return Cl.current = Ys, null === e ? Ys : e
                }

                function mu() {
                    0 !== Rl && 3 !== Rl && 2 !== Rl || (Rl = 4), null === Nl || 0 === (268435455 & Bl) && 0 === (268435455 & Fl) || au(Nl, Il)
                }

                function gu(e, t) {
                    var n = _l;
                    _l |= 2;
                    var r = pu();
                    for (Nl === e && Il === t || (Gl = null, hu(e, t));;) try {
                        yu();
                        break
                    } catch (i) {
                        fu(e, i)
                    }
                    if (So(), _l = n, Cl.current = r, null !== Ml) throw Error(o(261));
                    return Nl = null, Il = 0, Rl
                }

                function yu() {
                    for (; null !== Ml;) bu(Ml)
                }

                function vu() {
                    for (; null !== Ml && !We();) bu(Ml)
                }

                function bu(e) {
                    var t = Al(e.alternate, e, Ol);
                    e.memoizedProps = e.pendingProps, null === t ? wu(e) : Ml = t, Pl.current = null
                }

                function wu(e) {
                    var t = e;
                    do {
                        var n = t.alternate;
                        if (e = t.return, 0 === (32768 & t.flags)) {
                            if (null !== (n = Va(n, t, Ol))) return void(Ml = n)
                        } else {
                            if (null !== (n = Ka(n, t))) return n.flags &= 32767, void(Ml = n);
                            if (null === e) return Rl = 6, void(Ml = null);
                            e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null
                        }
                        if (null !== (t = t.sibling)) return void(Ml = t);
                        Ml = t = e
                    } while (null !== t);
                    0 === Rl && (Rl = 5)
                }

                function Eu(e, t, n) {
                    var r = bt,
                        i = Sl.transition;
                    try {
                        Sl.transition = null, bt = 1,
                            function(e, t, n, r) {
                                do {
                                    xu()
                                } while (null !== Kl);
                                if (0 !== (6 & _l)) throw Error(o(327));
                                n = e.finishedWork;
                                var i = e.finishedLanes;
                                if (null === n) return null;
                                if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177));
                                e.callbackNode = null, e.callbackPriority = 0;
                                var s = n.lanes | n.childLanes;
                                if (function(e, t) {
                                        var n = e.pendingLanes & ~t;
                                        e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
                                        var r = e.eventTimes;
                                        for (e = e.expirationTimes; 0 < n;) {
                                            var i = 31 - st(n),
                                                o = 1 << i;
                                            t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o
                                        }
                                    }(e, s), e === Nl && (Ml = Nl = null, Il = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Vl || (Vl = !0, Nu(tt, (function() {
                                        return xu(), null
                                    }))), s = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || s) {
                                    s = Sl.transition, Sl.transition = null;
                                    var a = bt;
                                    bt = 1;
                                    var l = _l;
                                    _l |= 4, Pl.current = null,
                                        function(e, t) {
                                            if (ei = Ht, fr(e = hr())) {
                                                if ("selectionStart" in e) var n = {
                                                    start: e.selectionStart,
                                                    end: e.selectionEnd
                                                };
                                                else e: {
                                                    var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                                    if (r && 0 !== r.rangeCount) {
                                                        n = r.anchorNode;
                                                        var i = r.anchorOffset,
                                                            s = r.focusNode;
                                                        r = r.focusOffset;
                                                        try {
                                                            n.nodeType, s.nodeType
                                                        } catch (E) {
                                                            n = null;
                                                            break e
                                                        }
                                                        var a = 0,
                                                            l = -1,
                                                            u = -1,
                                                            c = 0,
                                                            d = 0,
                                                            h = e,
                                                            f = null;
                                                        t: for (;;) {
                                                            for (var p; h !== n || 0 !== i && 3 !== h.nodeType || (l = a + i), h !== s || 0 !== r && 3 !== h.nodeType || (u = a + r), 3 === h.nodeType && (a += h.nodeValue.length), null !== (p = h.firstChild);) f = h, h = p;
                                                            for (;;) {
                                                                if (h === e) break t;
                                                                if (f === n && ++c === i && (l = a), f === s && ++d === r && (u = a), null !== (p = h.nextSibling)) break;
                                                                f = (h = f).parentNode
                                                            }
                                                            h = p
                                                        }
                                                        n = -1 === l || -1 === u ? null : {
                                                            start: l,
                                                            end: u
                                                        }
                                                    } else n = null
                                                }
                                                n = n || {
                                                    start: 0,
                                                    end: 0
                                                }
                                            } else n = null;
                                            for (ti = {
                                                    focusedElem: e,
                                                    selectionRange: n
                                                }, Ht = !1, Ya = t; null !== Ya;)
                                                if (e = (t = Ya).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, Ya = e;
                                                else
                                                    for (; null !== Ya;) {
                                                        t = Ya;
                                                        try {
                                                            var m = t.alternate;
                                                            if (0 !== (1024 & t.flags)) switch (t.tag) {
                                                                case 0:
                                                                case 11:
                                                                case 15:
                                                                case 5:
                                                                case 6:
                                                                case 4:
                                                                case 17:
                                                                    break;
                                                                case 1:
                                                                    if (null !== m) {
                                                                        var g = m.memoizedProps,
                                                                            y = m.memoizedState,
                                                                            v = t.stateNode,
                                                                            b = v.getSnapshotBeforeUpdate(t.elementType === t.type ? g : na(t.type, g), y);
                                                                        v.__reactInternalSnapshotBeforeUpdate = b
                                                                    }
                                                                    break;
                                                                case 3:
                                                                    var w = t.stateNode.containerInfo;
                                                                    1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement);
                                                                    break;
                                                                default:
                                                                    throw Error(o(163))
                                                            }
                                                        } catch (E) {
                                                            ku(t, t.return, E)
                                                        }
                                                        if (null !== (e = t.sibling)) {
                                                            e.return = t.return, Ya = e;
                                                            break
                                                        }
                                                        Ya = t.return
                                                    }
                                            m = tl, tl = !1
                                        }(e, n), gl(n, e), pr(ti), Ht = !!ei, ti = ei = null, e.current = n, vl(n, e, i), Je(), _l = l, bt = a, Sl.transition = s
                                } else e.current = n;
                                if (Vl && (Vl = !1, Kl = e, Wl = i), s = e.pendingLanes, 0 === s && (Ql = null), function(e) {
                                        if (ot && "function" === typeof ot.onCommitFiberRoot) try {
                                            ot.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags))
                                        } catch (t) {}
                                    }(n.stateNode), ru(e, Ze()), null !== t)
                                    for (r = e.onRecoverableError, n = 0; n < t.length; n++) i = t[n], r(i.value, {
                                        componentStack: i.stack,
                                        digest: i.digest
                                    });
                                if (Hl) throw Hl = !1, e = $l, $l = null, e;
                                0 !== (1 & Wl) && 0 !== e.tag && xu(), s = e.pendingLanes, 0 !== (1 & s) ? e === Zl ? Jl++ : (Jl = 0, Zl = e) : Jl = 0, qi()
                            }(e, t, n, r)
                    } finally {
                        Sl.transition = i, bt = r
                    }
                    return null
                }

                function xu() {
                    if (null !== Kl) {
                        var e = wt(Wl),
                            t = Sl.transition,
                            n = bt;
                        try {
                            if (Sl.transition = null, bt = 16 > e ? 16 : e, null === Kl) var r = !1;
                            else {
                                if (e = Kl, Kl = null, Wl = 0, 0 !== (6 & _l)) throw Error(o(331));
                                var i = _l;
                                for (_l |= 4, Ya = e.current; null !== Ya;) {
                                    var s = Ya,
                                        a = s.child;
                                    if (0 !== (16 & Ya.flags)) {
                                        var l = s.deletions;
                                        if (null !== l) {
                                            for (var u = 0; u < l.length; u++) {
                                                var c = l[u];
                                                for (Ya = c; null !== Ya;) {
                                                    var d = Ya;
                                                    switch (d.tag) {
                                                        case 0:
                                                        case 11:
                                                        case 15:
                                                            nl(8, d, s)
                                                    }
                                                    var h = d.child;
                                                    if (null !== h) h.return = d, Ya = h;
                                                    else
                                                        for (; null !== Ya;) {
                                                            var f = (d = Ya).sibling,
                                                                p = d.return;
                                                            if (ol(d), d === c) {
                                                                Ya = null;
                                                                break
                                                            }
                                                            if (null !== f) {
                                                                f.return = p, Ya = f;
                                                                break
                                                            }
                                                            Ya = p
                                                        }
                                                }
                                            }
                                            var m = s.alternate;
                                            if (null !== m) {
                                                var g = m.child;
                                                if (null !== g) {
                                                    m.child = null;
                                                    do {
                                                        var y = g.sibling;
                                                        g.sibling = null, g = y
                                                    } while (null !== g)
                                                }
                                            }
                                            Ya = s
                                        }
                                    }
                                    if (0 !== (2064 & s.subtreeFlags) && null !== a) a.return = s, Ya = a;
                                    else e: for (; null !== Ya;) {
                                        if (0 !== (2048 & (s = Ya).flags)) switch (s.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                nl(9, s, s.return)
                                        }
                                        var v = s.sibling;
                                        if (null !== v) {
                                            v.return = s.return, Ya = v;
                                            break e
                                        }
                                        Ya = s.return
                                    }
                                }
                                var b = e.current;
                                for (Ya = b; null !== Ya;) {
                                    var w = (a = Ya).child;
                                    if (0 !== (2064 & a.subtreeFlags) && null !== w) w.return = a, Ya = w;
                                    else e: for (a = b; null !== Ya;) {
                                        if (0 !== (2048 & (l = Ya).flags)) try {
                                            switch (l.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    rl(9, l)
                                            }
                                        } catch (x) {
                                            ku(l, l.return, x)
                                        }
                                        if (l === a) {
                                            Ya = null;
                                            break e
                                        }
                                        var E = l.sibling;
                                        if (null !== E) {
                                            E.return = l.return, Ya = E;
                                            break e
                                        }
                                        Ya = l.return
                                    }
                                }
                                if (_l = i, qi(), ot && "function" === typeof ot.onPostCommitFiberRoot) try {
                                    ot.onPostCommitFiberRoot(it, e)
                                } catch (x) {}
                                r = !0
                            }
                            return r
                        } finally {
                            bt = n, Sl.transition = t
                        }
                    }
                    return !1
                }

                function Au(e, t, n) {
                    e = Uo(e, t = fa(0, t = ua(n, t), 1), 1), t = eu(), null !== e && (yt(e, 1, t), ru(e, t))
                }

                function ku(e, t, n) {
                    if (3 === e.tag) Au(e, e, n);
                    else
                        for (; null !== t;) {
                            if (3 === t.tag) {
                                Au(t, e, n);
                                break
                            }
                            if (1 === t.tag) {
                                var r = t.stateNode;
                                if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Ql || !Ql.has(r))) {
                                    t = Uo(t, e = pa(t, e = ua(n, e), 1), 1), e = eu(), null !== t && (yt(t, 1, e), ru(t, e));
                                    break
                                }
                            }
                            t = t.return
                        }
                }

                function Cu(e, t, n) {
                    var r = e.pingCache;
                    null !== r && r.delete(t), t = eu(), e.pingedLanes |= e.suspendedLanes & n, Nl === e && (Il & n) === n && (4 === Rl || 3 === Rl && (130023424 & Il) === Il && 500 > Ze() - zl ? hu(e, 0) : jl |= n), ru(e, t)
                }

                function Pu(e, t) {
                    0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ct, 0 === (130023424 & (ct <<= 1)) && (ct = 4194304)));
                    var n = eu();
                    null !== (e = Lo(e, t)) && (yt(e, t, n), ru(e, n))
                }

                function Su(e) {
                    var t = e.memoizedState,
                        n = 0;
                    null !== t && (n = t.retryLane), Pu(e, n)
                }

                function _u(e, t) {
                    var n = 0;
                    switch (e.tag) {
                        case 13:
                            var r = e.stateNode,
                                i = e.memoizedState;
                            null !== i && (n = i.retryLane);
                            break;
                        case 19:
                            r = e.stateNode;
                            break;
                        default:
                            throw Error(o(314))
                    }
                    null !== r && r.delete(t), Pu(e, n)
                }

                function Nu(e, t) {
                    return Ve(e, t)
                }

                function Mu(e, t, n, r) {
                    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
                }

                function Iu(e, t, n, r) {
                    return new Mu(e, t, n, r)
                }

                function Ou(e) {
                    return !(!(e = e.prototype) || !e.isReactComponent)
                }

                function Tu(e, t) {
                    var n = e.alternate;
                    return null === n ? ((n = Iu(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
                        lanes: t.lanes,
                        firstContext: t.firstContext
                    }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
                }

                function Ru(e, t, n, r, i, s) {
                    var a = 2;
                    if (r = e, "function" === typeof e) Ou(e) && (a = 1);
                    else if ("string" === typeof e) a = 5;
                    else e: switch (e) {
                        case A:
                            return Lu(n.children, i, s, t);
                        case k:
                            a = 8, i |= 8;
                            break;
                        case C:
                            return (e = Iu(12, n, t, 2 | i)).elementType = C, e.lanes = s, e;
                        case N:
                            return (e = Iu(13, n, t, i)).elementType = N, e.lanes = s, e;
                        case M:
                            return (e = Iu(19, n, t, i)).elementType = M, e.lanes = s, e;
                        case T:
                            return Bu(n, i, s, t);
                        default:
                            if ("object" === typeof e && null !== e) switch (e.$$typeof) {
                                case P:
                                    a = 10;
                                    break e;
                                case S:
                                    a = 9;
                                    break e;
                                case _:
                                    a = 11;
                                    break e;
                                case I:
                                    a = 14;
                                    break e;
                                case O:
                                    a = 16, r = null;
                                    break e
                            }
                            throw Error(o(130, null == e ? e : typeof e, ""))
                    }
                    return (t = Iu(a, n, t, i)).elementType = e, t.type = r, t.lanes = s, t
                }

                function Lu(e, t, n, r) {
                    return (e = Iu(7, e, r, t)).lanes = n, e
                }

                function Bu(e, t, n, r) {
                    return (e = Iu(22, e, r, t)).elementType = T, e.lanes = n, e.stateNode = {
                        isHidden: !1
                    }, e
                }

                function Fu(e, t, n) {
                    return (e = Iu(6, e, null, t)).lanes = n, e
                }

                function ju(e, t, n) {
                    return (t = Iu(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
                        containerInfo: e.containerInfo,
                        pendingChildren: null,
                        implementation: e.implementation
                    }, t
                }

                function Du(e, t, n, r, i) {
                    this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
                }

                function Uu(e, t, n, r, i, o, s, a, l) {
                    return e = new Du(e, t, n, a, l), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = Iu(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = {
                        element: r,
                        isDehydrated: n,
                        cache: null,
                        transitions: null,
                        pendingSuspenseBoundaries: null
                    }, Fo(o), e
                }

                function zu(e) {
                    if (!e) return Si;
                    e: {
                        if (qe(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170));
                        var t = e;do {
                            switch (t.tag) {
                                case 3:
                                    t = t.stateNode.context;
                                    break e;
                                case 1:
                                    if (Oi(t.type)) {
                                        t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                        break e
                                    }
                            }
                            t = t.return
                        } while (null !== t);
                        throw Error(o(171))
                    }
                    if (1 === e.tag) {
                        var n = e.type;
                        if (Oi(n)) return Li(e, n, t)
                    }
                    return t
                }

                function qu(e, t, n, r, i, o, s, a, l) {
                    return (e = Uu(n, r, !0, e, 0, o, 0, a, l)).context = zu(null), n = e.current, (o = Do(r = eu(), i = tu(n))).callback = void 0 !== t && null !== t ? t : null, Uo(n, o, i), e.current.lanes = i, yt(e, i, r), ru(e, r), e
                }

                function Gu(e, t, n, r) {
                    var i = t.current,
                        o = eu(),
                        s = tu(i);
                    return n = zu(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Do(o, s)).payload = {
                        element: e
                    }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Uo(i, t, s)) && (nu(e, i, s, o), zo(e, i, s)), s
                }

                function Hu(e) {
                    return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null
                }

                function $u(e, t) {
                    if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                        var n = e.retryLane;
                        e.retryLane = 0 !== n && n < t ? n : t
                    }
                }

                function Qu(e, t) {
                    $u(e, t), (e = e.alternate) && $u(e, t)
                }
                Al = function(e, t, n) {
                    if (null !== e)
                        if (e.memoizedProps !== t.pendingProps || Ni.current) ba = !0;
                        else {
                            if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return ba = !1,
                                function(e, t, n) {
                                    switch (t.tag) {
                                        case 3:
                                            Na(t), po();
                                            break;
                                        case 5:
                                            Yo(t);
                                            break;
                                        case 1:
                                            Oi(t.type) && Bi(t);
                                            break;
                                        case 4:
                                            Jo(t, t.stateNode.containerInfo);
                                            break;
                                        case 10:
                                            var r = t.type._context,
                                                i = t.memoizedProps.value;
                                            Pi(Ao, r._currentValue), r._currentValue = i;
                                            break;
                                        case 13:
                                            if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Pi(es, 1 & es.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Fa(e, t, n) : (Pi(es, 1 & es.current), null !== (e = Ha(e, t, n)) ? e.sibling : null);
                                            Pi(es, 1 & es.current);
                                            break;
                                        case 19:
                                            if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) {
                                                if (r) return qa(e, t, n);
                                                t.flags |= 128
                                            }
                                            if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Pi(es, es.current), r) break;
                                            return null;
                                        case 22:
                                        case 23:
                                            return t.lanes = 0, ka(e, t, n)
                                    }
                                    return Ha(e, t, n)
                                }(e, t, n);
                            ba = 0 !== (131072 & e.flags)
                        }
                    else ba = !1, io && 0 !== (1048576 & t.flags) && Xi(t, Qi, t.index);
                    switch (t.lanes = 0, t.tag) {
                        case 2:
                            var r = t.type;
                            Ga(e, t), e = t.pendingProps;
                            var i = Ii(t, _i.current);
                            Mo(t, n), i = gs(null, t, r, e, i, n);
                            var s = ys();
                            return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Oi(r) ? (s = !0, Bi(t)) : s = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Fo(t), i.updater = ia, t.stateNode = i, i._reactInternals = t, la(t, r, e, n), t = _a(null, t, r, !0, s, n)) : (t.tag = 0, io && s && eo(t), wa(null, t, i, n), t = t.child), t;
                        case 16:
                            r = t.elementType;
                            e: {
                                switch (Ga(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function(e) {
                                    if ("function" === typeof e) return Ou(e) ? 1 : 0;
                                    if (void 0 !== e && null !== e) {
                                        if ((e = e.$$typeof) === _) return 11;
                                        if (e === I) return 14
                                    }
                                    return 2
                                }(r), e = na(r, e), i) {
                                    case 0:
                                        t = Pa(null, t, r, e, n);
                                        break e;
                                    case 1:
                                        t = Sa(null, t, r, e, n);
                                        break e;
                                    case 11:
                                        t = Ea(null, t, r, e, n);
                                        break e;
                                    case 14:
                                        t = xa(null, t, r, na(r.type, e), n);
                                        break e
                                }
                                throw Error(o(306, r, ""))
                            }
                            return t;
                        case 0:
                            return r = t.type, i = t.pendingProps, Pa(e, t, r, i = t.elementType === r ? i : na(r, i), n);
                        case 1:
                            return r = t.type, i = t.pendingProps, Sa(e, t, r, i = t.elementType === r ? i : na(r, i), n);
                        case 3:
                            e: {
                                if (Na(t), null === e) throw Error(o(387));r = t.pendingProps,
                                i = (s = t.memoizedState).element,
                                jo(e, t),
                                Go(t, r, null, n);
                                var a = t.memoizedState;
                                if (r = a.element, s.isDehydrated) {
                                    if (s = {
                                            element: r,
                                            isDehydrated: !1,
                                            cache: a.cache,
                                            pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                                            transitions: a.transitions
                                        }, t.updateQueue.baseState = s, t.memoizedState = s, 256 & t.flags) {
                                        t = Ma(e, t, r, n, i = ua(Error(o(423)), t));
                                        break e
                                    }
                                    if (r !== i) {
                                        t = Ma(e, t, r, n, i = ua(Error(o(424)), t));
                                        break e
                                    }
                                    for (ro = ui(t.stateNode.containerInfo.firstChild), no = t, io = !0, oo = null, n = xo(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 4096, n = n.sibling
                                } else {
                                    if (po(), r === i) {
                                        t = Ha(e, t, n);
                                        break e
                                    }
                                    wa(e, t, r, n)
                                }
                                t = t.child
                            }
                            return t;
                        case 5:
                            return Yo(t), null === e && uo(t), r = t.type, i = t.pendingProps, s = null !== e ? e.memoizedProps : null, a = i.children, ni(r, i) ? a = null : null !== s && ni(r, s) && (t.flags |= 32), Ca(e, t), wa(e, t, a, n), t.child;
                        case 6:
                            return null === e && uo(t), null;
                        case 13:
                            return Fa(e, t, n);
                        case 4:
                            return Jo(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Eo(t, null, r, n) : wa(e, t, r, n), t.child;
                        case 11:
                            return r = t.type, i = t.pendingProps, Ea(e, t, r, i = t.elementType === r ? i : na(r, i), n);
                        case 7:
                            return wa(e, t, t.pendingProps, n), t.child;
                        case 8:
                        case 12:
                            return wa(e, t, t.pendingProps.children, n), t.child;
                        case 10:
                            e: {
                                if (r = t.type._context, i = t.pendingProps, s = t.memoizedProps, a = i.value, Pi(Ao, r._currentValue), r._currentValue = a, null !== s)
                                    if (ar(s.value, a)) {
                                        if (s.children === i.children && !Ni.current) {
                                            t = Ha(e, t, n);
                                            break e
                                        }
                                    } else
                                        for (null !== (s = t.child) && (s.return = t); null !== s;) {
                                            var l = s.dependencies;
                                            if (null !== l) {
                                                a = s.child;
                                                for (var u = l.firstContext; null !== u;) {
                                                    if (u.context === r) {
                                                        if (1 === s.tag) {
                                                            (u = Do(-1, n & -n)).tag = 2;
                                                            var c = s.updateQueue;
                                                            if (null !== c) {
                                                                var d = (c = c.shared).pending;
                                                                null === d ? u.next = u : (u.next = d.next, d.next = u), c.pending = u
                                                            }
                                                        }
                                                        s.lanes |= n, null !== (u = s.alternate) && (u.lanes |= n), No(s.return, n, t), l.lanes |= n;
                                                        break
                                                    }
                                                    u = u.next
                                                }
                                            } else if (10 === s.tag) a = s.type === t.type ? null : s.child;
                                            else if (18 === s.tag) {
                                                if (null === (a = s.return)) throw Error(o(341));
                                                a.lanes |= n, null !== (l = a.alternate) && (l.lanes |= n), No(a, n, t), a = s.sibling
                                            } else a = s.child;
                                            if (null !== a) a.return = s;
                                            else
                                                for (a = s; null !== a;) {
                                                    if (a === t) {
                                                        a = null;
                                                        break
                                                    }
                                                    if (null !== (s = a.sibling)) {
                                                        s.return = a.return, a = s;
                                                        break
                                                    }
                                                    a = a.return
                                                }
                                            s = a
                                        }
                                wa(e, t, i.children, n),
                                t = t.child
                            }
                            return t;
                        case 9:
                            return i = t.type, r = t.pendingProps.children, Mo(t, n), r = r(i = Io(i)), t.flags |= 1, wa(e, t, r, n), t.child;
                        case 14:
                            return i = na(r = t.type, t.pendingProps), xa(e, t, r, i = na(r.type, i), n);
                        case 15:
                            return Aa(e, t, t.type, t.pendingProps, n);
                        case 17:
                            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : na(r, i), Ga(e, t), t.tag = 1, Oi(r) ? (e = !0, Bi(t)) : e = !1, Mo(t, n), sa(t, r, i), la(t, r, i, n), _a(null, t, r, !0, e, n);
                        case 19:
                            return qa(e, t, n);
                        case 22:
                            return ka(e, t, n)
                    }
                    throw Error(o(156, t.tag))
                };
                var Vu = "function" === typeof reportError ? reportError : function(e) {
                    console.error(e)
                };

                function Ku(e) {
                    this._internalRoot = e
                }

                function Wu(e) {
                    this._internalRoot = e
                }

                function Ju(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
                }

                function Zu(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
                }

                function Yu() {}

                function Xu(e, t, n, r, i) {
                    var o = n._reactRootContainer;
                    if (o) {
                        var s = o;
                        if ("function" === typeof i) {
                            var a = i;
                            i = function() {
                                var e = Hu(s);
                                a.call(e)
                            }
                        }
                        Gu(t, s, e, i)
                    } else s = function(e, t, n, r, i) {
                        if (i) {
                            if ("function" === typeof r) {
                                var o = r;
                                r = function() {
                                    var e = Hu(s);
                                    o.call(e)
                                }
                            }
                            var s = qu(t, r, e, 0, null, !1, 0, "", Yu);
                            return e._reactRootContainer = s, e[pi] = s.current, qr(8 === e.nodeType ? e.parentNode : e), cu(), s
                        }
                        for (; i = e.lastChild;) e.removeChild(i);
                        if ("function" === typeof r) {
                            var a = r;
                            r = function() {
                                var e = Hu(l);
                                a.call(e)
                            }
                        }
                        var l = Uu(e, 0, !1, null, 0, !1, 0, "", Yu);
                        return e._reactRootContainer = l, e[pi] = l.current, qr(8 === e.nodeType ? e.parentNode : e), cu((function() {
                            Gu(t, l, n, r)
                        })), l
                    }(n, t, e, i, r);
                    return Hu(s)
                }
                Wu.prototype.render = Ku.prototype.render = function(e) {
                    var t = this._internalRoot;
                    if (null === t) throw Error(o(409));
                    Gu(e, t, null, null)
                }, Wu.prototype.unmount = Ku.prototype.unmount = function() {
                    var e = this._internalRoot;
                    if (null !== e) {
                        this._internalRoot = null;
                        var t = e.containerInfo;
                        cu((function() {
                            Gu(null, e, null, null)
                        })), t[pi] = null
                    }
                }, Wu.prototype.unstable_scheduleHydration = function(e) {
                    if (e) {
                        var t = kt();
                        e = {
                            blockedOn: null,
                            target: e,
                            priority: t
                        };
                        for (var n = 0; n < Tt.length && 0 !== t && t < Tt[n].priority; n++);
                        Tt.splice(n, 0, e), 0 === n && Ft(e)
                    }
                }, Et = function(e) {
                    switch (e.tag) {
                        case 3:
                            var t = e.stateNode;
                            if (t.current.memoizedState.isDehydrated) {
                                var n = dt(t.pendingLanes);
                                0 !== n && (vt(t, 1 | n), ru(t, Ze()), 0 === (6 & _l) && (ql = Ze() + 500, qi()))
                            }
                            break;
                        case 13:
                            cu((function() {
                                var t = Lo(e, 1);
                                if (null !== t) {
                                    var n = eu();
                                    nu(t, e, 1, n)
                                }
                            })), Qu(e, 1)
                    }
                }, xt = function(e) {
                    if (13 === e.tag) {
                        var t = Lo(e, 134217728);
                        if (null !== t) nu(t, e, 134217728, eu());
                        Qu(e, 134217728)
                    }
                }, At = function(e) {
                    if (13 === e.tag) {
                        var t = tu(e),
                            n = Lo(e, t);
                        if (null !== n) nu(n, e, t, eu());
                        Qu(e, t)
                    }
                }, kt = function() {
                    return bt
                }, Ct = function(e, t) {
                    var n = bt;
                    try {
                        return bt = e, t()
                    } finally {
                        bt = n
                    }
                }, xe = function(e, t, n) {
                    switch (t) {
                        case "input":
                            if (Y(e, n), t = n.name, "radio" === n.type && null != t) {
                                for (n = e; n.parentNode;) n = n.parentNode;
                                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                                    var r = n[t];
                                    if (r !== e && r.form === e.form) {
                                        var i = Ei(r);
                                        if (!i) throw Error(o(90));
                                        V(r), Y(r, i)
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            oe(e, n);
                            break;
                        case "select":
                            null != (t = n.value) && ne(e, !!n.multiple, t, !1)
                    }
                }, _e = uu, Ne = cu;
                var ec = {
                        usingClientEntryPoint: !1,
                        Events: [bi, wi, Ei, Pe, Se, uu]
                    },
                    tc = {
                        findFiberByHostInstance: vi,
                        bundleType: 0,
                        version: "18.3.1",
                        rendererPackageName: "react-dom"
                    },
                    nc = {
                        bundleType: tc.bundleType,
                        version: tc.version,
                        rendererPackageName: tc.rendererPackageName,
                        rendererConfig: tc.rendererConfig,
                        overrideHookState: null,
                        overrideHookStateDeletePath: null,
                        overrideHookStateRenamePath: null,
                        overrideProps: null,
                        overridePropsDeletePath: null,
                        overridePropsRenamePath: null,
                        setErrorHandler: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: w.ReactCurrentDispatcher,
                        findHostInstanceByFiber: function(e) {
                            return null === (e = $e(e)) ? null : e.stateNode
                        },
                        findFiberByHostInstance: tc.findFiberByHostInstance || function() {
                            return null
                        },
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null,
                        reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
                    };
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                    var rc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (!rc.isDisabled && rc.supportsFiber) try {
                        it = rc.inject(nc), ot = rc
                    } catch (ce) {}
                }
                t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ec, t.createPortal = function(e, t) {
                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (!Ju(t)) throw Error(o(200));
                    return function(e, t, n) {
                        var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                        return {
                            $$typeof: x,
                            key: null == r ? null : "" + r,
                            children: e,
                            containerInfo: t,
                            implementation: n
                        }
                    }(e, t, null, n)
                }, t.createRoot = function(e, t) {
                    if (!Ju(e)) throw Error(o(299));
                    var n = !1,
                        r = "",
                        i = Vu;
                    return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Uu(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, qr(8 === e.nodeType ? e.parentNode : e), new Ku(t)
                }, t.findDOMNode = function(e) {
                    if (null == e) return null;
                    if (1 === e.nodeType) return e;
                    var t = e._reactInternals;
                    if (void 0 === t) {
                        if ("function" === typeof e.render) throw Error(o(188));
                        throw e = Object.keys(e).join(","), Error(o(268, e))
                    }
                    return e = null === (e = $e(t)) ? null : e.stateNode
                }, t.flushSync = function(e) {
                    return cu(e)
                }, t.hydrate = function(e, t, n) {
                    if (!Zu(t)) throw Error(o(200));
                    return Xu(null, e, t, !0, n)
                }, t.hydrateRoot = function(e, t, n) {
                    if (!Ju(e)) throw Error(o(405));
                    var r = null != n && n.hydratedSources || null,
                        i = !1,
                        s = "",
                        a = Vu;
                    if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (s = n.identifierPrefix), void 0 !== n.onRecoverableError && (a = n.onRecoverableError)), t = qu(t, null, e, 1, null != n ? n : null, i, 0, s, a), e[pi] = t.current, qr(e), r)
                        for (e = 0; e < r.length; e++) i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
                    return new Wu(t)
                }, t.render = function(e, t, n) {
                    if (!Zu(t)) throw Error(o(200));
                    return Xu(null, e, t, !1, n)
                }, t.unmountComponentAtNode = function(e) {
                    if (!Zu(e)) throw Error(o(40));
                    return !!e._reactRootContainer && (cu((function() {
                        Xu(null, null, e, !1, (function() {
                            e._reactRootContainer = null, e[pi] = null
                        }))
                    })), !0)
                }, t.unstable_batchedUpdates = uu, t.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
                    if (!Zu(n)) throw Error(o(200));
                    if (null == e || void 0 === e._reactInternals) throw Error(o(38));
                    return Xu(e, t, n, !1, r)
                }, t.version = "18.3.1-next-f1338f8080-20240426"
            },
            4391: (e, t, n) => {
                "use strict";
                var r = n(7950);
                t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot
            },
            7950: (e, t, n) => {
                "use strict";
                ! function e() {
                    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
                }(), e.exports = n(2730)
            },
            1153: (e, t, n) => {
                "use strict";
                var r = n(5043),
                    i = Symbol.for("react.element"),
                    o = Symbol.for("react.fragment"),
                    s = Object.prototype.hasOwnProperty,
                    a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
                    l = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function u(e, t, n) {
                    var r, o = {},
                        u = null,
                        c = null;
                    for (r in void 0 !== n && (u = "" + n), void 0 !== t.key && (u = "" + t.key), void 0 !== t.ref && (c = t.ref), t) s.call(t, r) && !l.hasOwnProperty(r) && (o[r] = t[r]);
                    if (e && e.defaultProps)
                        for (r in t = e.defaultProps) void 0 === o[r] && (o[r] = t[r]);
                    return {
                        $$typeof: i,
                        type: e,
                        key: u,
                        ref: c,
                        props: o,
                        _owner: a.current
                    }
                }
                t.Fragment = o, t.jsx = u, t.jsxs = u
            },
            4202: (e, t) => {
                "use strict";
                var n = Symbol.for("react.element"),
                    r = Symbol.for("react.portal"),
                    i = Symbol.for("react.fragment"),
                    o = Symbol.for("react.strict_mode"),
                    s = Symbol.for("react.profiler"),
                    a = Symbol.for("react.provider"),
                    l = Symbol.for("react.context"),
                    u = Symbol.for("react.forward_ref"),
                    c = Symbol.for("react.suspense"),
                    d = Symbol.for("react.memo"),
                    h = Symbol.for("react.lazy"),
                    f = Symbol.iterator;
                var p = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    },
                    m = Object.assign,
                    g = {};

                function y(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || p
                }

                function v() {}

                function b(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || p
                }
                y.prototype.isReactComponent = {}, y.prototype.setState = function(e, t) {
                    if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                    this.updater.enqueueSetState(this, e, t, "setState")
                }, y.prototype.forceUpdate = function(e) {
                    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
                }, v.prototype = y.prototype;
                var w = b.prototype = new v;
                w.constructor = b, m(w, y.prototype), w.isPureReactComponent = !0;
                var E = Array.isArray,
                    x = Object.prototype.hasOwnProperty,
                    A = {
                        current: null
                    },
                    k = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function C(e, t, r) {
                    var i, o = {},
                        s = null,
                        a = null;
                    if (null != t)
                        for (i in void 0 !== t.ref && (a = t.ref), void 0 !== t.key && (s = "" + t.key), t) x.call(t, i) && !k.hasOwnProperty(i) && (o[i] = t[i]);
                    var l = arguments.length - 2;
                    if (1 === l) o.children = r;
                    else if (1 < l) {
                        for (var u = Array(l), c = 0; c < l; c++) u[c] = arguments[c + 2];
                        o.children = u
                    }
                    if (e && e.defaultProps)
                        for (i in l = e.defaultProps) void 0 === o[i] && (o[i] = l[i]);
                    return {
                        $$typeof: n,
                        type: e,
                        key: s,
                        ref: a,
                        props: o,
                        _owner: A.current
                    }
                }

                function P(e) {
                    return "object" === typeof e && null !== e && e.$$typeof === n
                }
                var S = /\/+/g;

                function _(e, t) {
                    return "object" === typeof e && null !== e && null != e.key ? function(e) {
                        var t = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + e.replace(/[=:]/g, (function(e) {
                            return t[e]
                        }))
                    }("" + e.key) : t.toString(36)
                }

                function N(e, t, i, o, s) {
                    var a = typeof e;
                    "undefined" !== a && "boolean" !== a || (e = null);
                    var l = !1;
                    if (null === e) l = !0;
                    else switch (a) {
                        case "string":
                        case "number":
                            l = !0;
                            break;
                        case "object":
                            switch (e.$$typeof) {
                                case n:
                                case r:
                                    l = !0
                            }
                    }
                    if (l) return s = s(l = e), e = "" === o ? "." + _(l, 0) : o, E(s) ? (i = "", null != e && (i = e.replace(S, "$&/") + "/"), N(s, t, i, "", (function(e) {
                        return e
                    }))) : null != s && (P(s) && (s = function(e, t) {
                        return {
                            $$typeof: n,
                            type: e.type,
                            key: t,
                            ref: e.ref,
                            props: e.props,
                            _owner: e._owner
                        }
                    }(s, i + (!s.key || l && l.key === s.key ? "" : ("" + s.key).replace(S, "$&/") + "/") + e)), t.push(s)), 1;
                    if (l = 0, o = "" === o ? "." : o + ":", E(e))
                        for (var u = 0; u < e.length; u++) {
                            var c = o + _(a = e[u], u);
                            l += N(a, t, i, c, s)
                        } else if (c = function(e) {
                                return null === e || "object" !== typeof e ? null : "function" === typeof(e = f && e[f] || e["@@iterator"]) ? e : null
                            }(e), "function" === typeof c)
                            for (e = c.call(e), u = 0; !(a = e.next()).done;) l += N(a = a.value, t, i, c = o + _(a, u++), s);
                        else if ("object" === a) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
                    return l
                }

                function M(e, t, n) {
                    if (null == e) return e;
                    var r = [],
                        i = 0;
                    return N(e, r, "", "", (function(e) {
                        return t.call(n, e, i++)
                    })), r
                }

                function I(e) {
                    if (-1 === e._status) {
                        var t = e._result;
                        (t = t()).then((function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t)
                        }), (function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t)
                        })), -1 === e._status && (e._status = 0, e._result = t)
                    }
                    if (1 === e._status) return e._result.default;
                    throw e._result
                }
                var O = {
                        current: null
                    },
                    T = {
                        transition: null
                    },
                    R = {
                        ReactCurrentDispatcher: O,
                        ReactCurrentBatchConfig: T,
                        ReactCurrentOwner: A
                    };

                function L() {
                    throw Error("act(...) is not supported in production builds of React.")
                }
                t.Children = {
                    map: M,
                    forEach: function(e, t, n) {
                        M(e, (function() {
                            t.apply(this, arguments)
                        }), n)
                    },
                    count: function(e) {
                        var t = 0;
                        return M(e, (function() {
                            t++
                        })), t
                    },
                    toArray: function(e) {
                        return M(e, (function(e) {
                            return e
                        })) || []
                    },
                    only: function(e) {
                        if (!P(e)) throw Error("React.Children.only expected to receive a single React element child.");
                        return e
                    }
                }, t.Component = y, t.Fragment = i, t.Profiler = s, t.PureComponent = b, t.StrictMode = o, t.Suspense = c, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = R, t.act = L, t.cloneElement = function(e, t, r) {
                    if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
                    var i = m({}, e.props),
                        o = e.key,
                        s = e.ref,
                        a = e._owner;
                    if (null != t) {
                        if (void 0 !== t.ref && (s = t.ref, a = A.current), void 0 !== t.key && (o = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps;
                        for (u in t) x.call(t, u) && !k.hasOwnProperty(u) && (i[u] = void 0 === t[u] && void 0 !== l ? l[u] : t[u])
                    }
                    var u = arguments.length - 2;
                    if (1 === u) i.children = r;
                    else if (1 < u) {
                        l = Array(u);
                        for (var c = 0; c < u; c++) l[c] = arguments[c + 2];
                        i.children = l
                    }
                    return {
                        $$typeof: n,
                        type: e.type,
                        key: o,
                        ref: s,
                        props: i,
                        _owner: a
                    }
                }, t.createContext = function(e) {
                    return (e = {
                        $$typeof: l,
                        _currentValue: e,
                        _currentValue2: e,
                        _threadCount: 0,
                        Provider: null,
                        Consumer: null,
                        _defaultValue: null,
                        _globalName: null
                    }).Provider = {
                        $$typeof: a,
                        _context: e
                    }, e.Consumer = e
                }, t.createElement = C, t.createFactory = function(e) {
                    var t = C.bind(null, e);
                    return t.type = e, t
                }, t.createRef = function() {
                    return {
                        current: null
                    }
                }, t.forwardRef = function(e) {
                    return {
                        $$typeof: u,
                        render: e
                    }
                }, t.isValidElement = P, t.lazy = function(e) {
                    return {
                        $$typeof: h,
                        _payload: {
                            _status: -1,
                            _result: e
                        },
                        _init: I
                    }
                }, t.memo = function(e, t) {
                    return {
                        $$typeof: d,
                        type: e,
                        compare: void 0 === t ? null : t
                    }
                }, t.startTransition = function(e) {
                    var t = T.transition;
                    T.transition = {};
                    try {
                        e()
                    } finally {
                        T.transition = t
                    }
                }, t.unstable_act = L, t.useCallback = function(e, t) {
                    return O.current.useCallback(e, t)
                }, t.useContext = function(e) {
                    return O.current.useContext(e)
                }, t.useDebugValue = function() {}, t.useDeferredValue = function(e) {
                    return O.current.useDeferredValue(e)
                }, t.useEffect = function(e, t) {
                    return O.current.useEffect(e, t)
                }, t.useId = function() {
                    return O.current.useId()
                }, t.useImperativeHandle = function(e, t, n) {
                    return O.current.useImperativeHandle(e, t, n)
                }, t.useInsertionEffect = function(e, t) {
                    return O.current.useInsertionEffect(e, t)
                }, t.useLayoutEffect = function(e, t) {
                    return O.current.useLayoutEffect(e, t)
                }, t.useMemo = function(e, t) {
                    return O.current.useMemo(e, t)
                }, t.useReducer = function(e, t, n) {
                    return O.current.useReducer(e, t, n)
                }, t.useRef = function(e) {
                    return O.current.useRef(e)
                }, t.useState = function(e) {
                    return O.current.useState(e)
                }, t.useSyncExternalStore = function(e, t, n) {
                    return O.current.useSyncExternalStore(e, t, n)
                }, t.useTransition = function() {
                    return O.current.useTransition()
                }, t.version = "18.3.1"
            },
            5043: (e, t, n) => {
                "use strict";
                e.exports = n(4202)
            },
            579: (e, t, n) => {
                "use strict";
                e.exports = n(1153)
            },
            7234: (e, t) => {
                "use strict";

                function n(e, t) {
                    var n = e.length;
                    e.push(t);
                    e: for (; 0 < n;) {
                        var r = n - 1 >>> 1,
                            i = e[r];
                        if (!(0 < o(i, t))) break e;
                        e[r] = t, e[n] = i, n = r
                    }
                }

                function r(e) {
                    return 0 === e.length ? null : e[0]
                }

                function i(e) {
                    if (0 === e.length) return null;
                    var t = e[0],
                        n = e.pop();
                    if (n !== t) {
                        e[0] = n;
                        e: for (var r = 0, i = e.length, s = i >>> 1; r < s;) {
                            var a = 2 * (r + 1) - 1,
                                l = e[a],
                                u = a + 1,
                                c = e[u];
                            if (0 > o(l, n)) u < i && 0 > o(c, l) ? (e[r] = c, e[u] = n, r = u) : (e[r] = l, e[a] = n, r = a);
                            else {
                                if (!(u < i && 0 > o(c, n))) break e;
                                e[r] = c, e[u] = n, r = u
                            }
                        }
                    }
                    return t
                }

                function o(e, t) {
                    var n = e.sortIndex - t.sortIndex;
                    return 0 !== n ? n : e.id - t.id
                }
                if ("object" === typeof performance && "function" === typeof performance.now) {
                    var s = performance;
                    t.unstable_now = function() {
                        return s.now()
                    }
                } else {
                    var a = Date,
                        l = a.now();
                    t.unstable_now = function() {
                        return a.now() - l
                    }
                }
                var u = [],
                    c = [],
                    d = 1,
                    h = null,
                    f = 3,
                    p = !1,
                    m = !1,
                    g = !1,
                    y = "function" === typeof setTimeout ? setTimeout : null,
                    v = "function" === typeof clearTimeout ? clearTimeout : null,
                    b = "undefined" !== typeof setImmediate ? setImmediate : null;

                function w(e) {
                    for (var t = r(c); null !== t;) {
                        if (null === t.callback) i(c);
                        else {
                            if (!(t.startTime <= e)) break;
                            i(c), t.sortIndex = t.expirationTime, n(u, t)
                        }
                        t = r(c)
                    }
                }

                function E(e) {
                    if (g = !1, w(e), !m)
                        if (null !== r(u)) m = !0, T(x);
                        else {
                            var t = r(c);
                            null !== t && R(E, t.startTime - e)
                        }
                }

                function x(e, n) {
                    m = !1, g && (g = !1, v(P), P = -1), p = !0;
                    var o = f;
                    try {
                        for (w(n), h = r(u); null !== h && (!(h.expirationTime > n) || e && !N());) {
                            var s = h.callback;
                            if ("function" === typeof s) {
                                h.callback = null, f = h.priorityLevel;
                                var a = s(h.expirationTime <= n);
                                n = t.unstable_now(), "function" === typeof a ? h.callback = a : h === r(u) && i(u), w(n)
                            } else i(u);
                            h = r(u)
                        }
                        if (null !== h) var l = !0;
                        else {
                            var d = r(c);
                            null !== d && R(E, d.startTime - n), l = !1
                        }
                        return l
                    } finally {
                        h = null, f = o, p = !1
                    }
                }
                "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
                var A, k = !1,
                    C = null,
                    P = -1,
                    S = 5,
                    _ = -1;

                function N() {
                    return !(t.unstable_now() - _ < S)
                }

                function M() {
                    if (null !== C) {
                        var e = t.unstable_now();
                        _ = e;
                        var n = !0;
                        try {
                            n = C(!0, e)
                        } finally {
                            n ? A() : (k = !1, C = null)
                        }
                    } else k = !1
                }
                if ("function" === typeof b) A = function() {
                    b(M)
                };
                else if ("undefined" !== typeof MessageChannel) {
                    var I = new MessageChannel,
                        O = I.port2;
                    I.port1.onmessage = M, A = function() {
                        O.postMessage(null)
                    }
                } else A = function() {
                    y(M, 0)
                };

                function T(e) {
                    C = e, k || (k = !0, A())
                }

                function R(e, n) {
                    P = y((function() {
                        e(t.unstable_now())
                    }), n)
                }
                t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(e) {
                    e.callback = null
                }, t.unstable_continueExecution = function() {
                    m || p || (m = !0, T(x))
                }, t.unstable_forceFrameRate = function(e) {
                    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : S = 0 < e ? Math.floor(1e3 / e) : 5
                }, t.unstable_getCurrentPriorityLevel = function() {
                    return f
                }, t.unstable_getFirstCallbackNode = function() {
                    return r(u)
                }, t.unstable_next = function(e) {
                    switch (f) {
                        case 1:
                        case 2:
                        case 3:
                            var t = 3;
                            break;
                        default:
                            t = f
                    }
                    var n = f;
                    f = t;
                    try {
                        return e()
                    } finally {
                        f = n
                    }
                }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            e = 3
                    }
                    var n = f;
                    f = e;
                    try {
                        return t()
                    } finally {
                        f = n
                    }
                }, t.unstable_scheduleCallback = function(e, i, o) {
                    var s = t.unstable_now();
                    switch ("object" === typeof o && null !== o ? o = "number" === typeof(o = o.delay) && 0 < o ? s + o : s : o = s, e) {
                        case 1:
                            var a = -1;
                            break;
                        case 2:
                            a = 250;
                            break;
                        case 5:
                            a = 1073741823;
                            break;
                        case 4:
                            a = 1e4;
                            break;
                        default:
                            a = 5e3
                    }
                    return e = {
                        id: d++,
                        callback: i,
                        priorityLevel: e,
                        startTime: o,
                        expirationTime: a = o + a,
                        sortIndex: -1
                    }, o > s ? (e.sortIndex = o, n(c, e), null === r(u) && e === r(c) && (g ? (v(P), P = -1) : g = !0, R(E, o - s))) : (e.sortIndex = a, n(u, e), m || p || (m = !0, T(x))), e
                }, t.unstable_shouldYield = N, t.unstable_wrapCallback = function(e) {
                    var t = f;
                    return function() {
                        var n = f;
                        f = t;
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            f = n
                        }
                    }
                }
            },
            8853: (e, t, n) => {
                "use strict";
                e.exports = n(7234)
            },
            5956: (e, t, n) => {
                "use strict";
                var r = n(5043);
                var i = "function" === typeof Object.is ? Object.is : function(e, t) {
                        return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                    },
                    o = r.useState,
                    s = r.useEffect,
                    a = r.useLayoutEffect,
                    l = r.useDebugValue;

                function u(e) {
                    var t = e.getSnapshot;
                    e = e.value;
                    try {
                        var n = t();
                        return !i(e, n)
                    } catch (r) {
                        return !0
                    }
                }
                var c = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? function(e, t) {
                    return t()
                } : function(e, t) {
                    var n = t(),
                        r = o({
                            inst: {
                                value: n,
                                getSnapshot: t
                            }
                        }),
                        i = r[0].inst,
                        c = r[1];
                    return a((function() {
                        i.value = n, i.getSnapshot = t, u(i) && c({
                            inst: i
                        })
                    }), [e, n, t]), s((function() {
                        return u(i) && c({
                            inst: i
                        }), e((function() {
                            u(i) && c({
                                inst: i
                            })
                        }))
                    }), [e]), l(n), n
                };
                t.useSyncExternalStore = void 0 !== r.useSyncExternalStore ? r.useSyncExternalStore : c
            },
            5039: (e, t, n) => {
                "use strict";
                var r = n(5043),
                    i = n(9461);
                var o = "function" === typeof Object.is ? Object.is : function(e, t) {
                        return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                    },
                    s = i.useSyncExternalStore,
                    a = r.useRef,
                    l = r.useEffect,
                    u = r.useMemo,
                    c = r.useDebugValue;
                t.useSyncExternalStoreWithSelector = function(e, t, n, r, i) {
                    var d = a(null);
                    if (null === d.current) {
                        var h = {
                            hasValue: !1,
                            value: null
                        };
                        d.current = h
                    } else h = d.current;
                    d = u((function() {
                        function e(e) {
                            if (!l) {
                                if (l = !0, s = e, e = r(e), void 0 !== i && h.hasValue) {
                                    var t = h.value;
                                    if (i(t, e)) return a = t
                                }
                                return a = e
                            }
                            if (t = a, o(s, e)) return t;
                            var n = r(e);
                            return void 0 !== i && i(t, n) ? t : (s = e, a = n)
                        }
                        var s, a, l = !1,
                            u = void 0 === n ? null : n;
                        return [function() {
                            return e(t())
                        }, null === u ? void 0 : function() {
                            return e(u())
                        }]
                    }), [t, n, r, i]);
                    var f = s(e, d[0], d[1]);
                    return l((function() {
                        h.hasValue = !0, h.value = f
                    }), [f]), c(f), f
                }
            },
            9461: (e, t, n) => {
                "use strict";
                e.exports = n(5956)
            },
            8443: (e, t, n) => {
                "use strict";
                e.exports = n(5039)
            },
            7790: () => {},
            8139: (e, t) => {
                var n;
                ! function() {
                    "use strict";
                    var r = {}.hasOwnProperty;

                    function i() {
                        for (var e = "", t = 0; t < arguments.length; t++) {
                            var n = arguments[t];
                            n && (e = s(e, o(n)))
                        }
                        return e
                    }

                    function o(e) {
                        if ("string" === typeof e || "number" === typeof e) return e;
                        if ("object" !== typeof e) return "";
                        if (Array.isArray(e)) return i.apply(null, e);
                        if (e.toString !== Object.prototype.toString && !e.toString.toString().includes("[native code]")) return e.toString();
                        var t = "";
                        for (var n in e) r.call(e, n) && e[n] && (t = s(t, n));
                        return t
                    }

                    function s(e, t) {
                        return t ? e ? e + " " + t : e + t : e
                    }
                    e.exports ? (i.default = i, e.exports = i) : void 0 === (n = function() {
                        return i
                    }.apply(t, [])) || (e.exports = n)
                }()
            },
            4034: (e, t, n) => {
                "use strict";

                function r(e) {
                    return "string" === typeof e ? {
                        address: e,
                        type: "json-rpc"
                    } : e
                }
                n.d(t, {
                    J: () => r
                })
            },
            9357: (e, t, n) => {
                "use strict";
                n.d(t, {
                    T1: () => A
                });
                var r = n(4034),
                    i = n(2770);
                const o = "0x82ad56cb";
                var s = n(3491),
                    a = n(1370),
                    l = n(6310),
                    u = n(7942),
                    c = n(4603),
                    d = n(1602),
                    h = n(1313),
                    f = n(7908),
                    p = n(3556),
                    m = n(1898),
                    g = n(4117),
                    y = n(2343),
                    v = n(6615);
                var b = n(1928),
                    w = n(6812),
                    E = n(6510),
                    x = n(2861);
                async function A(e, t) {
                    const {
                        account: s = e.account,
                        batch: c = Boolean(e.batch ? .multicall),
                        blockNumber: d,
                        blockTag: p = "latest",
                        accessList: A,
                        blobs: k,
                        data: C,
                        gas: S,
                        gasPrice: _,
                        maxFeePerBlobGas: N,
                        maxFeePerGas: M,
                        maxPriorityFeePerGas: I,
                        nonce: O,
                        to: T,
                        value: R,
                        stateOverride: L,
                        ...B
                    } = t, F = s ? (0, r.J)(s) : void 0;
                    try {
                        (0, x.c)(t);
                        const n = (d ? (0, g.cK)(d) : void 0) || p,
                            r = P(L),
                            s = e.chain ? .formatters ? .transactionRequest ? .format,
                            a = (s || w.Bv)({ ...(0, b.o)(B, {
                                    format: s
                                }),
                                from: F ? .address,
                                accessList: A,
                                blobs: k,
                                data: C,
                                gas: S,
                                gasPrice: _,
                                maxFeePerBlobGas: N,
                                maxFeePerGas: M,
                                maxPriorityFeePerGas: I,
                                nonce: O,
                                to: T,
                                value: R
                            });
                        if (c && function(e) {
                                let {
                                    request: t
                                } = e;
                                const {
                                    data: n,
                                    to: r,
                                    ...i
                                } = t;
                                return !!n && (!n.startsWith(o) && (!!r && !(Object.values(i).filter((e => "undefined" !== typeof e)).length > 0)))
                            }({
                                request: a
                            }) && !r) try {
                            return await async function(e, t) {
                                const {
                                    batchSize: n = 1024,
                                    wait: r = 0
                                } = "object" === typeof e.batch ? .multicall ? e.batch.multicall : {}, {
                                    blockNumber: o,
                                    blockTag: s = "latest",
                                    data: a,
                                    multicallAddress: c,
                                    to: d
                                } = t;
                                let p = c;
                                if (!p) {
                                    if (!e.chain) throw new l.YE;
                                    p = (0, m.M)({
                                        blockNumber: o,
                                        chain: e.chain,
                                        contract: "multicall3"
                                    })
                                }
                                const y = o ? (0, g.cK)(o) : void 0,
                                    v = y || s,
                                    {
                                        schedule: b
                                    } = (0, E.u)({
                                        id: `${e.uid}.${v}`,
                                        wait: r,
                                        shouldSplitBatch(e) {
                                            const t = e.reduce(((e, t) => {
                                                let {
                                                    data: n
                                                } = t;
                                                return e + (n.length - 2)
                                            }), 0);
                                            return t > 2 * n
                                        },
                                        fn: async t => {
                                            const n = t.map((e => ({
                                                    allowFailure: !0,
                                                    callData: e.data,
                                                    target: e.to
                                                }))),
                                                r = (0, f.p)({
                                                    abi: i.v2,
                                                    args: [n],
                                                    functionName: "aggregate3"
                                                }),
                                                o = await e.request({
                                                    method: "eth_call",
                                                    params: [{
                                                        data: r,
                                                        to: p
                                                    }, v]
                                                });
                                            return (0, h.e)({
                                                abi: i.v2,
                                                args: [n],
                                                functionName: "aggregate3",
                                                data: o || "0x"
                                            })
                                        }
                                    }),
                                    [{
                                        returnData: w,
                                        success: x
                                    }] = await b({
                                        data: a,
                                        to: d
                                    });
                                if (!x) throw new u.$S({
                                    data: w
                                });
                                return "0x" === w ? {
                                    data: void 0
                                } : {
                                    data: w
                                }
                            }(e, { ...a,
                                blockNumber: d,
                                blockTag: p
                            })
                        } catch (j) {
                            if (!(j instanceof l.YE) && !(j instanceof l.rj)) throw j
                        }
                        const y = await e.request({
                            method: "eth_call",
                            params: r ? [a, n, r] : [a, n]
                        });
                        return "0x" === y ? {
                            data: void 0
                        } : {
                            data: y
                        }
                    } catch (j) {
                        const r = function(e) {
                                if (!(e instanceof a.C)) return;
                                const t = e.walk();
                                return "object" === typeof t ? .data ? t.data ? .data : t.data
                            }(j),
                            {
                                offchainLookup: i,
                                offchainLookupSignature: o
                            } = await n.e(507).then(n.bind(n, 8507));
                        if (!1 !== e.ccipRead && r ? .slice(0, 10) === o && T) return {
                            data: await i(e, {
                                data: r,
                                to: T
                            })
                        };
                        throw function(e, t) {
                            let {
                                docsPath: n,
                                ...r
                            } = t;
                            const i = (() => {
                                const t = (0, v.l)(e, r);
                                return t instanceof y.RM ? e : t
                            })();
                            return new u.zX(i, {
                                docsPath: n,
                                ...r
                            })
                        }(j, { ...t,
                            account: F,
                            chain: e.chain
                        })
                    }
                }

                function k(e) {
                    if (e && 0 !== e.length) return e.reduce(((e, t) => {
                        let {
                            slot: n,
                            value: r
                        } = t;
                        if (66 !== n.length) throw new c.NV({
                            size: n.length,
                            targetSize: 66,
                            type: "hex"
                        });
                        if (66 !== r.length) throw new c.NV({
                            size: r.length,
                            targetSize: 66,
                            type: "hex"
                        });
                        return e[n] = r, e
                    }), {})
                }

                function C(e) {
                    const {
                        balance: t,
                        nonce: n,
                        state: r,
                        stateDiff: i,
                        code: o
                    } = e, s = {};
                    if (void 0 !== o && (s.code = o), void 0 !== t && (s.balance = (0, g.cK)(t)), void 0 !== n && (s.nonce = (0, g.cK)(n)), void 0 !== r && (s.state = k(r)), void 0 !== i) {
                        if (s.state) throw new d.ft;
                        s.stateDiff = k(i)
                    }
                    return s
                }

                function P(e) {
                    if (!e) return;
                    const t = {};
                    for (const {
                            address: n,
                            ...r
                        } of e) {
                        if (!(0, p.P)(n, {
                                strict: !1
                            })) throw new s.M({
                            address: n
                        });
                        if (t[n]) throw new d.Hi({
                            address: n
                        });
                        t[n] = C(r)
                    }
                    return t
                }
            },
            2770: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Ag: () => o,
                    Rm: () => l,
                    SJ: () => a,
                    _: () => u,
                    oX: () => s,
                    v2: () => r
                });
                const r = [{
                        inputs: [{
                            components: [{
                                name: "target",
                                type: "address"
                            }, {
                                name: "allowFailure",
                                type: "bool"
                            }, {
                                name: "callData",
                                type: "bytes"
                            }],
                            name: "calls",
                            type: "tuple[]"
                        }],
                        name: "aggregate3",
                        outputs: [{
                            components: [{
                                name: "success",
                                type: "bool"
                            }, {
                                name: "returnData",
                                type: "bytes"
                            }],
                            name: "returnData",
                            type: "tuple[]"
                        }],
                        stateMutability: "view",
                        type: "function"
                    }],
                    i = [{
                        inputs: [],
                        name: "ResolverNotFound",
                        type: "error"
                    }, {
                        inputs: [],
                        name: "ResolverWildcardNotSupported",
                        type: "error"
                    }, {
                        inputs: [],
                        name: "ResolverNotContract",
                        type: "error"
                    }, {
                        inputs: [{
                            name: "returnData",
                            type: "bytes"
                        }],
                        name: "ResolverError",
                        type: "error"
                    }, {
                        inputs: [{
                            components: [{
                                name: "status",
                                type: "uint16"
                            }, {
                                name: "message",
                                type: "string"
                            }],
                            name: "errors",
                            type: "tuple[]"
                        }],
                        name: "HttpError",
                        type: "error"
                    }],
                    o = [...i, {
                        name: "resolve",
                        type: "function",
                        stateMutability: "view",
                        inputs: [{
                            name: "name",
                            type: "bytes"
                        }, {
                            name: "data",
                            type: "bytes"
                        }],
                        outputs: [{
                            name: "",
                            type: "bytes"
                        }, {
                            name: "address",
                            type: "address"
                        }]
                    }, {
                        name: "resolve",
                        type: "function",
                        stateMutability: "view",
                        inputs: [{
                            name: "name",
                            type: "bytes"
                        }, {
                            name: "data",
                            type: "bytes"
                        }, {
                            name: "gateways",
                            type: "string[]"
                        }],
                        outputs: [{
                            name: "",
                            type: "bytes"
                        }, {
                            name: "address",
                            type: "address"
                        }]
                    }],
                    s = [...i, {
                        name: "reverse",
                        type: "function",
                        stateMutability: "view",
                        inputs: [{
                            type: "bytes",
                            name: "reverseName"
                        }],
                        outputs: [{
                            type: "string",
                            name: "resolvedName"
                        }, {
                            type: "address",
                            name: "resolvedAddress"
                        }, {
                            type: "address",
                            name: "reverseResolver"
                        }, {
                            type: "address",
                            name: "resolver"
                        }]
                    }, {
                        name: "reverse",
                        type: "function",
                        stateMutability: "view",
                        inputs: [{
                            type: "bytes",
                            name: "reverseName"
                        }, {
                            type: "string[]",
                            name: "gateways"
                        }],
                        outputs: [{
                            type: "string",
                            name: "resolvedName"
                        }, {
                            type: "address",
                            name: "resolvedAddress"
                        }, {
                            type: "address",
                            name: "reverseResolver"
                        }, {
                            type: "address",
                            name: "resolver"
                        }]
                    }],
                    a = [{
                        name: "text",
                        type: "function",
                        stateMutability: "view",
                        inputs: [{
                            name: "name",
                            type: "bytes32"
                        }, {
                            name: "key",
                            type: "string"
                        }],
                        outputs: [{
                            name: "",
                            type: "string"
                        }]
                    }],
                    l = [{
                        name: "addr",
                        type: "function",
                        stateMutability: "view",
                        inputs: [{
                            name: "name",
                            type: "bytes32"
                        }],
                        outputs: [{
                            name: "",
                            type: "address"
                        }]
                    }, {
                        name: "addr",
                        type: "function",
                        stateMutability: "view",
                        inputs: [{
                            name: "name",
                            type: "bytes32"
                        }, {
                            name: "coinType",
                            type: "uint256"
                        }],
                        outputs: [{
                            name: "",
                            type: "bytes"
                        }]
                    }],
                    u = [{
                        inputs: [{
                            internalType: "address",
                            name: "_signer",
                            type: "address"
                        }, {
                            internalType: "bytes32",
                            name: "_hash",
                            type: "bytes32"
                        }, {
                            internalType: "bytes",
                            name: "_signature",
                            type: "bytes"
                        }],
                        stateMutability: "nonpayable",
                        type: "constructor"
                    }]
            },
            9048: (e, t, n) => {
                "use strict";
                n.d(t, {
                    J9: () => o,
                    Mc: () => i,
                    fD: () => r
                });
                const r = {
                        1: "An `assert` condition failed.",
                        17: "Arithmetic operation resulted in underflow or overflow.",
                        18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
                        33: "Attempted to convert to an invalid type.",
                        34: "Attempted to access a storage byte array that is incorrectly encoded.",
                        49: "Performed `.pop()` on an empty array",
                        50: "Array index is out of bounds.",
                        65: "Allocated too much memory or created an array which is too large.",
                        81: "Attempted to call a zero-initialized variable of internal function type."
                    },
                    i = {
                        inputs: [{
                            name: "message",
                            type: "string"
                        }],
                        name: "Error",
                        type: "error"
                    },
                    o = {
                        inputs: [{
                            name: "reason",
                            type: "uint256"
                        }],
                        name: "Panic",
                        type: "error"
                    }
            },
            9611: (e, t, n) => {
                "use strict";
                n.d(t, {
                    eL: () => r,
                    sz: () => i
                });
                const r = {
                        gwei: 9,
                        wei: 18
                    },
                    i = {
                        ether: -9,
                        wei: 9
                    }
            },
            7965: (e, t, n) => {
                "use strict";
                n.d(t, {
                    BI: () => w,
                    Iy: () => l,
                    Iz: () => y,
                    MR: () => v,
                    M_: () => g,
                    Nc: () => c,
                    O: () => u,
                    Wq: () => f,
                    YE: () => h,
                    YF: () => a,
                    YW: () => s,
                    _z: () => p,
                    d_: () => P,
                    dm: () => C,
                    fo: () => E,
                    gH: () => d,
                    j: () => k,
                    kE: () => m,
                    l3: () => x,
                    nK: () => A,
                    nM: () => b
                });
                var r = n(9052),
                    i = n(2017),
                    o = n(1370);
                class s extends o.C {
                    constructor(e) {
                        let {
                            docsPath: t
                        } = e;
                        super(["A constructor was not found on the ABI.", "Make sure you are using the correct ABI and that the constructor exists on it."].join("\n"), {
                            docsPath: t
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiConstructorNotFoundError"
                        })
                    }
                }
                class a extends o.C {
                    constructor(e) {
                        let {
                            docsPath: t
                        } = e;
                        super(["Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.", "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."].join("\n"), {
                            docsPath: t
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiConstructorParamsNotFoundError"
                        })
                    }
                }
                o.C;
                class l extends o.C {
                    constructor(e) {
                        let {
                            data: t,
                            params: n,
                            size: i
                        } = e;
                        super([`Data size of ${i} bytes is too small for given parameters.`].join("\n"), {
                            metaMessages: [`Params: (${(0,r.A)(n,{includeName:!0})})`, `Data:   ${t} (${i} bytes)`]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiDecodingDataSizeTooSmallError"
                        }), Object.defineProperty(this, "data", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "params", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "size", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.data = t, this.params = n, this.size = i
                    }
                }
                o.C;
                class u extends o.C {
                    constructor() {
                        super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiDecodingZeroDataError"
                        })
                    }
                }
                class c extends o.C {
                    constructor(e) {
                        let {
                            expectedLength: t,
                            givenLength: n,
                            type: r
                        } = e;
                        super([`ABI encoding array length mismatch for type ${r}.`, `Expected length: ${t}`, `Given length: ${n}`].join("\n")), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiEncodingArrayLengthMismatchError"
                        })
                    }
                }
                class d extends o.C {
                    constructor(e) {
                        let {
                            expectedSize: t,
                            value: n
                        } = e;
                        super(`Size of bytes "${n}" (bytes${(0,i.E)(n)}) does not match expected size (bytes${t}).`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiEncodingBytesSizeMismatchError"
                        })
                    }
                }
                class h extends o.C {
                    constructor(e) {
                        let {
                            expectedLength: t,
                            givenLength: n
                        } = e;
                        super(["ABI encoding params/values length mismatch.", `Expected length (params): ${t}`, `Given length (values): ${n}`].join("\n")), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiEncodingLengthMismatchError"
                        })
                    }
                }
                o.C;
                o.C;
                class f extends o.C {
                    constructor(e, t) {
                        let {
                            docsPath: n
                        } = t;
                        super([`Encoded error signature "${e}" not found on ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"), {
                            docsPath: n
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiErrorSignatureNotFoundError"
                        }), Object.defineProperty(this, "signature", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.signature = e
                    }
                }
                class p extends o.C {
                    constructor(e) {
                        let {
                            docsPath: t
                        } = e;
                        super("Cannot extract event signature from empty topics.", {
                            docsPath: t
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiEventSignatureEmptyTopicsError"
                        })
                    }
                }
                class m extends o.C {
                    constructor(e, t) {
                        let {
                            docsPath: n
                        } = t;
                        super([`Encoded event signature "${e}" not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it.", `You can look up the signature here: https://openchain.xyz/signatures?query=${e}.`].join("\n"), {
                            docsPath: n
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiEventSignatureNotFoundError"
                        })
                    }
                }
                class g extends o.C {
                    constructor(e) {
                        let {
                            docsPath: t
                        } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        super([`Event ${e?`"${e}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the event exists on it."].join("\n"), {
                            docsPath: t
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiEventNotFoundError"
                        })
                    }
                }
                class y extends o.C {
                    constructor(e) {
                        let {
                            docsPath: t
                        } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        super([`Function ${e?`"${e}" `:""}not found on ABI.`, "Make sure you are using the correct ABI and that the function exists on it."].join("\n"), {
                            docsPath: t
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiFunctionNotFoundError"
                        })
                    }
                }
                class v extends o.C {
                    constructor(e, t) {
                        let {
                            docsPath: n
                        } = t;
                        super([`Function "${e}" does not contain any \`outputs\` on ABI.`, "Cannot decode function result without knowing what the parameter types are.", "Make sure you are using the correct ABI and that the function exists on it."].join("\n"), {
                            docsPath: n
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiFunctionOutputsNotFoundError"
                        })
                    }
                }
                o.C;
                class b extends o.C {
                    constructor(e, t) {
                        super("Found ambiguous types in overloaded ABI items.", {
                            metaMessages: [`\`${e.type}\` in \`${(0,r.B)(e.abiItem)}\`, and`, `\`${t.type}\` in \`${(0,r.B)(t.abiItem)}\``, "", "These types encode differently and cannot be distinguished at runtime.", "Remove one of the ambiguous items in the ABI."]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AbiItemAmbiguityError"
                        })
                    }
                }
                class w extends o.C {
                    constructor(e) {
                        let {
                            expectedSize: t,
                            givenSize: n
                        } = e;
                        super(`Expected bytes${t}, got bytes${n}.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "BytesSizeMismatchError"
                        })
                    }
                }
                class E extends o.C {
                    constructor(e) {
                        let {
                            abiItem: t,
                            data: n,
                            params: i,
                            size: o
                        } = e;
                        super([`Data size of ${o} bytes is too small for non-indexed event parameters.`].join("\n"), {
                            metaMessages: [`Params: (${(0,r.A)(i,{includeName:!0})})`, `Data:   ${n} (${o} bytes)`]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "DecodeLogDataMismatch"
                        }), Object.defineProperty(this, "abiItem", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "data", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "params", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "size", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.abiItem = t, this.data = n, this.params = i, this.size = o
                    }
                }
                class x extends o.C {
                    constructor(e) {
                        let {
                            abiItem: t,
                            param: n
                        } = e;
                        super([`Expected a topic for indexed event parameter${n.name?` "${n.name}"`:""} on event "${(0,r.B)(t,{includeName:!0})}".`].join("\n")), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "DecodeLogTopicsMismatch"
                        }), Object.defineProperty(this, "abiItem", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.abiItem = t
                    }
                }
                class A extends o.C {
                    constructor(e, t) {
                        let {
                            docsPath: n
                        } = t;
                        super([`Type "${e}" is not a valid encoding type.`, "Please provide a valid ABI type."].join("\n"), {
                            docsPath: n
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidAbiEncodingType"
                        })
                    }
                }
                class k extends o.C {
                    constructor(e, t) {
                        let {
                            docsPath: n
                        } = t;
                        super([`Type "${e}" is not a valid decoding type.`, "Please provide a valid ABI type."].join("\n"), {
                            docsPath: n
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidAbiDecodingType"
                        })
                    }
                }
                class C extends o.C {
                    constructor(e) {
                        super([`Value "${e}" is not a valid array.`].join("\n")), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidArrayError"
                        })
                    }
                }
                class P extends o.C {
                    constructor(e) {
                        super([`"${e}" is not a valid definition type.`, 'Valid types: "function", "event", "error"'].join("\n")), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidDefinitionTypeError"
                        })
                    }
                }
                o.C
            },
            3491: (e, t, n) => {
                "use strict";
                n.d(t, {
                    M: () => i
                });
                var r = n(1370);
                class i extends r.C {
                    constructor(e) {
                        let {
                            address: t
                        } = e;
                        super(`Address "${t}" is invalid.`, {
                            metaMessages: ["- Address must be a hex value of 20 bytes (40 hex characters).", "- Address must match its checksum counterpart."]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidAddressError"
                        })
                    }
                }
            },
            1370: (e, t, n) => {
                "use strict";
                n.d(t, {
                    C: () => i
                });
                var r = n(4094);
                class i extends Error {
                    constructor(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        super(), Object.defineProperty(this, "details", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "docsPath", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "metaMessages", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "shortMessage", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ViemError"
                        }), Object.defineProperty(this, "version", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: (0, r.HF)()
                        });
                        const n = t.cause instanceof i ? t.cause.details : t.cause ? .message ? t.cause.message : t.details,
                            o = t.cause instanceof i && t.cause.docsPath || t.docsPath;
                        this.message = [e || "An error occurred.", "", ...t.metaMessages ? [...t.metaMessages, ""] : [], ...o ? [`Docs: https://viem.sh${o}${t.docsSlug?`#${t.docsSlug}`:""}`] : [], ...n ? [`Details: ${n}`] : [], `Version: ${this.version}`].join("\n"), t.cause && (this.cause = t.cause), this.details = n, this.docsPath = o, this.metaMessages = t.metaMessages, this.shortMessage = e
                    }
                    walk(e) {
                        return o(this, e)
                    }
                }

                function o(e, t) {
                    return t ? .(e) ? e : e && "object" === typeof e && "cause" in e ? o(e.cause, t) : t ? null : e
                }
            },
            6310: (e, t, n) => {
                "use strict";
                n.d(t, {
                    EH: () => o,
                    YE: () => a,
                    jF: () => s,
                    rj: () => i
                });
                var r = n(1370);
                class i extends r.C {
                    constructor(e) {
                        let {
                            blockNumber: t,
                            chain: n,
                            contract: r
                        } = e;
                        super(`Chain "${n.name}" does not support contract "${r.name}".`, {
                            metaMessages: ["This could be due to any of the following:", ...t && r.blockCreated && r.blockCreated > t ? [`- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${t}).`] : [`- The chain does not have the contract "${r.name}" configured.`]]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ChainDoesNotSupportContract"
                        })
                    }
                }
                class o extends r.C {
                    constructor(e) {
                        let {
                            chain: t,
                            currentChainId: n
                        } = e;
                        super(`The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id} \u2013 ${t.name}).`, {
                            metaMessages: [`Current Chain ID:  ${n}`, `Expected Chain ID: ${t.id} \u2013 ${t.name}`]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ChainMismatchError"
                        })
                    }
                }
                class s extends r.C {
                    constructor() {
                        super(["No chain was provided to the request.", "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."].join("\n")), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ChainNotFoundError"
                        })
                    }
                }
                class a extends r.C {
                    constructor() {
                        super("No chain was provided to the Client."), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ClientChainNotConfiguredError"
                        })
                    }
                }
                r.C
            },
            7942: (e, t, n) => {
                "use strict";
                n.d(t, {
                    zX: () => y,
                    bG: () => v,
                    M: () => b,
                    rR: () => w,
                    $S: () => E
                });
                var r = n(4034),
                    i = n(9048),
                    o = n(4745),
                    s = n(9052),
                    a = n(3512);

                function l(e) {
                    let {
                        abiItem: t,
                        args: n,
                        includeFunctionName: r = !0,
                        includeName: i = !1
                    } = e;
                    if ("name" in t && "inputs" in t && t.inputs) return `${r?t.name:""}(${t.inputs.map(((e,t)=>`${i&&e.name?`${e.name}: `:""}${"object"===typeof n[t]?(0,a.A)(n[t]):n[t]}`)).join(", ")})`
                }
                var u = n(2283),
                    c = n(1273),
                    d = n(4569),
                    h = n(7965),
                    f = n(1370),
                    p = n(1602),
                    m = n(3003),
                    g = n(4094);
                class y extends f.C {
                    constructor(e, t) {
                        let {
                            account: n,
                            docsPath: i,
                            chain: o,
                            data: s,
                            gas: a,
                            gasPrice: l,
                            maxFeePerGas: u,
                            maxPriorityFeePerGas: h,
                            nonce: f,
                            to: g,
                            value: y,
                            stateOverride: v
                        } = t;
                        const b = n ? (0, r.J)(n) : void 0;
                        let w = (0, m.aO)({
                            from: b ? .address,
                            to: g,
                            value: "undefined" !== typeof y && `${(0,c.c)(y)} ${o?.nativeCurrency?.symbol||"ETH"}`,
                            data: s,
                            gas: a,
                            gasPrice: "undefined" !== typeof l && `${(0,d.Q)(l)} gwei`,
                            maxFeePerGas: "undefined" !== typeof u && `${(0,d.Q)(u)} gwei`,
                            maxPriorityFeePerGas: "undefined" !== typeof h && `${(0,d.Q)(h)} gwei`,
                            nonce: f
                        });
                        v && (w += `\n${(0,p.uj)(v)}`), super(e.shortMessage, {
                            cause: e,
                            docsPath: i,
                            metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], "Raw Call Arguments:", w].filter(Boolean)
                        }), Object.defineProperty(this, "cause", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "CallExecutionError"
                        }), this.cause = e
                    }
                }
                class v extends f.C {
                    constructor(e, t) {
                        let {
                            abi: n,
                            args: r,
                            contractAddress: i,
                            docsPath: o,
                            functionName: a,
                            sender: c
                        } = t;
                        const d = (0, u.iY)({
                                abi: n,
                                args: r,
                                name: a
                            }),
                            h = d ? l({
                                abiItem: d,
                                args: r,
                                includeFunctionName: !1,
                                includeName: !1
                            }) : void 0,
                            f = d ? (0, s.B)(d, {
                                includeName: !0
                            }) : void 0,
                            p = (0, m.aO)({
                                address: i && (0, g.RZ)(i),
                                function: f,
                                args: h && "()" !== h && `${[...Array(a?.length??0).keys()].map((()=>" ")).join("")}${h}`,
                                sender: c
                            });
                        super(e.shortMessage || `An unknown error occurred while executing the contract function "${a}".`, {
                            cause: e,
                            docsPath: o,
                            metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], "Contract Call:", p].filter(Boolean)
                        }), Object.defineProperty(this, "abi", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "args", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "cause", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "contractAddress", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "formattedArgs", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "functionName", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "sender", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ContractFunctionExecutionError"
                        }), this.abi = n, this.args = r, this.cause = e, this.contractAddress = i, this.functionName = a, this.sender = c
                    }
                }
                class b extends f.C {
                    constructor(e) {
                        let t, n, r, a, u, {
                            abi: c,
                            data: d,
                            functionName: f,
                            message: p
                        } = e;
                        if (d && "0x" !== d) try {
                            n = (0, o.W)({
                                abi: c,
                                data: d
                            });
                            const {
                                abiItem: e,
                                errorName: t,
                                args: u
                            } = n;
                            if ("Error" === t) a = u[0];
                            else if ("Panic" === t) {
                                const [e] = u;
                                a = i.fD[e]
                            } else {
                                const n = e ? (0, s.B)(e, {
                                        includeName: !0
                                    }) : void 0,
                                    i = e && u ? l({
                                        abiItem: e,
                                        args: u,
                                        includeFunctionName: !1,
                                        includeName: !1
                                    }) : void 0;
                                r = [n ? `Error: ${n}` : "", i && "()" !== i ? `       ${[...Array(t?.length??0).keys()].map((()=>" ")).join("")}${i}` : ""]
                            }
                        } catch (m) {
                            t = m
                        } else p && (a = p);
                        t instanceof h.Wq && (u = t.signature, r = [`Unable to decode signature "${u}" as it was not found on the provided ABI.`, "Make sure you are using the correct ABI and that the error exists on it.", `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${u}.`]), super(a && "execution reverted" !== a || u ? [`The contract function "${f}" reverted with the following ${u?"signature":"reason"}:`, a || u].join("\n") : `The contract function "${f}" reverted.`, {
                            cause: t,
                            metaMessages: r
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ContractFunctionRevertedError"
                        }), Object.defineProperty(this, "data", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "reason", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "signature", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.data = n, this.reason = a, this.signature = u
                    }
                }
                class w extends f.C {
                    constructor(e) {
                        let {
                            functionName: t
                        } = e;
                        super(`The contract function "${t}" returned no data ("0x").`, {
                            metaMessages: ["This could be due to any of the following:", `  - The contract does not have the function "${t}",`, "  - The parameters passed to the contract function may be invalid, or", "  - The address is not a contract."]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ContractFunctionZeroDataError"
                        })
                    }
                }
                class E extends f.C {
                    constructor(e) {
                        let {
                            data: t,
                            message: n
                        } = e;
                        super(n || ""), Object.defineProperty(this, "code", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: 3
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "RawContractError"
                        }), Object.defineProperty(this, "data", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.data = t
                    }
                }
            },
            9577: (e, t, n) => {
                "use strict";
                n.d(t, {
                    B4: () => i,
                    SK: () => o,
                    hX: () => s
                });
                var r = n(1370);
                class i extends r.C {
                    constructor(e) {
                        let {
                            offset: t
                        } = e;
                        super(`Offset \`${t}\` cannot be negative.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "NegativeOffsetError"
                        })
                    }
                }
                class o extends r.C {
                    constructor(e) {
                        let {
                            length: t,
                            position: n
                        } = e;
                        super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "PositionOutOfBoundsError"
                        })
                    }
                }
                class s extends r.C {
                    constructor(e) {
                        let {
                            count: t,
                            limit: n
                        } = e;
                        super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "RecursiveReadLimitExceededError"
                        })
                    }
                }
            },
            4603: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Fl: () => o,
                    NV: () => s,
                    ii: () => i
                });
                var r = n(1370);
                class i extends r.C {
                    constructor(e) {
                        let {
                            offset: t,
                            position: n,
                            size: r
                        } = e;
                        super(`Slice ${"start"===n?"starting":"ending"} at offset "${t}" is out-of-bounds (size: ${r}).`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "SliceOffsetOutOfBoundsError"
                        })
                    }
                }
                class o extends r.C {
                    constructor(e) {
                        let {
                            size: t,
                            targetSize: n,
                            type: r
                        } = e;
                        super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "SizeExceedsPaddingSizeError"
                        })
                    }
                }
                class s extends r.C {
                    constructor(e) {
                        let {
                            size: t,
                            targetSize: n,
                            type: r
                        } = e;
                        super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${t} ${r} long.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidBytesLengthError"
                        })
                    }
                }
            },
            3458: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Ty: () => i,
                    u: () => s,
                    xO: () => o
                });
                var r = n(1370);
                class i extends r.C {
                    constructor(e) {
                        let {
                            max: t,
                            min: n,
                            signed: r,
                            size: i,
                            value: o
                        } = e;
                        super(`Number "${o}" is not in safe ${i?`${8*i}-bit ${r?"signed":"unsigned"} `:""}integer range ${t?`(${n} to ${t})`:`(above ${n})`}`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "IntegerOutOfRangeError"
                        })
                    }
                }
                class o extends r.C {
                    constructor(e) {
                        super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidBytesBooleanError"
                        })
                    }
                }
                r.C;
                r.C;
                class s extends r.C {
                    constructor(e) {
                        let {
                            givenSize: t,
                            maxSize: n
                        } = e;
                        super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "SizeOverflowError"
                        })
                    }
                }
            },
            2343: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A7: () => o,
                    BG: () => s,
                    Fo: () => f,
                    K0: () => l,
                    Oh: () => u,
                    RM: () => g,
                    jj: () => a,
                    k5: () => d,
                    lN: () => m,
                    lY: () => h,
                    uC: () => p,
                    vW: () => c
                });
                var r = n(4569),
                    i = n(1370);
                class o extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            message: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        const n = t ? .replace("execution reverted: ", "") ? .replace("execution reverted", "");
                        super(`Execution reverted ${n?`with reason: ${n}`:"for an unknown reason"}.`, {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "ExecutionRevertedError"
                        })
                    }
                }
                Object.defineProperty(o, "code", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 3
                }), Object.defineProperty(o, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /execution reverted/
                });
                class s extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            maxFeePerGas: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super(`The fee cap (\`maxFeePerGas\`${t?` = ${(0,r.Q)(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`, {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "FeeCapTooHigh"
                        })
                    }
                }
                Object.defineProperty(s, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
                });
                class a extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            maxFeePerGas: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super(`The fee cap (\`maxFeePerGas\`${t?` = ${(0,r.Q)(t)}`:""} gwei) cannot be lower than the block base fee.`, {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "FeeCapTooLow"
                        })
                    }
                }
                Object.defineProperty(a, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
                });
                class l extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            nonce: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`, {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "NonceTooHighError"
                        })
                    }
                }
                Object.defineProperty(l, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /nonce too high/
                });
                class u extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            nonce: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`, "Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"), {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "NonceTooLowError"
                        })
                    }
                }
                Object.defineProperty(u, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /nonce too low|transaction already imported|already known/
                });
                class c extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            nonce: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`, {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "NonceMaxValueError"
                        })
                    }
                }
                Object.defineProperty(c, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /nonce has max value/
                });
                class d extends i.C {
                    constructor() {
                        let {
                            cause: e
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"), {
                            cause: e,
                            metaMessages: ["This error could arise when the account does not have enough funds to:", " - pay for the total gas fee,", " - pay for the value to send.", " ", "The cost of the transaction is calculated as `gas * gas fee + value`, where:", " - `gas` is the amount of gas needed for transaction to execute,", " - `gas fee` is the gas fee,", " - `value` is the amount of ether to send to the recipient."]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InsufficientFundsError"
                        })
                    }
                }
                Object.defineProperty(d, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /insufficient funds/
                });
                class h extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            gas: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`, {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "IntrinsicGasTooHighError"
                        })
                    }
                }
                Object.defineProperty(h, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /intrinsic gas too high|gas limit reached/
                });
                class f extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            gas: t
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`, {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "IntrinsicGasTooLowError"
                        })
                    }
                }
                Object.defineProperty(f, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /intrinsic gas too low/
                });
                class p extends i.C {
                    constructor(e) {
                        let {
                            cause: t
                        } = e;
                        super("The transaction type is not supported for this chain.", {
                            cause: t
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "TransactionTypeNotSupportedError"
                        })
                    }
                }
                Object.defineProperty(p, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /transaction type not valid/
                });
                class m extends i.C {
                    constructor() {
                        let {
                            cause: e,
                            maxPriorityFeePerGas: t,
                            maxFeePerGas: n
                        } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${(0,r.Q)(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n?` = ${(0,r.Q)(n)} gwei`:""}).`].join("\n"), {
                            cause: e
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "TipAboveFeeCapError"
                        })
                    }
                }
                Object.defineProperty(m, "nodeMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
                });
                class g extends i.C {
                    constructor(e) {
                        let {
                            cause: t
                        } = e;
                        super(`An error occurred while executing: ${t?.shortMessage}`, {
                            cause: t
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "UnknownNodeError"
                        })
                    }
                }
            },
            2494: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Ci: () => s,
                    J8: () => a,
                    MU: () => l
                });
                var r = n(3512),
                    i = n(1370),
                    o = n(4094);
                class s extends i.C {
                    constructor(e) {
                        let {
                            body: t,
                            details: n,
                            headers: i,
                            status: s,
                            url: a
                        } = e;
                        super("HTTP request failed.", {
                            details: n,
                            metaMessages: [s && `Status: ${s}`, `URL: ${(0,o.ID)(a)}`, t && `Request body: ${(0,r.A)(t)}`].filter(Boolean)
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "HttpRequestError"
                        }), Object.defineProperty(this, "body", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "headers", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "status", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "url", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.body = t, this.headers = i, this.status = s, this.url = a
                    }
                }
                i.C;
                class a extends i.C {
                    constructor(e) {
                        let {
                            body: t,
                            error: n,
                            url: i
                        } = e;
                        super("RPC Request failed.", {
                            cause: n,
                            details: n.message,
                            metaMessages: [`URL: ${(0,o.ID)(i)}`, `Request body: ${(0,r.A)(t)}`]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "RpcRequestError"
                        }), Object.defineProperty(this, "code", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.code = n.code
                    }
                }
                class l extends i.C {
                    constructor(e) {
                        let {
                            body: t,
                            url: n
                        } = e;
                        super("The request took too long to respond.", {
                            details: "The request timed out.",
                            metaMessages: [`URL: ${(0,o.ID)(n)}`, `Request body: ${(0,r.A)(t)}`]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "TimeoutError"
                        })
                    }
                }
            },
            1602: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Hi: () => i,
                    ft: () => o,
                    uj: () => a
                });
                var r = n(1370);
                class i extends r.C {
                    constructor(e) {
                        let {
                            address: t
                        } = e;
                        super(`State for account "${t}" is set multiple times.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "AccountStateConflictError"
                        })
                    }
                }
                class o extends r.C {
                    constructor() {
                        super("state and stateDiff are set on the same account."), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "StateAssignmentConflictError"
                        })
                    }
                }

                function s(e) {
                    return e.reduce(((e, t) => {
                        let {
                            slot: n,
                            value: r
                        } = t;
                        return `${e}        ${n}: ${r}\n`
                    }), "")
                }

                function a(e) {
                    return e.reduce(((e, t) => {
                        let {
                            address: n,
                            ...r
                        } = t, i = `${e}    ${n}:\n`;
                        return r.nonce && (i += `      nonce: ${r.nonce}\n`), r.balance && (i += `      balance: ${r.balance}\n`), r.code && (i += `      code: ${r.code}\n`), r.state && (i += "      state:\n", i += s(r.state)), r.stateDiff && (i += "      stateDiff:\n", i += s(r.stateDiff)), i
                    }), "  State Override:\n").slice(0, -1)
                }
            },
            3003: (e, t, n) => {
                "use strict";
                n.d(t, {
                    $s: () => u,
                    Kc: () => d,
                    Kz: () => c,
                    Vg: () => l,
                    WA: () => h,
                    aO: () => s,
                    n3: () => a
                });
                var r = n(1273),
                    i = n(4569),
                    o = n(1370);

                function s(e) {
                    const t = Object.entries(e).map((e => {
                            let [t, n] = e;
                            return void 0 === n || !1 === n ? null : [t, n]
                        })).filter(Boolean),
                        n = t.reduce(((e, t) => {
                            let [n] = t;
                            return Math.max(e, n.length)
                        }), 0);
                    return t.map((e => {
                        let [t, r] = e;
                        return `  ${`${t}:`.padEnd(n+1)}  ${r}`
                    })).join("\n")
                }
                class a extends o.C {
                    constructor() {
                        super(["Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.", "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."].join("\n")), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "FeeConflictError"
                        })
                    }
                }
                o.C;
                class l extends o.C {
                    constructor(e) {
                        let {
                            transaction: t
                        } = e;
                        super("Cannot infer a transaction type from provided transaction.", {
                            metaMessages: ["Provided Transaction:", "{", s(t), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or", "- a Legacy Transaction with `gasPrice`"]
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "InvalidSerializableTransactionError"
                        })
                    }
                }
                o.C;
                o.C;
                o.C;
                class u extends o.C {
                    constructor(e, t) {
                        let {
                            account: n,
                            docsPath: o,
                            chain: a,
                            data: l,
                            gas: u,
                            gasPrice: c,
                            maxFeePerGas: d,
                            maxPriorityFeePerGas: h,
                            nonce: f,
                            to: p,
                            value: m
                        } = t;
                        const g = s({
                            chain: a && `${a?.name} (id: ${a?.id})`,
                            from: n ? .address,
                            to: p,
                            value: "undefined" !== typeof m && `${(0,r.c)(m)} ${a?.nativeCurrency?.symbol||"ETH"}`,
                            data: l,
                            gas: u,
                            gasPrice: "undefined" !== typeof c && `${(0,i.Q)(c)} gwei`,
                            maxFeePerGas: "undefined" !== typeof d && `${(0,i.Q)(d)} gwei`,
                            maxPriorityFeePerGas: "undefined" !== typeof h && `${(0,i.Q)(h)} gwei`,
                            nonce: f
                        });
                        super(e.shortMessage, {
                            cause: e,
                            docsPath: o,
                            metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], "Request Arguments:", g].filter(Boolean)
                        }), Object.defineProperty(this, "cause", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "TransactionExecutionError"
                        }), this.cause = e
                    }
                }
                class c extends o.C {
                    constructor(e) {
                        let {
                            blockHash: t,
                            blockNumber: n,
                            blockTag: r,
                            hash: i,
                            index: o
                        } = e, s = "Transaction";
                        r && void 0 !== o && (s = `Transaction at block time "${r}" at index "${o}"`), t && void 0 !== o && (s = `Transaction at block hash "${t}" at index "${o}"`), n && void 0 !== o && (s = `Transaction at block number "${n}" at index "${o}"`), i && (s = `Transaction with hash "${i}"`), super(`${s} could not be found.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "TransactionNotFoundError"
                        })
                    }
                }
                class d extends o.C {
                    constructor(e) {
                        let {
                            hash: t
                        } = e;
                        super(`Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "TransactionReceiptNotFoundError"
                        })
                    }
                }
                class h extends o.C {
                    constructor(e) {
                        let {
                            hash: t
                        } = e;
                        super(`Timed out while waiting for transaction with hash "${t}" to be confirmed.`), Object.defineProperty(this, "name", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: "WaitForTransactionReceiptTimeoutError"
                        })
                    }
                }
            },
            4094: (e, t, n) => {
                "use strict";
                n.d(t, {
                    RZ: () => r,
                    ID: () => i,
                    HF: () => o
                });
                const r = e => e,
                    i = e => e,
                    o = () => "viem@2.9.31"
            },
            3206: (e, t, n) => {
                "use strict";
                n.d(t, {
                    n: () => v
                });
                var r = n(7965),
                    i = n(3028),
                    o = n(751),
                    s = n(2017),
                    a = n(6220),
                    l = n(8604),
                    u = n(3458),
                    c = n(7962),
                    d = n(4117);

                function h(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    "undefined" !== typeof t.size && (0, c.Sl)(e, {
                        size: t.size
                    });
                    const n = (0, d.My)(e, t);
                    return (0, c.uU)(n, t)
                }

                function f(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = e;
                    if ("undefined" !== typeof t.size && ((0, c.Sl)(n, {
                            size: t.size
                        }), n = (0, l.B)(n)), n.length > 1 || n[0] > 1) throw new u.xO(n);
                    return Boolean(n[0])
                }

                function p(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    "undefined" !== typeof t.size && (0, c.Sl)(e, {
                        size: t.size
                    });
                    const n = (0, d.My)(e, t);
                    return (0, c.ME)(n, t)
                }

                function m(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = e;
                    return "undefined" !== typeof t.size && ((0, c.Sl)(n, {
                        size: t.size
                    }), n = (0, l.B)(n, {
                        dir: "right"
                    })), (new TextDecoder).decode(n)
                }
                var g = n(7131),
                    y = n(1376);

                function v(e, t) {
                    const n = "string" === typeof t ? (0, g.aT)(t) : t,
                        i = (0, o.l)(n);
                    if (0 === (0, s.E)(n) && e.length > 0) throw new r.O;
                    if ((0, s.E)(t) && (0, s.E)(t) < 32) throw new r.Iy({
                        data: "string" === typeof t ? t : (0, d.My)(t),
                        params: e,
                        size: (0, s.E)(t)
                    });
                    let a = 0;
                    const l = [];
                    for (let r = 0; r < e.length; ++r) {
                        const t = e[r];
                        i.setPosition(a);
                        const [n, o] = b(i, t, {
                            staticPosition: 0
                        });
                        a += o, l.push(n)
                    }
                    return l
                }

                function b(e, t, n) {
                    let {
                        staticPosition: o
                    } = n;
                    const s = (0, y.k)(t.type);
                    if (s) {
                        const [n, r] = s;
                        return function(e, t, n) {
                            let {
                                length: r,
                                staticPosition: i
                            } = n;
                            if (!r) {
                                const n = i + p(e.readBytes(E)),
                                    r = n + w;
                                e.setPosition(n);
                                const o = p(e.readBytes(w)),
                                    s = x(t);
                                let a = 0;
                                const l = [];
                                for (let i = 0; i < o; ++i) {
                                    e.setPosition(r + (s ? 32 * i : a));
                                    const [n, o] = b(e, t, {
                                        staticPosition: r
                                    });
                                    a += o, l.push(n)
                                }
                                return e.setPosition(i + 32), [l, 32]
                            }
                            if (x(t)) {
                                const n = i + p(e.readBytes(E)),
                                    o = [];
                                for (let i = 0; i < r; ++i) {
                                    e.setPosition(n + 32 * i);
                                    const [r] = b(e, t, {
                                        staticPosition: n
                                    });
                                    o.push(r)
                                }
                                return e.setPosition(i + 32), [o, 32]
                            }
                            let o = 0;
                            const s = [];
                            for (let a = 0; a < r; ++a) {
                                const [n, r] = b(e, t, {
                                    staticPosition: i + o
                                });
                                o += r, s.push(n)
                            }
                            return [s, o]
                        }(e, { ...t,
                            type: r
                        }, {
                            length: n,
                            staticPosition: o
                        })
                    }
                    if ("tuple" === t.type) return function(e, t, n) {
                        let {
                            staticPosition: r
                        } = n;
                        const i = 0 === t.components.length || t.components.some((e => {
                                let {
                                    name: t
                                } = e;
                                return !t
                            })),
                            o = i ? [] : {};
                        let s = 0;
                        if (x(t)) {
                            const n = r + p(e.readBytes(E));
                            for (let r = 0; r < t.components.length; ++r) {
                                const a = t.components[r];
                                e.setPosition(n + s);
                                const [l, u] = b(e, a, {
                                    staticPosition: n
                                });
                                s += u, o[i ? r : a ? .name] = l
                            }
                            return e.setPosition(r + 32), [o, 32]
                        }
                        for (let a = 0; a < t.components.length; ++a) {
                            const n = t.components[a],
                                [l, u] = b(e, n, {
                                    staticPosition: r
                                });
                            o[i ? a : n ? .name] = l, s += u
                        }
                        return [o, s]
                    }(e, t, {
                        staticPosition: o
                    });
                    if ("address" === t.type) return function(e) {
                        const t = e.readBytes(32);
                        return [(0, i.o)((0, d.My)((0, a.A1)(t, -20))), 32]
                    }(e);
                    if ("bool" === t.type) return function(e) {
                        return [f(e.readBytes(32), {
                            size: 32
                        }), 32]
                    }(e);
                    if (t.type.startsWith("bytes")) return function(e, t, n) {
                        let {
                            staticPosition: r
                        } = n;
                        const [i, o] = t.type.split("bytes");
                        if (!o) {
                            const t = p(e.readBytes(32));
                            e.setPosition(r + t);
                            const n = p(e.readBytes(32));
                            if (0 === n) return e.setPosition(r + 32), ["0x", 32];
                            const i = e.readBytes(n);
                            return e.setPosition(r + 32), [(0, d.My)(i), 32]
                        }
                        const s = (0, d.My)(e.readBytes(parseInt(o), 32));
                        return [s, 32]
                    }(e, t, {
                        staticPosition: o
                    });
                    if (t.type.startsWith("uint") || t.type.startsWith("int")) return function(e, t) {
                        const n = t.type.startsWith("int"),
                            r = parseInt(t.type.split("int")[1] || "256"),
                            i = e.readBytes(32);
                        return [r > 48 ? h(i, {
                            signed: n
                        }) : p(i, {
                            signed: n
                        }), 32]
                    }(e, t);
                    if ("string" === t.type) return function(e, t) {
                        let {
                            staticPosition: n
                        } = t;
                        const r = p(e.readBytes(32)),
                            i = n + r;
                        e.setPosition(i);
                        const o = p(e.readBytes(32));
                        if (0 === o) return e.setPosition(n + 32), ["", 32];
                        const s = e.readBytes(o, 32),
                            a = m((0, l.B)(s));
                        return e.setPosition(n + 32), [a, 32]
                    }(e, {
                        staticPosition: o
                    });
                    throw new r.j(t.type, {
                        docsPath: "/docs/contract/decodeAbiParameters"
                    })
                }
                const w = 32,
                    E = 32;

                function x(e) {
                    const {
                        type: t
                    } = e;
                    if ("string" === t) return !0;
                    if ("bytes" === t) return !0;
                    if (t.endsWith("[]")) return !0;
                    if ("tuple" === t) return e.components ? .some(x);
                    const n = (0, y.k)(e.type);
                    return !(!n || !x({ ...e,
                        type: n[1]
                    }))
                }
            },
            4745: (e, t, n) => {
                "use strict";
                n.d(t, {
                    W: () => u
                });
                var r = n(9048),
                    i = n(7965),
                    o = n(6220),
                    s = n(3924),
                    a = n(3206),
                    l = n(9052);

                function u(e) {
                    const {
                        abi: t,
                        data: n
                    } = e, u = (0, o.di)(n, 0, 4);
                    if ("0x" === u) throw new i.O;
                    const c = [...t || [], r.Mc, r.J9].find((e => "error" === e.type && u === (0, s.V)((0, l.B)(e))));
                    if (!c) throw new i.Wq(u, {
                        docsPath: "/docs/contract/decodeErrorResult"
                    });
                    return {
                        abiItem: c,
                        args: "inputs" in c && c.inputs && c.inputs.length > 0 ? (0, a.n)(c.inputs, (0, o.di)(n, 4)) : void 0,
                        errorName: c.name
                    }
                }
            },
            1313: (e, t, n) => {
                "use strict";
                n.d(t, {
                    e: () => a
                });
                var r = n(7965),
                    i = n(3206),
                    o = n(2283);
                const s = "/docs/contract/decodeFunctionResult";

                function a(e) {
                    const {
                        abi: t,
                        args: n,
                        functionName: a,
                        data: l
                    } = e;
                    let u = t[0];
                    if (a) {
                        const e = (0, o.iY)({
                            abi: t,
                            args: n,
                            name: a
                        });
                        if (!e) throw new r.Iz(a, {
                            docsPath: s
                        });
                        u = e
                    }
                    if ("function" !== u.type) throw new r.Iz(void 0, {
                        docsPath: s
                    });
                    if (!u.outputs) throw new r.MR(u.name, {
                        docsPath: s
                    });
                    const c = (0, i.n)(u.outputs, l);
                    return c && c.length > 1 ? c : c && 1 === c.length ? c[0] : void 0
                }
            },
            1376: (e, t, n) => {
                "use strict";
                n.d(t, {
                    h: () => h,
                    k: () => m
                });
                var r = n(7965),
                    i = n(3491),
                    o = n(1370),
                    s = n(3556),
                    a = n(2620),
                    l = n(7143),
                    u = n(2017),
                    c = n(6220),
                    d = n(4117);

                function h(e, t) {
                    if (e.length !== t.length) throw new r.YE({
                        expectedLength: e.length,
                        givenLength: t.length
                    });
                    const n = function(e) {
                            let {
                                params: t,
                                values: n
                            } = e;
                            const r = [];
                            for (let i = 0; i < t.length; i++) r.push(f({
                                param: t[i],
                                value: n[i]
                            }));
                            return r
                        }({
                            params: e,
                            values: t
                        }),
                        i = p(n);
                    return 0 === i.length ? "0x" : i
                }

                function f(e) {
                    let {
                        param: t,
                        value: n
                    } = e;
                    const h = m(t.type);
                    if (h) {
                        const [e, i] = h;
                        return function(e, t) {
                            let {
                                length: n,
                                param: i
                            } = t;
                            const o = null === n;
                            if (!Array.isArray(e)) throw new r.dm(e);
                            if (!o && e.length !== n) throw new r.Nc({
                                expectedLength: n,
                                givenLength: e.length,
                                type: `${i.type}[${n}]`
                            });
                            let s = !1;
                            const l = [];
                            for (let r = 0; r < e.length; r++) {
                                const t = f({
                                    param: i,
                                    value: e[r]
                                });
                                t.dynamic && (s = !0), l.push(t)
                            }
                            if (o || s) {
                                const e = p(l);
                                if (o) {
                                    const t = (0, d.cK)(l.length, {
                                        size: 32
                                    });
                                    return {
                                        dynamic: !0,
                                        encoded: l.length > 0 ? (0, a.xW)([t, e]) : t
                                    }
                                }
                                if (s) return {
                                    dynamic: !0,
                                    encoded: e
                                }
                            }
                            return {
                                dynamic: !1,
                                encoded: (0, a.xW)(l.map((e => {
                                    let {
                                        encoded: t
                                    } = e;
                                    return t
                                })))
                            }
                        }(n, {
                            length: e,
                            param: { ...t,
                                type: i
                            }
                        })
                    }
                    if ("tuple" === t.type) return function(e, t) {
                        let {
                            param: n
                        } = t, r = !1;
                        const i = [];
                        for (let o = 0; o < n.components.length; o++) {
                            const t = n.components[o],
                                s = f({
                                    param: t,
                                    value: e[Array.isArray(e) ? o : t.name]
                                });
                            i.push(s), s.dynamic && (r = !0)
                        }
                        return {
                            dynamic: r,
                            encoded: r ? p(i) : (0, a.xW)(i.map((e => {
                                let {
                                    encoded: t
                                } = e;
                                return t
                            })))
                        }
                    }(n, {
                        param: t
                    });
                    if ("address" === t.type) return function(e) {
                        if (!(0, s.P)(e)) throw new i.M({
                            address: e
                        });
                        return {
                            dynamic: !1,
                            encoded: (0, l.db)(e.toLowerCase())
                        }
                    }(n);
                    if ("bool" === t.type) return function(e) {
                        if ("boolean" !== typeof e) throw new o.C(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);
                        return {
                            dynamic: !1,
                            encoded: (0, l.db)((0, d.$P)(e))
                        }
                    }(n);
                    if (t.type.startsWith("uint") || t.type.startsWith("int")) {
                        return function(e, t) {
                            let {
                                signed: n
                            } = t;
                            return {
                                dynamic: !1,
                                encoded: (0, d.cK)(e, {
                                    size: 32,
                                    signed: n
                                })
                            }
                        }(n, {
                            signed: t.type.startsWith("int")
                        })
                    }
                    if (t.type.startsWith("bytes")) return function(e, t) {
                        let {
                            param: n
                        } = t;
                        const [, i] = n.type.split("bytes"), o = (0, u.E)(e);
                        if (!i) {
                            let t = e;
                            return o % 32 !== 0 && (t = (0, l.db)(t, {
                                dir: "right",
                                size: 32 * Math.ceil((e.length - 2) / 2 / 32)
                            })), {
                                dynamic: !0,
                                encoded: (0, a.xW)([(0, l.db)((0, d.cK)(o, {
                                    size: 32
                                })), t])
                            }
                        }
                        if (o !== parseInt(i)) throw new r.gH({
                            expectedSize: parseInt(i),
                            value: e
                        });
                        return {
                            dynamic: !1,
                            encoded: (0, l.db)(e, {
                                dir: "right"
                            })
                        }
                    }(n, {
                        param: t
                    });
                    if ("string" === t.type) return function(e) {
                        const t = (0, d.i3)(e),
                            n = Math.ceil((0, u.E)(t) / 32),
                            r = [];
                        for (let i = 0; i < n; i++) r.push((0, l.db)((0, c.di)(t, 32 * i, 32 * (i + 1)), {
                            dir: "right"
                        }));
                        return {
                            dynamic: !0,
                            encoded: (0, a.xW)([(0, l.db)((0, d.cK)((0, u.E)(t), {
                                size: 32
                            })), ...r])
                        }
                    }(n);
                    throw new r.nK(t.type, {
                        docsPath: "/docs/contract/encodeAbiParameters"
                    })
                }

                function p(e) {
                    let t = 0;
                    for (let o = 0; o < e.length; o++) {
                        const {
                            dynamic: n,
                            encoded: r
                        } = e[o];
                        t += n ? 32 : (0, u.E)(r)
                    }
                    const n = [],
                        r = [];
                    let i = 0;
                    for (let o = 0; o < e.length; o++) {
                        const {
                            dynamic: s,
                            encoded: a
                        } = e[o];
                        s ? (n.push((0, d.cK)(t + i, {
                            size: 32
                        })), r.push(a), i += (0, u.E)(a)) : n.push(a)
                    }
                    return (0, a.xW)([...n, ...r])
                }

                function m(e) {
                    const t = e.match(/^(.*)\[(\d+)?\]$/);
                    return t ? [t[2] ? Number(t[2]) : null, t[1]] : void 0
                }
            },
            7908: (e, t, n) => {
                "use strict";
                n.d(t, {
                    p: () => c
                });
                var r = n(2620),
                    i = n(1376),
                    o = n(7965),
                    s = n(3924),
                    a = n(9052),
                    l = n(2283);
                const u = "/docs/contract/encodeFunctionData";

                function c(e) {
                    const {
                        args: t
                    } = e, {
                        abi: n,
                        functionName: c
                    } = 1 === e.abi.length && e.functionName ? .startsWith("0x") ? e : function(e) {
                        const {
                            abi: t,
                            args: n,
                            functionName: r
                        } = e;
                        let i = t[0];
                        if (r) {
                            const e = (0, l.iY)({
                                abi: t,
                                args: n,
                                name: r
                            });
                            if (!e) throw new o.Iz(r, {
                                docsPath: u
                            });
                            i = e
                        }
                        if ("function" !== i.type) throw new o.Iz(void 0, {
                            docsPath: u
                        });
                        return {
                            abi: [i],
                            functionName: (0, s.V)((0, a.B)(i))
                        }
                    }(e), d = n[0], h = c, f = "inputs" in d && d.inputs ? (0, i.h)(d.inputs, t ? ? []) : void 0;
                    return (0, r.aP)([h, f ? ? "0x"])
                }
            },
            9052: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => o,
                    B: () => i
                });
                var r = n(7965);

                function i(e) {
                    let {
                        includeName: t = !1
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if ("function" !== e.type && "event" !== e.type && "error" !== e.type) throw new r.d_(e.type);
                    return `${e.name}(${o(e.inputs,{includeName:t})})`
                }

                function o(e) {
                    let {
                        includeName: t = !1
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return e ? e.map((e => function(e, t) {
                        let {
                            includeName: n
                        } = t;
                        if (e.type.startsWith("tuple")) return `(${o(e.components,{includeName:n})})${e.type.slice(5)}`;
                        return e.type + (n && e.name ? ` ${e.name}` : "")
                    }(e, {
                        includeName: t
                    }))).join(t ? ", " : ",") : ""
                }
            },
            2283: (e, t, n) => {
                "use strict";
                n.d(t, {
                    iY: () => l
                });
                var r = n(7965),
                    i = n(1499),
                    o = n(3556),
                    s = n(284),
                    a = n(3924);

                function l(e) {
                    const {
                        abi: t,
                        args: n = [],
                        name: o
                    } = e, l = (0, i.q)(o, {
                        strict: !1
                    }), d = t.filter((e => l ? "function" === e.type ? (0, a.V)(e) === o : "event" === e.type && (0, s.h)(e) === o : "name" in e && e.name === o));
                    if (0 === d.length) return;
                    if (1 === d.length) return d[0];
                    let h;
                    for (const i of d) {
                        if (!("inputs" in i)) continue;
                        if (!n || 0 === n.length) {
                            if (!i.inputs || 0 === i.inputs.length) return i;
                            continue
                        }
                        if (!i.inputs) continue;
                        if (0 === i.inputs.length) continue;
                        if (i.inputs.length !== n.length) continue;
                        if (n.every(((e, t) => {
                                const n = "inputs" in i && i.inputs[t];
                                return !!n && u(e, n)
                            }))) {
                            if (h && "inputs" in h && h.inputs) {
                                const e = c(i.inputs, h.inputs, n);
                                if (e) throw new r.nM({
                                    abiItem: i,
                                    type: e[0]
                                }, {
                                    abiItem: h,
                                    type: e[1]
                                })
                            }
                            h = i
                        }
                    }
                    return h || d[0]
                }

                function u(e, t) {
                    const n = typeof e,
                        r = t.type;
                    switch (r) {
                        case "address":
                            return (0, o.P)(e, {
                                strict: !1
                            });
                        case "bool":
                            return "boolean" === n;
                        case "function":
                        case "string":
                            return "string" === n;
                        default:
                            return "tuple" === r && "components" in t ? Object.values(t.components).every(((t, n) => u(Object.values(e)[n], t))) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r) ? "number" === n || "bigint" === n : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r) ? "string" === n || e instanceof Uint8Array : !!/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r) && (Array.isArray(e) && e.every((e => u(e, { ...t,
                                type: r.replace(/(\[[0-9]{0,}\])$/, "")
                            }))))
                    }
                }

                function c(e, t, n) {
                    for (const r in e) {
                        const i = e[r],
                            s = t[r];
                        if ("tuple" === i.type && "tuple" === s.type && "components" in i && "components" in s) return c(i.components, s.components, n[r]);
                        const a = [i.type, s.type];
                        if (!(!a.includes("address") || !a.includes("bytes20")) || (a.includes("address") && a.includes("string") || !(!a.includes("address") || !a.includes("bytes"))) && (0, o.P)(n[r], {
                                strict: !1
                            })) return a
                    }
                }
            },
            3028: (e, t, n) => {
                "use strict";
                n.d(t, {
                    b: () => l,
                    o: () => a
                });
                var r = n(3491),
                    i = n(7131),
                    o = n(1064),
                    s = n(3556);

                function a(e, t) {
                    const n = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
                        r = (0, o.S)((0, i.Af)(n), "bytes"),
                        s = (t ? n.substring(`${t}0x`.length) : n).split("");
                    for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && s[i] && (s[i] = s[i].toUpperCase()), (15 & r[i >> 1]) >= 8 && s[i + 1] && (s[i + 1] = s[i + 1].toUpperCase());
                    return `0x${s.join("")}`
                }

                function l(e, t) {
                    if (!(0, s.P)(e, {
                            strict: !1
                        })) throw new r.M({
                        address: e
                    });
                    return a(e, t)
                }
            },
            3556: (e, t, n) => {
                "use strict";
                n.d(t, {
                    P: () => a
                });
                class r extends Map {
                    constructor(e) {
                        super(), Object.defineProperty(this, "maxSize", {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: void 0
                        }), this.maxSize = e
                    }
                    set(e, t) {
                        return super.set(e, t), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this
                    }
                }
                var i = n(3028);
                const o = /^0x[a-fA-F0-9]{40}$/,
                    s = new r(8192);

                function a(e, t) {
                    const {
                        strict: n = !0
                    } = t ? ? {};
                    if (s.has(e)) return s.get(e);
                    const r = !!o.test(e) && (e.toLowerCase() === e || !n || (0, i.o)(e) === e);
                    return s.set(e, r), r
                }
            },
            1898: (e, t, n) => {
                "use strict";
                n.d(t, {
                    M: () => i
                });
                var r = n(6310);

                function i(e) {
                    let {
                        blockNumber: t,
                        chain: n,
                        contract: i
                    } = e;
                    const o = n ? .contracts ? .[i];
                    if (!o) throw new r.rj({
                        chain: n,
                        contract: {
                            name: i
                        }
                    });
                    if (t && o.blockCreated && o.blockCreated > t) throw new r.rj({
                        blockNumber: t,
                        chain: n,
                        contract: {
                            name: i,
                            blockCreated: o.blockCreated
                        }
                    });
                    return o.address
                }
            },
            751: (e, t, n) => {
                "use strict";
                n.d(t, {
                    l: () => o
                });
                var r = n(9577);
                const i = {
                    bytes: new Uint8Array,
                    dataView: new DataView(new ArrayBuffer(0)),
                    position: 0,
                    positionReadCount: new Map,
                    recursiveReadCount: 0,
                    recursiveReadLimit: 1 / 0,
                    assertReadLimit() {
                        if (this.recursiveReadCount >= this.recursiveReadLimit) throw new r.hX({
                            count: this.recursiveReadCount + 1,
                            limit: this.recursiveReadLimit
                        })
                    },
                    assertPosition(e) {
                        if (e < 0 || e > this.bytes.length - 1) throw new r.SK({
                            length: this.bytes.length,
                            position: e
                        })
                    },
                    decrementPosition(e) {
                        if (e < 0) throw new r.B4({
                            offset: e
                        });
                        const t = this.position - e;
                        this.assertPosition(t), this.position = t
                    },
                    getReadCount(e) {
                        return this.positionReadCount.get(e || this.position) || 0
                    },
                    incrementPosition(e) {
                        if (e < 0) throw new r.B4({
                            offset: e
                        });
                        const t = this.position + e;
                        this.assertPosition(t), this.position = t
                    },
                    inspectByte(e) {
                        const t = e ? ? this.position;
                        return this.assertPosition(t), this.bytes[t]
                    },
                    inspectBytes(e, t) {
                        const n = t ? ? this.position;
                        return this.assertPosition(n + e - 1), this.bytes.subarray(n, n + e)
                    },
                    inspectUint8(e) {
                        const t = e ? ? this.position;
                        return this.assertPosition(t), this.bytes[t]
                    },
                    inspectUint16(e) {
                        const t = e ? ? this.position;
                        return this.assertPosition(t + 1), this.dataView.getUint16(t)
                    },
                    inspectUint24(e) {
                        const t = e ? ? this.position;
                        return this.assertPosition(t + 2), (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2)
                    },
                    inspectUint32(e) {
                        const t = e ? ? this.position;
                        return this.assertPosition(t + 3), this.dataView.getUint32(t)
                    },
                    pushByte(e) {
                        this.assertPosition(this.position), this.bytes[this.position] = e, this.position++
                    },
                    pushBytes(e) {
                        this.assertPosition(this.position + e.length - 1), this.bytes.set(e, this.position), this.position += e.length
                    },
                    pushUint8(e) {
                        this.assertPosition(this.position), this.bytes[this.position] = e, this.position++
                    },
                    pushUint16(e) {
                        this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e), this.position += 2
                    },
                    pushUint24(e) {
                        this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e >> 8), this.dataView.setUint8(this.position + 2, 255 & e), this.position += 3
                    },
                    pushUint32(e) {
                        this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e), this.position += 4
                    },
                    readByte() {
                        this.assertReadLimit(), this._touch();
                        const e = this.inspectByte();
                        return this.position++, e
                    },
                    readBytes(e, t) {
                        this.assertReadLimit(), this._touch();
                        const n = this.inspectBytes(e);
                        return this.position += t ? ? e, n
                    },
                    readUint8() {
                        this.assertReadLimit(), this._touch();
                        const e = this.inspectUint8();
                        return this.position += 1, e
                    },
                    readUint16() {
                        this.assertReadLimit(), this._touch();
                        const e = this.inspectUint16();
                        return this.position += 2, e
                    },
                    readUint24() {
                        this.assertReadLimit(), this._touch();
                        const e = this.inspectUint24();
                        return this.position += 3, e
                    },
                    readUint32() {
                        this.assertReadLimit(), this._touch();
                        const e = this.inspectUint32();
                        return this.position += 4, e
                    },
                    get remaining() {
                        return this.bytes.length - this.position
                    },
                    setPosition(e) {
                        const t = this.position;
                        return this.assertPosition(e), this.position = e, () => this.position = t
                    },
                    _touch() {
                        if (this.recursiveReadLimit === 1 / 0) return;
                        const e = this.getReadCount();
                        this.positionReadCount.set(this.position, e + 1), e > 0 && this.recursiveReadCount++
                    }
                };

                function o(e) {
                    let {
                        recursiveReadLimit: t = 8192
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const n = Object.create(i);
                    return n.bytes = e, n.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength), n.positionReadCount = new Map, n.recursiveReadLimit = t, n
                }
            },
            2620: (e, t, n) => {
                "use strict";

                function r(e) {
                    return "string" === typeof e[0] ? i(e) : function(e) {
                        let t = 0;
                        for (const i of e) t += i.length;
                        const n = new Uint8Array(t);
                        let r = 0;
                        for (const i of e) n.set(i, r), r += i.length;
                        return n
                    }(e)
                }

                function i(e) {
                    return `0x${e.reduce(((e,t)=>e+t.replace("0x","")),"")}`
                }
                n.d(t, {
                    aP: () => i,
                    xW: () => r
                })
            },
            1499: (e, t, n) => {
                "use strict";

                function r(e) {
                    let {
                        strict: t = !0
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return !!e && ("string" === typeof e && (t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x")))
                }
                n.d(t, {
                    q: () => r
                })
            },
            7143: (e, t, n) => {
                "use strict";
                n.d(t, {
                    db: () => o,
                    eV: () => i
                });
                var r = n(4603);

                function i(e) {
                    let {
                        dir: t,
                        size: n = 32
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return "string" === typeof e ? o(e, {
                        dir: t,
                        size: n
                    }) : function(e) {
                        let {
                            dir: t,
                            size: n = 32
                        } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if (null === n) return e;
                        if (e.length > n) throw new r.Fl({
                            size: e.length,
                            targetSize: n,
                            type: "bytes"
                        });
                        const i = new Uint8Array(n);
                        for (let r = 0; r < n; r++) {
                            const o = "right" === t;
                            i[o ? r : n - r - 1] = e[o ? r : e.length - r - 1]
                        }
                        return i
                    }(e, {
                        dir: t,
                        size: n
                    })
                }

                function o(e) {
                    let {
                        dir: t,
                        size: n = 32
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (null === n) return e;
                    const i = e.replace("0x", "");
                    if (i.length > 2 * n) throw new r.Fl({
                        size: Math.ceil(i.length / 2),
                        targetSize: n,
                        type: "hex"
                    });
                    return `0x${i["right"===t?"padEnd":"padStart"](2*n,"0")}`
                }
            },
            2017: (e, t, n) => {
                "use strict";
                n.d(t, {
                    E: () => i
                });
                var r = n(1499);

                function i(e) {
                    return (0, r.q)(e, {
                        strict: !1
                    }) ? Math.ceil((e.length - 2) / 2) : e.length
                }
            },
            6220: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A1: () => u,
                    di: () => s
                });
                var r = n(4603),
                    i = n(1499),
                    o = n(2017);

                function s(e, t, n) {
                    let {
                        strict: r
                    } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    return (0, i.q)(e, {
                        strict: !1
                    }) ? function(e, t, n) {
                        let {
                            strict: r
                        } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                        a(e, t);
                        const i = `0x${e.replace("0x","").slice(2*(t??0),2*(n??e.length))}`;
                        r && l(i, t, n);
                        return i
                    }(e, t, n, {
                        strict: r
                    }) : u(e, t, n, {
                        strict: r
                    })
                }

                function a(e, t) {
                    if ("number" === typeof t && t > 0 && t > (0, o.E)(e) - 1) throw new r.ii({
                        offset: t,
                        position: "start",
                        size: (0, o.E)(e)
                    })
                }

                function l(e, t, n) {
                    if ("number" === typeof t && "number" === typeof n && (0, o.E)(e) !== n - t) throw new r.ii({
                        offset: n,
                        position: "end",
                        size: (0, o.E)(e)
                    })
                }

                function u(e, t, n) {
                    let {
                        strict: r
                    } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                    a(e, t);
                    const i = e.slice(t, n);
                    return r && l(i, t, n), i
                }
            },
            8604: (e, t, n) => {
                "use strict";

                function r(e) {
                    let {
                        dir: t = "left"
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = "string" === typeof e ? e.replace("0x", "") : e, r = 0;
                    for (let i = 0; i < n.length - 1 && "0" === n["left" === t ? i : n.length - i - 1].toString(); i++) r++;
                    return n = "left" === t ? n.slice(r) : n.slice(0, n.length - r), "string" === typeof e ? (1 === n.length && "right" === t && (n = `${n}0`), `0x${n.length%2===1?`0${n}`:n}`) : n
                }
                n.d(t, {
                    B: () => r
                })
            },
            7962: (e, t, n) => {
                "use strict";
                n.d(t, {
                    ME: () => a,
                    Sl: () => o,
                    uU: () => s
                });
                var r = n(3458),
                    i = n(2017);

                function o(e, t) {
                    let {
                        size: n
                    } = t;
                    if ((0, i.E)(e) > n) throw new r.u({
                        givenSize: (0, i.E)(e),
                        maxSize: n
                    })
                }

                function s(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const {
                        signed: n
                    } = t;
                    t.size && o(e, {
                        size: t.size
                    });
                    const r = BigInt(e);
                    if (!n) return r;
                    const i = (e.length - 2) / 2;
                    return r <= (1 n << 8 n * BigInt(i) - 1 n) - 1 n ? r : r - BigInt(`0x${"f".padStart(2*i,"f")}`) - 1 n
                }

                function a(e) {
                    return Number(s(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}))
                }
            },
            7131: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Af: () => f,
                    ZJ: () => u,
                    aT: () => h
                });
                var r = n(1370),
                    i = n(1499),
                    o = n(7143),
                    s = n(7962),
                    a = n(4117);
                const l = new TextEncoder;

                function u(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return "number" === typeof e || "bigint" === typeof e ? function(e, t) {
                        const n = (0, a.cK)(e, t);
                        return h(n)
                    }(e, t) : "boolean" === typeof e ? function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        const n = new Uint8Array(1);
                        if (n[0] = Number(e), "number" === typeof t.size) return (0, s.Sl)(n, {
                            size: t.size
                        }), (0, o.eV)(n, {
                            size: t.size
                        });
                        return n
                    }(e, t) : (0, i.q)(e) ? h(e, t) : f(e, t)
                }
                const c = {
                    zero: 48,
                    nine: 57,
                    A: 65,
                    F: 70,
                    a: 97,
                    f: 102
                };

                function d(e) {
                    return e >= c.zero && e <= c.nine ? e - c.zero : e >= c.A && e <= c.F ? e - (c.A - 10) : e >= c.a && e <= c.f ? e - (c.a - 10) : void 0
                }

                function h(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = e;
                    t.size && ((0, s.Sl)(n, {
                        size: t.size
                    }), n = (0, o.eV)(n, {
                        dir: "right",
                        size: t.size
                    }));
                    let i = n.slice(2);
                    i.length % 2 && (i = `0${i}`);
                    const a = i.length / 2,
                        l = new Uint8Array(a);
                    for (let o = 0, s = 0; o < a; o++) {
                        const e = d(i.charCodeAt(s++)),
                            t = d(i.charCodeAt(s++));
                        if (void 0 === e || void 0 === t) throw new r.C(`Invalid byte sequence ("${i[s-2]}${i[s-1]}" in "${i}").`);
                        l[o] = 16 * e + t
                    }
                    return l
                }

                function f(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const n = l.encode(e);
                    return "number" === typeof t.size ? ((0, s.Sl)(n, {
                        size: t.size
                    }), (0, o.eV)(n, {
                        dir: "right",
                        size: t.size
                    })) : n
                }
            },
            4117: (e, t, n) => {
                "use strict";
                n.d(t, {
                    $P: () => l,
                    My: () => u,
                    cK: () => c,
                    i3: () => h,
                    nj: () => a
                });
                var r = n(3458),
                    i = n(7143),
                    o = n(7962);
                const s = Array.from({
                    length: 256
                }, ((e, t) => t.toString(16).padStart(2, "0")));

                function a(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return "number" === typeof e || "bigint" === typeof e ? c(e, t) : "string" === typeof e ? h(e, t) : "boolean" === typeof e ? l(e, t) : u(e, t)
                }

                function l(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const n = `0x${Number(e)}`;
                    return "number" === typeof t.size ? ((0, o.Sl)(n, {
                        size: t.size
                    }), (0, i.eV)(n, {
                        size: t.size
                    })) : n
                }

                function u(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = "";
                    for (let i = 0; i < e.length; i++) n += s[e[i]];
                    const r = `0x${n}`;
                    return "number" === typeof t.size ? ((0, o.Sl)(r, {
                        size: t.size
                    }), (0, i.eV)(r, {
                        dir: "right",
                        size: t.size
                    })) : r
                }

                function c(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const {
                        signed: n,
                        size: o
                    } = t, s = BigInt(e);
                    let a;
                    o ? a = n ? (1 n << 8 n * BigInt(o) - 1 n) - 1 n : 2 n ** (8 n * BigInt(o)) - 1 n : "number" === typeof e && (a = BigInt(Number.MAX_SAFE_INTEGER));
                    const l = "bigint" === typeof a && n ? -a - 1 n : 0;
                    if (a && s > a || s < l) {
                        const t = "bigint" === typeof e ? "n" : "";
                        throw new r.Ty({
                            max: a ? `${a}${t}` : void 0,
                            min: `${l}${t}`,
                            signed: n,
                            size: o,
                            value: `${e}${t}`
                        })
                    }
                    const u = `0x${(n&&s<0?(1n<<BigInt(8*o))+BigInt(s):s).toString(16)}`;
                    return o ? (0, i.eV)(u, {
                        size: o
                    }) : u
                }
                const d = new TextEncoder;

                function h(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return u(d.encode(e), t)
                }
            },
            6615: (e, t, n) => {
                "use strict";
                n.d(t, {
                    l: () => o
                });
                var r = n(1370),
                    i = n(2343);

                function o(e, t) {
                    const n = (e.details || "").toLowerCase(),
                        o = e instanceof r.C ? e.walk((e => e.code === i.A7.code)) : e;
                    return o instanceof r.C ? new i.A7({
                        cause: e,
                        message: o.details
                    }) : i.A7.nodeMessage.test(n) ? new i.A7({
                        cause: e,
                        message: e.details
                    }) : i.BG.nodeMessage.test(n) ? new i.BG({
                        cause: e,
                        maxFeePerGas: t ? .maxFeePerGas
                    }) : i.jj.nodeMessage.test(n) ? new i.jj({
                        cause: e,
                        maxFeePerGas: t ? .maxFeePerGas
                    }) : i.K0.nodeMessage.test(n) ? new i.K0({
                        cause: e,
                        nonce: t ? .nonce
                    }) : i.Oh.nodeMessage.test(n) ? new i.Oh({
                        cause: e,
                        nonce: t ? .nonce
                    }) : i.vW.nodeMessage.test(n) ? new i.vW({
                        cause: e,
                        nonce: t ? .nonce
                    }) : i.k5.nodeMessage.test(n) ? new i.k5({
                        cause: e
                    }) : i.lY.nodeMessage.test(n) ? new i.lY({
                        cause: e,
                        gas: t ? .gas
                    }) : i.Fo.nodeMessage.test(n) ? new i.Fo({
                        cause: e,
                        gas: t ? .gas
                    }) : i.uC.nodeMessage.test(n) ? new i.uC({
                        cause: e
                    }) : i.lN.nodeMessage.test(n) ? new i.lN({
                        cause: e,
                        maxFeePerGas: t ? .maxFeePerGas,
                        maxPriorityFeePerGas: t ? .maxPriorityFeePerGas
                    }) : new i.RM({
                        cause: e
                    })
                }
            },
            1928: (e, t, n) => {
                "use strict";

                function r(e, t) {
                    let {
                        format: n
                    } = t;
                    if (!n) return {};
                    const r = {};
                    return function t(n) {
                        const i = Object.keys(n);
                        for (const o of i) o in e && (r[o] = e[o]), n[o] && "object" === typeof n[o] && !Array.isArray(n[o]) && t(n[o])
                    }(n(e || {})), r
                }
                n.d(t, {
                    o: () => r
                })
            },
            6812: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Bv: () => o
                });
                var r = n(4117);
                const i = {
                    legacy: "0x0",
                    eip2930: "0x1",
                    eip1559: "0x2",
                    eip4844: "0x3"
                };

                function o(e) {
                    const t = {};
                    return "undefined" !== typeof e.accessList && (t.accessList = e.accessList), "undefined" !== typeof e.blobVersionedHashes && (t.blobVersionedHashes = e.blobVersionedHashes), "undefined" !== typeof e.blobs && ("string" !== typeof e.blobs[0] ? t.blobs = e.blobs.map((e => (0, r.My)(e))) : t.blobs = e.blobs), "undefined" !== typeof e.data && (t.data = e.data), "undefined" !== typeof e.from && (t.from = e.from), "undefined" !== typeof e.gas && (t.gas = (0, r.cK)(e.gas)), "undefined" !== typeof e.gasPrice && (t.gasPrice = (0, r.cK)(e.gasPrice)), "undefined" !== typeof e.maxFeePerBlobGas && (t.maxFeePerBlobGas = (0, r.cK)(e.maxFeePerBlobGas)), "undefined" !== typeof e.maxFeePerGas && (t.maxFeePerGas = (0, r.cK)(e.maxFeePerGas)), "undefined" !== typeof e.maxPriorityFeePerGas && (t.maxPriorityFeePerGas = (0, r.cK)(e.maxPriorityFeePerGas)), "undefined" !== typeof e.nonce && (t.nonce = (0, r.cK)(e.nonce)), "undefined" !== typeof e.to && (t.to = e.to), "undefined" !== typeof e.type && (t.type = i[e.type]), "undefined" !== typeof e.value && (t.value = (0, r.cK)(e.value)), t
                }
            },
            1064: (e, t, n) => {
                "use strict";
                n.d(t, {
                    S: () => O
                });
                var r = n(108);
                const i = BigInt(2 ** 32 - 1),
                    o = BigInt(32);

                function s(e) {
                    return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? {
                        h: Number(e & i),
                        l: Number(e >> o & i)
                    } : {
                        h: 0 | Number(e >> o & i),
                        l: 0 | Number(e & i)
                    }
                }

                function a(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        n = new Uint32Array(e.length),
                        r = new Uint32Array(e.length);
                    for (let i = 0; i < e.length; i++) {
                        const {
                            h: o,
                            l: a
                        } = s(e[i], t);
                        [n[i], r[i]] = [o, a]
                    }
                    return [n, r]
                }
                const l = (e, t, n) => e << n | t >>> 32 - n,
                    u = (e, t, n) => t << n | e >>> 32 - n,
                    c = (e, t, n) => t << n - 32 | e >>> 64 - n,
                    d = (e, t, n) => e << n - 32 | t >>> 64 - n;
                var h = n(464);
                const [f, p, m] = [
                    [],
                    [],
                    []
                ], g = BigInt(0), y = BigInt(1), v = BigInt(2), b = BigInt(7), w = BigInt(256), E = BigInt(113);
                for (let T = 0, R = y, L = 1, B = 0; T < 24; T++) {
                    [L, B] = [B, (2 * L + 3 * B) % 5], f.push(2 * (5 * B + L)), p.push((T + 1) * (T + 2) / 2 % 64);
                    let e = g;
                    for (let t = 0; t < 7; t++) R = (R << y ^ (R >> b) * E) % w, R & v && (e ^= y << (y << BigInt(t)) - y);
                    m.push(e)
                }
                const [x, A] = a(m, !0), k = (e, t, n) => n > 32 ? c(e, t, n) : l(e, t, n), C = (e, t, n) => n > 32 ? d(e, t, n) : u(e, t, n);
                class P extends h.Vw {
                    constructor(e, t, n) {
                        let i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                            o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 24;
                        if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = i, this.rounds = o, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, r.ai)(n), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
                        this.state = new Uint8Array(200), this.state32 = (0, h.DH)(this.state)
                    }
                    keccak() {
                        ! function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 24;
                            const n = new Uint32Array(10);
                            for (let r = 24 - t; r < 24; r++) {
                                for (let r = 0; r < 10; r++) n[r] = e[r] ^ e[r + 10] ^ e[r + 20] ^ e[r + 30] ^ e[r + 40];
                                for (let r = 0; r < 10; r += 2) {
                                    const t = (r + 8) % 10,
                                        i = (r + 2) % 10,
                                        o = n[i],
                                        s = n[i + 1],
                                        a = k(o, s, 1) ^ n[t],
                                        l = C(o, s, 1) ^ n[t + 1];
                                    for (let n = 0; n < 50; n += 10) e[r + n] ^= a, e[r + n + 1] ^= l
                                }
                                let t = e[2],
                                    i = e[3];
                                for (let n = 0; n < 24; n++) {
                                    const r = p[n],
                                        o = k(t, i, r),
                                        s = C(t, i, r),
                                        a = f[n];
                                    t = e[a], i = e[a + 1], e[a] = o, e[a + 1] = s
                                }
                                for (let r = 0; r < 50; r += 10) {
                                    for (let t = 0; t < 10; t++) n[t] = e[r + t];
                                    for (let t = 0; t < 10; t++) e[r + t] ^= ~n[(t + 2) % 10] & n[(t + 4) % 10]
                                }
                                e[0] ^= x[r], e[1] ^= A[r]
                            }
                            n.fill(0)
                        }(this.state32, this.rounds), this.posOut = 0, this.pos = 0
                    }
                    update(e) {
                        (0, r.t2)(this);
                        const {
                            blockLen: t,
                            state: n
                        } = this, i = (e = (0, h.ZJ)(e)).length;
                        for (let r = 0; r < i;) {
                            const o = Math.min(t - this.pos, i - r);
                            for (let t = 0; t < o; t++) n[this.pos++] ^= e[r++];
                            this.pos === t && this.keccak()
                        }
                        return this
                    }
                    finish() {
                        if (this.finished) return;
                        this.finished = !0;
                        const {
                            state: e,
                            suffix: t,
                            pos: n,
                            blockLen: r
                        } = this;
                        e[n] ^= t, 0 !== (128 & t) && n === r - 1 && this.keccak(), e[r - 1] ^= 128, this.keccak()
                    }
                    writeInto(e) {
                        (0, r.t2)(this, !1), (0, r.ee)(e), this.finish();
                        const t = this.state,
                            {
                                blockLen: n
                            } = this;
                        for (let r = 0, i = e.length; r < i;) {
                            this.posOut >= n && this.keccak();
                            const o = Math.min(n - this.posOut, i - r);
                            e.set(t.subarray(this.posOut, this.posOut + o), r), this.posOut += o, r += o
                        }
                        return e
                    }
                    xofInto(e) {
                        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
                        return this.writeInto(e)
                    }
                    xof(e) {
                        return (0, r.ai)(e), this.xofInto(new Uint8Array(e))
                    }
                    digestInto(e) {
                        if ((0, r.CG)(e, this), this.finished) throw new Error("digest() was already called");
                        return this.writeInto(e), this.destroy(), e
                    }
                    digest() {
                        return this.digestInto(new Uint8Array(this.outputLen))
                    }
                    destroy() {
                        this.destroyed = !0, this.state.fill(0)
                    }
                    _cloneInto(e) {
                        const {
                            blockLen: t,
                            suffix: n,
                            outputLen: r,
                            rounds: i,
                            enableXOF: o
                        } = this;
                        return e || (e = new P(t, n, r, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = r, e.enableXOF = o, e.destroyed = this.destroyed, e
                    }
                }
                const S = (e, t, n) => (0, h.ld)((() => new P(t, e, n))),
                    _ = S(1, 136, 32);
                var N = n(1499),
                    M = n(7131),
                    I = n(4117);

                function O(e, t) {
                    const n = t || "hex",
                        r = _((0, N.q)(e, {
                            strict: !1
                        }) ? (0, M.ZJ)(e) : e);
                    return "bytes" === n ? r : (0, I.nj)(r)
                }
            },
            284: (e, t, n) => {
                "use strict";
                n.d(t, {
                    h: () => r
                });
                const r = n(6955).k
            },
            3924: (e, t, n) => {
                "use strict";
                n.d(t, {
                    V: () => o
                });
                var r = n(6220),
                    i = n(6955);
                const o = e => (0, r.di)((0, i.k)(e), 0, 4)
            },
            6955: (e, t, n) => {
                "use strict";
                n.d(t, {
                    k: () => d
                });
                var r = n(7131),
                    i = n(1064);
                const o = e => (0, i.S)((0, r.ZJ)(e));
                const s = /^tuple(?<array>(\[(\d*)\])*)$/;

                function a(e) {
                    let t = e.type;
                    if (s.test(e.type) && "components" in e) {
                        t = "(";
                        const n = e.components.length;
                        for (let i = 0; i < n; i++) {
                            t += a(e.components[i]), i < n - 1 && (t += ", ")
                        }
                        const r = function(e, t) {
                            const n = e.exec(t);
                            return n ? .groups
                        }(s, e.type);
                        return t += `)${r?.array??""}`, a({ ...e,
                            type: t
                        })
                    }
                    return "indexed" in e && e.indexed && (t = `${t} indexed`), e.name ? `${t} ${e.name}` : t
                }

                function l(e) {
                    let t = "";
                    const n = e.length;
                    for (let r = 0; r < n; r++) {
                        t += a(e[r]), r !== n - 1 && (t += ", ")
                    }
                    return t
                }
                var u = n(1370);
                const c = e => function(e) {
                    let t = !0,
                        n = "",
                        r = 0,
                        i = "",
                        o = !1;
                    for (let s = 0; s < e.length; s++) {
                        const a = e[s];
                        if (["(", ")", ","].includes(a) && (t = !0), "(" === a && r++, ")" === a && r--, t)
                            if (0 !== r) " " !== a ? (i += a, n += a) : "," !== e[s - 1] && "," !== n && ",(" !== n && (n = "", t = !1);
                            else if (" " === a && ["event", "function", ""].includes(i)) i = "";
                        else if (i += a, ")" === a) {
                            o = !0;
                            break
                        }
                    }
                    if (!o) throw new u.C("Unable to normalize signature.");
                    return i
                }((() => {
                    return "string" === typeof e ? e : "function" === (t = e).type ? `function ${t.name}(${l(t.inputs)})${t.stateMutability&&"nonpayable"!==t.stateMutability?` ${t.stateMutability}`:""}${t.outputs.length?` returns (${l(t.outputs)})`:""}` : "event" === t.type ? `event ${t.name}(${l(t.inputs)})` : "error" === t.type ? `error ${t.name}(${l(t.inputs)})` : "constructor" === t.type ? `constructor(${l(t.inputs)})${"payable"===t.stateMutability?" payable":""}` : "fallback" === t.type ? "fallback()" : "receive() external payable";
                    var t
                })());

                function d(e) {
                    return t = c(e), o(t);
                    var t
                }
            },
            6510: (e, t, n) => {
                "use strict";
                n.d(t, {
                    u: () => i
                });
                const r = new Map;

                function i(e) {
                    let {
                        fn: t,
                        id: n,
                        shouldSplitBatch: i,
                        wait: o = 0,
                        sort: s
                    } = e;
                    const a = async () => {
                            const e = u();
                            l();
                            const n = e.map((e => {
                                let {
                                    args: t
                                } = e;
                                return t
                            }));
                            0 !== n.length && t(n).then((t => {
                                s && Array.isArray(t) && t.sort(s);
                                for (let n = 0; n < e.length; n++) {
                                    const {
                                        pendingPromise: r
                                    } = e[n];
                                    r.resolve ? .([t[n], t])
                                }
                            })).catch((t => {
                                for (let n = 0; n < e.length; n++) {
                                    const {
                                        pendingPromise: r
                                    } = e[n];
                                    r.reject ? .(t)
                                }
                            }))
                        },
                        l = () => r.delete(n),
                        u = () => r.get(n) || [],
                        c = e => r.set(n, [...u(), e]);
                    return {
                        flush: l,
                        async schedule(e) {
                            const t = {},
                                n = new Promise(((e, n) => {
                                    t.resolve = e, t.reject = n
                                })),
                                r = i ? .([...u().map((e => {
                                    let {
                                        args: t
                                    } = e;
                                    return t
                                })), e]);
                            r && a();
                            return u().length > 0 ? (c({
                                args: e,
                                pendingPromise: t
                            }), n) : (c({
                                args: e,
                                pendingPromise: t
                            }), setTimeout(a, o), n)
                        }
                    }
                }
            },
            3512: (e, t, n) => {
                "use strict";
                n.d(t, {
                    A: () => r
                });
                const r = (e, t, n) => JSON.stringify(e, ((e, n) => {
                    const r = "bigint" === typeof n ? n.toString() : n;
                    return "function" === typeof t ? t(e, r) : r
                }), n)
            },
            2861: (e, t, n) => {
                "use strict";
                n.d(t, {
                    c: () => l
                });
                var r = n(4034),
                    i = n(3491),
                    o = n(2343),
                    s = n(3003),
                    a = n(3556);

                function l(e) {
                    const {
                        account: t,
                        gasPrice: n,
                        maxFeePerGas: l,
                        maxPriorityFeePerGas: u,
                        to: c
                    } = e, d = t ? (0, r.J)(t) : void 0;
                    if (d && !(0, a.P)(d.address)) throw new i.M({
                        address: d.address
                    });
                    if (c && !(0, a.P)(c)) throw new i.M({
                        address: c
                    });
                    if ("undefined" !== typeof n && ("undefined" !== typeof l || "undefined" !== typeof u)) throw new s.n3;
                    if (l && l > 2 n ** 256 n - 1 n) throw new o.BG({
                        maxFeePerGas: l
                    });
                    if (u && l && u > l) throw new o.lN({
                        maxFeePerGas: l,
                        maxPriorityFeePerGas: u
                    })
                }
            },
            1273: (e, t, n) => {
                "use strict";
                n.d(t, {
                    c: () => o
                });
                var r = n(9611),
                    i = n(306);

                function o(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "wei";
                    return (0, i.J)(e, r.eL[t])
                }
            },
            4569: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Q: () => o
                });
                var r = n(9611),
                    i = n(306);

                function o(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "wei";
                    return (0, i.J)(e, r.sz[t])
                }
            },
            306: (e, t, n) => {
                "use strict";

                function r(e, t) {
                    let n = e.toString();
                    const r = n.startsWith("-");
                    r && (n = n.slice(1)), n = n.padStart(t, "0");
                    let [i, o] = [n.slice(0, n.length - t), n.slice(n.length - t)];
                    return o = o.replace(/(0+)$/, ""), `${r?"-":""}${i||"0"}${o?`.${o}`:""}`
                }
                n.d(t, {
                    J: () => r
                })
            },
            108: (e, t, n) => {
                "use strict";

                function r(e) {
                    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`)
                }

                function i(e) {
                    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
                    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                    if (n.length > 0 && !n.includes(e.length)) throw new Error(`Expected Uint8Array of length ${n}, not of length=${e.length}`)
                }

                function o(e) {
                    if ("function" !== typeof e || "function" !== typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
                    r(e.outputLen), r(e.blockLen)
                }

                function s(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    if (e.destroyed) throw new Error("Hash instance has been destroyed");
                    if (t && e.finished) throw new Error("Hash#digest() has already been called")
                }

                function a(e, t) {
                    i(e);
                    const n = t.outputLen;
                    if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
                }
                n.d(t, {
                    CG: () => a,
                    ai: () => r,
                    ee: () => i,
                    t2: () => s,
                    tW: () => o
                })
            },
            464: (e, t, n) => {
                "use strict";
                n.d(t, {
                    Vw: () => c,
                    Id: () => u,
                    O8: () => s,
                    po: () => h,
                    Ow: () => a,
                    ZJ: () => l,
                    DH: () => o,
                    ld: () => d
                });
                const r = "object" === typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
                    i = e => e instanceof Uint8Array,
                    o = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
                    s = e => new DataView(e.buffer, e.byteOffset, e.byteLength),
                    a = (e, t) => e << 32 - t | e >>> t;
                if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])) throw new Error("Non little-endian hardware is not supported");

                function l(e) {
                    if ("string" === typeof e && (e = function(e) {
                            if ("string" !== typeof e) throw new Error("utf8ToBytes expected string, got " + typeof e);
                            return new Uint8Array((new TextEncoder).encode(e))
                        }(e)), !i(e)) throw new Error("expected Uint8Array, got " + typeof e);
                    return e
                }

                function u() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    const r = new Uint8Array(t.reduce(((e, t) => e + t.length), 0));
                    let o = 0;
                    return t.forEach((e => {
                        if (!i(e)) throw new Error("Uint8Array expected");
                        r.set(e, o), o += e.length
                    })), r
                }
                class c {
                    clone() {
                        return this._cloneInto()
                    }
                }

                function d(e) {
                    const t = t => e().update(l(t)).digest(),
                        n = e();
                    return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
                }

                function h() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
                    if (r && "function" === typeof r.getRandomValues) return r.getRandomValues(new Uint8Array(e));
                    throw new Error("crypto.getRandomValues must be defined")
                }
            }
        },
        t = {};

    function n(r) {
        var i = t[r];
        if (void 0 !== i) return i.exports;
        var o = t[r] = {
            id: r,
            loaded: !1,
            exports: {}
        };
        return e[r].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports
    }
    n.m = e, n.amdO = {}, n.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return n.d(t, {
            a: t
        }), t
    }, (() => {
        var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__;
        n.t = function(r, i) {
            if (1 & i && (r = this(r)), 8 & i) return r;
            if ("object" === typeof r && r) {
                if (4 & i && r.__esModule) return r;
                if (16 & i && "function" === typeof r.then) return r
            }
            var o = Object.create(null);
            n.r(o);
            var s = {};
            e = e || [null, t({}), t([]), t(t)];
            for (var a = 2 & i && r;
                "object" == typeof a && !~e.indexOf(a); a = t(a)) Object.getOwnPropertyNames(a).forEach((e => s[e] = () => r[e]));
            return s.default = () => r, n.d(o, s), o
        }
    })(), n.d = (e, t) => {
        for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
            enumerable: !0,
            get: t[r]
        })
    }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce(((t, r) => (n.f[r](e, t), t)), [])), n.u = e => "static/js/" + e + "." + {
        126: "2b3a8478",
        171: "3a20b501",
        432: "efe1c440",
        444: "ba788840",
        507: "8051121b"
    }[e] + ".chunk.js", n.miniCssF = e => {}, n.g = function() {
        if ("object" === typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" === typeof window) return window
        }
    }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => {
        var e = {},
            t = "cosmic-wallet:";
        n.l = (r, i, o, s) => {
            if (e[r]) e[r].push(i);
            else {
                var a, l;
                if (void 0 !== o)
                    for (var u = document.getElementsByTagName("script"), c = 0; c < u.length; c++) {
                        var d = u[c];
                        if (d.getAttribute("src") == r || d.getAttribute("data-webpack") == t + o) {
                            a = d;
                            break
                        }
                    }
                a || (l = !0, (a = document.createElement("script")).charset = "utf-8", a.timeout = 120, n.nc && a.setAttribute("nonce", n.nc), a.setAttribute("data-webpack", t + o), a.src = r), e[r] = [i];
                var h = (t, n) => {
                        a.onerror = a.onload = null, clearTimeout(f);
                        var i = e[r];
                        if (delete e[r], a.parentNode && a.parentNode.removeChild(a), i && i.forEach((e => e(n))), t) return t(n)
                    },
                    f = setTimeout(h.bind(null, void 0, {
                        type: "timeout",
                        target: a
                    }), 12e4);
                a.onerror = h.bind(null, a.onerror), a.onload = h.bind(null, a.onload), l && document.head.appendChild(a)
            }
        }
    })(), n.r = e => {
        "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, n.nmd = e => (e.paths = [], e.children || (e.children = []), e), n.p = "/", (() => {
        var e = {
            792: 0
        };
        n.f.j = (t, r) => {
            var i = n.o(e, t) ? e[t] : void 0;
            if (0 !== i)
                if (i) r.push(i[2]);
                else {
                    var o = new Promise(((n, r) => i = e[t] = [n, r]));
                    r.push(i[2] = o);
                    var s = n.p + n.u(t),
                        a = new Error;
                    n.l(s, (r => {
                        if (n.o(e, t) && (0 !== (i = e[t]) && (e[t] = void 0), i)) {
                            var o = r && ("load" === r.type ? "missing" : r.type),
                                s = r && r.target && r.target.src;
                            a.message = "Loading chunk " + t + " failed.\n(" + o + ": " + s + ")", a.name = "ChunkLoadError", a.type = o, a.request = s, i[1](a)
                        }
                    }), "chunk-" + t, t)
                }
        };
        var t = (t, r) => {
                var i, o, s = r[0],
                    a = r[1],
                    l = r[2],
                    u = 0;
                if (s.some((t => 0 !== e[t]))) {
                    for (i in a) n.o(a, i) && (n.m[i] = a[i]);
                    if (l) l(n)
                }
                for (t && t(r); u < s.length; u++) o = s[u], n.o(e, o) && e[o] && e[o][0](), e[o] = 0
            },
            r = self.webpackChunkcosmic_wallet = self.webpackChunkcosmic_wallet || [];
        r.forEach(t.bind(null, 0)), r.push = t.bind(null, r.push.bind(r))
    })(), (() => {
        "use strict";
        var e = {};
        n.r(e), n.d(e, {
            DO: () => da,
            OG: () => Ca,
            My: () => fa,
            Ph: () => va,
            lX: () => ba,
            Id: () => Aa,
            fg: () => _a,
            qj: () => xa,
            ex: () => ka,
            aT: () => ya,
            aY: () => ca,
            lq: () => wa,
            z: () => Ea,
            Q5: () => Ma
        });
        var t, r = n(5043),
            i = n.t(r, 2),
            o = n(4391),
            s = n(7950),
            a = n.t(s, 2);

        function l() {
            return l = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, l.apply(this, arguments)
        }! function(e) {
            e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE"
        }(t || (t = {}));
        const u = "popstate";

        function c(e, t) {
            if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t)
        }

        function d(e, t) {
            if (!e) {
                "undefined" !== typeof console && console.warn(t);
                try {
                    throw new Error(t)
                } catch (n) {}
            }
        }

        function h(e, t) {
            return {
                usr: e.state,
                key: e.key,
                idx: t
            }
        }

        function f(e, t, n, r) {
            return void 0 === n && (n = null), l({
                pathname: "string" === typeof e ? e : e.pathname,
                search: "",
                hash: ""
            }, "string" === typeof t ? m(t) : t, {
                state: n,
                key: t && t.key || r || Math.random().toString(36).substr(2, 8)
            })
        }

        function p(e) {
            let {
                pathname: t = "/",
                search: n = "",
                hash: r = ""
            } = e;
            return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t
        }

        function m(e) {
            let t = {};
            if (e) {
                let n = e.indexOf("#");
                n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
                let r = e.indexOf("?");
                r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e)
            }
            return t
        }

        function g(e, n, r, i) {
            void 0 === i && (i = {});
            let {
                window: o = document.defaultView,
                v5Compat: s = !1
            } = i, a = o.history, d = t.Pop, m = null, g = y();

            function y() {
                return (a.state || {
                    idx: null
                }).idx
            }

            function v() {
                d = t.Pop;
                let e = y(),
                    n = null == e ? null : e - g;
                g = e, m && m({
                    action: d,
                    location: w.location,
                    delta: n
                })
            }

            function b(e) {
                let t = "null" !== o.location.origin ? o.location.origin : o.location.href,
                    n = "string" === typeof e ? e : p(e);
                return n = n.replace(/ $/, "%20"), c(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t)
            }
            null == g && (g = 0, a.replaceState(l({}, a.state, {
                idx: g
            }), ""));
            let w = {
                get action() {
                    return d
                },
                get location() {
                    return e(o, a)
                },
                listen(e) {
                    if (m) throw new Error("A history only accepts one active listener");
                    return o.addEventListener(u, v), m = e, () => {
                        o.removeEventListener(u, v), m = null
                    }
                },
                createHref: e => n(o, e),
                createURL: b,
                encodeLocation(e) {
                    let t = b(e);
                    return {
                        pathname: t.pathname,
                        search: t.search,
                        hash: t.hash
                    }
                },
                push: function(e, n) {
                    d = t.Push;
                    let i = f(w.location, e, n);
                    r && r(i, e), g = y() + 1;
                    let l = h(i, g),
                        u = w.createHref(i);
                    try {
                        a.pushState(l, "", u)
                    } catch (c) {
                        if (c instanceof DOMException && "DataCloneError" === c.name) throw c;
                        o.location.assign(u)
                    }
                    s && m && m({
                        action: d,
                        location: w.location,
                        delta: 1
                    })
                },
                replace: function(e, n) {
                    d = t.Replace;
                    let i = f(w.location, e, n);
                    r && r(i, e), g = y();
                    let o = h(i, g),
                        l = w.createHref(i);
                    a.replaceState(o, "", l), s && m && m({
                        action: d,
                        location: w.location,
                        delta: 0
                    })
                },
                go: e => a.go(e)
            };
            return w
        }
        var y;
        ! function(e) {
            e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error"
        }(y || (y = {}));
        new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);

        function v(e, t, n) {
            return void 0 === n && (n = "/"), b(e, t, n, !1)
        }

        function b(e, t, n, r) {
            let i = T(("string" === typeof t ? m(t) : t).pathname || "/", n);
            if (null == i) return null;
            let o = w(e);
            ! function(e) {
                e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function(e, t) {
                    let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n]));
                    return n ? e[e.length - 1] - t[t.length - 1] : 0
                }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex)))))
            }(o);
            let s = null;
            for (let a = 0; null == s && a < o.length; ++a) {
                let e = O(i);
                s = M(o[a], e, r)
            }
            return s
        }

        function w(e, t, n, r) {
            void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = "");
            let i = (e, i, o) => {
                let s = {
                    relativePath: void 0 === o ? e.path || "" : o,
                    caseSensitive: !0 === e.caseSensitive,
                    childrenIndex: i,
                    route: e
                };
                s.relativePath.startsWith("/") && (c(s.relativePath.startsWith(r), 'Absolute route path "' + s.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), s.relativePath = s.relativePath.slice(r.length));
                let a = R([r, s.relativePath]),
                    l = n.concat(s);
                e.children && e.children.length > 0 && (c(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + a + '".'), w(e.children, t, l, a)), (null != e.path || e.index) && t.push({
                    path: a,
                    score: N(a, e.index),
                    routesMeta: l
                })
            };
            return e.forEach(((e, t) => {
                var n;
                if ("" !== e.path && null != (n = e.path) && n.includes("?"))
                    for (let r of E(e.path)) i(e, t, r);
                else i(e, t)
            })), t
        }

        function E(e) {
            let t = e.split("/");
            if (0 === t.length) return [];
            let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
            if (0 === r.length) return i ? [o, ""] : [o];
            let s = E(r.join("/")),
                a = [];
            return a.push(...s.map((e => "" === e ? o : [o, e].join("/")))), i && a.push(...s), a.map((t => e.startsWith("/") && "" === t ? "/" : t))
        }
        const x = /^:[\w-]+$/,
            A = 3,
            k = 2,
            C = 1,
            P = 10,
            S = -2,
            _ = e => "*" === e;

        function N(e, t) {
            let n = e.split("/"),
                r = n.length;
            return n.some(_) && (r += S), t && (r += k), n.filter((e => !_(e))).reduce(((e, t) => e + (x.test(t) ? A : "" === t ? C : P)), r)
        }

        function M(e, t, n) {
            void 0 === n && (n = !1);
            let {
                routesMeta: r
            } = e, i = {}, o = "/", s = [];
            for (let a = 0; a < r.length; ++a) {
                let e = r[a],
                    l = a === r.length - 1,
                    u = "/" === o ? t : t.slice(o.length) || "/",
                    c = I({
                        path: e.relativePath,
                        caseSensitive: e.caseSensitive,
                        end: l
                    }, u),
                    d = e.route;
                if (!c && l && n && !r[r.length - 1].route.index && (c = I({
                        path: e.relativePath,
                        caseSensitive: e.caseSensitive,
                        end: !1
                    }, u)), !c) return null;
                Object.assign(i, c.params), s.push({
                    params: i,
                    pathname: R([o, c.pathname]),
                    pathnameBase: L(R([o, c.pathnameBase])),
                    route: d
                }), "/" !== c.pathnameBase && (o = R([o, c.pathnameBase]))
            }
            return s
        }

        function I(e, t) {
            "string" === typeof e && (e = {
                path: e,
                caseSensitive: !1,
                end: !0
            });
            let [n, r] = function(e, t, n) {
                void 0 === t && (t = !1);
                void 0 === n && (n = !0);
                d("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".');
                let r = [],
                    i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, ((e, t, n) => (r.push({
                        paramName: t,
                        isOptional: null != n
                    }), n ? "/?([^\\/]+)?" : "/([^\\/]+)")));
                e.endsWith("*") ? (r.push({
                    paramName: "*"
                }), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))");
                let o = new RegExp(i, t ? void 0 : "i");
                return [o, r]
            }(e.path, e.caseSensitive, e.end), i = t.match(n);
            if (!i) return null;
            let o = i[0],
                s = o.replace(/(.)\/+$/, "$1"),
                a = i.slice(1),
                l = r.reduce(((e, t, n) => {
                    let {
                        paramName: r,
                        isOptional: i
                    } = t;
                    if ("*" === r) {
                        let e = a[n] || "";
                        s = o.slice(0, o.length - e.length).replace(/(.)\/+$/, "$1")
                    }
                    const l = a[n];
                    return e[r] = i && !l ? void 0 : (l || "").replace(/%2F/g, "/"), e
                }), {});
            return {
                params: l,
                pathname: o,
                pathnameBase: s,
                pattern: e
            }
        }

        function O(e) {
            try {
                return e.split("/").map((e => decodeURIComponent(e).replace(/\//g, "%2F"))).join("/")
            } catch (t) {
                return d(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e
            }
        }

        function T(e, t) {
            if ("/" === t) return e;
            if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
            let n = t.endsWith("/") ? t.length - 1 : t.length,
                r = e.charAt(n);
            return r && "/" !== r ? null : e.slice(n) || "/"
        }
        const R = e => e.join("/").replace(/\/\/+/g, "/"),
            L = e => e.replace(/\/+$/, "").replace(/^\/*/, "/");
        Error;

        function B(e) {
            return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e
        }
        const F = ["post", "put", "patch", "delete"],
            j = (new Set(F), ["get", ...F]);
        new Set(j), new Set([301, 302, 303, 307, 308]), new Set([307, 308]);
        Symbol("deferred");

        function D() {
            return D = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, D.apply(this, arguments)
        }
        const U = r.createContext(null);
        const z = r.createContext(null);
        const q = r.createContext(null);
        const G = r.createContext(null);
        const H = r.createContext({
            outlet: null,
            matches: [],
            isDataRoute: !1
        });
        const $ = r.createContext(null);

        function Q() {
            return null != r.useContext(G)
        }

        function V() {
            return Q() || c(!1), r.useContext(G).location
        }

        function K(e, n, i, o) {
            Q() || c(!1);
            let {
                navigator: s
            } = r.useContext(q), {
                matches: a
            } = r.useContext(H), l = a[a.length - 1], u = l ? l.params : {}, d = (l && l.pathname, l ? l.pathnameBase : "/");
            l && l.route;
            let h, f = V();
            if (n) {
                var p;
                let e = "string" === typeof n ? m(n) : n;
                "/" === d || (null == (p = e.pathname) ? void 0 : p.startsWith(d)) || c(!1), h = e
            } else h = f;
            let g = h.pathname || "/",
                y = g;
            if ("/" !== d) {
                let e = d.replace(/^\//, "").split("/");
                y = "/" + g.replace(/^\//, "").split("/").slice(e.length).join("/")
            }
            let b = v(e, {
                pathname: y
            });
            let w = X(b && b.map((e => Object.assign({}, e, {
                params: Object.assign({}, u, e.params),
                pathname: R([d, s.encodeLocation ? s.encodeLocation(e.pathname).pathname : e.pathname]),
                pathnameBase: "/" === e.pathnameBase ? d : R([d, s.encodeLocation ? s.encodeLocation(e.pathnameBase).pathname : e.pathnameBase])
            }))), a, i, o);
            return n && w ? r.createElement(G.Provider, {
                value: {
                    location: D({
                        pathname: "/",
                        search: "",
                        hash: "",
                        state: null,
                        key: "default"
                    }, h),
                    navigationType: t.Pop
                }
            }, w) : w
        }

        function W() {
            let e = function() {
                    var e;
                    let t = r.useContext($),
                        n = te(ee.UseRouteError),
                        i = ne(ee.UseRouteError);
                    if (void 0 !== t) return t;
                    return null == (e = n.errors) ? void 0 : e[i]
                }(),
                t = B(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e),
                n = e instanceof Error ? e.stack : null,
                i = "rgba(200,200,200, 0.5)",
                o = {
                    padding: "0.5rem",
                    backgroundColor: i
                };
            return r.createElement(r.Fragment, null, r.createElement("h2", null, "Unexpected Application Error!"), r.createElement("h3", {
                style: {
                    fontStyle: "italic"
                }
            }, t), n ? r.createElement("pre", {
                style: o
            }, n) : null, null)
        }
        const J = r.createElement(W, null);
        class Z extends r.Component {
            constructor(e) {
                super(e), this.state = {
                    location: e.location,
                    revalidation: e.revalidation,
                    error: e.error
                }
            }
            static getDerivedStateFromError(e) {
                return {
                    error: e
                }
            }
            static getDerivedStateFromProps(e, t) {
                return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? {
                    error: e.error,
                    location: e.location,
                    revalidation: e.revalidation
                } : {
                    error: void 0 !== e.error ? e.error : t.error,
                    location: t.location,
                    revalidation: e.revalidation || t.revalidation
                }
            }
            componentDidCatch(e, t) {
                console.error("React Router caught the following error during render", e, t)
            }
            render() {
                return void 0 !== this.state.error ? r.createElement(H.Provider, {
                    value: this.props.routeContext
                }, r.createElement($.Provider, {
                    value: this.state.error,
                    children: this.props.component
                })) : this.props.children
            }
        }

        function Y(e) {
            let {
                routeContext: t,
                match: n,
                children: i
            } = e, o = r.useContext(U);
            return o && o.static && o.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = n.route.id), r.createElement(H.Provider, {
                value: t
            }, i)
        }

        function X(e, t, n, i) {
            var o;
            if (void 0 === t && (t = []), void 0 === n && (n = null), void 0 === i && (i = null), null == e) {
                var s;
                if (!n) return null;
                if (n.errors) e = n.matches;
                else {
                    if (!(null != (s = i) && s.v7_partialHydration && 0 === t.length && !n.initialized && n.matches.length > 0)) return null;
                    e = n.matches
                }
            }
            let a = e,
                l = null == (o = n) ? void 0 : o.errors;
            if (null != l) {
                let e = a.findIndex((e => e.route.id && void 0 !== (null == l ? void 0 : l[e.route.id])));
                e >= 0 || c(!1), a = a.slice(0, Math.min(a.length, e + 1))
            }
            let u = !1,
                d = -1;
            if (n && i && i.v7_partialHydration)
                for (let r = 0; r < a.length; r++) {
                    let e = a[r];
                    if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (d = r), e.route.id) {
                        let {
                            loaderData: t,
                            errors: r
                        } = n, i = e.route.loader && void 0 === t[e.route.id] && (!r || void 0 === r[e.route.id]);
                        if (e.route.lazy || i) {
                            u = !0, a = d >= 0 ? a.slice(0, d + 1) : [a[0]];
                            break
                        }
                    }
                }
            return a.reduceRight(((e, i, o) => {
                let s, c = !1,
                    h = null,
                    f = null;
                n && (s = l && i.route.id ? l[i.route.id] : void 0, h = i.route.errorElement || J, u && (d < 0 && 0 === o ? (! function(e, t) {
                    t || re[e] || (re[e] = !0)
                }("route-fallback", !1), c = !0, f = null) : d === o && (c = !0, f = i.route.hydrateFallbackElement || null)));
                let p = t.concat(a.slice(0, o + 1)),
                    m = () => {
                        let t;
                        return t = s ? h : c ? f : i.route.Component ? r.createElement(i.route.Component, null) : i.route.element ? i.route.element : e, r.createElement(Y, {
                            match: i,
                            routeContext: {
                                outlet: e,
                                matches: p,
                                isDataRoute: null != n
                            },
                            children: t
                        })
                    };
                return n && (i.route.ErrorBoundary || i.route.errorElement || 0 === o) ? r.createElement(Z, {
                    location: n.location,
                    revalidation: n.revalidation,
                    component: h,
                    error: s,
                    children: m(),
                    routeContext: {
                        outlet: null,
                        matches: p,
                        isDataRoute: !0
                    }
                }) : m()
            }), null)
        }
        var ee = function(e) {
            return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e
        }(ee || {});

        function te(e) {
            let t = r.useContext(z);
            return t || c(!1), t
        }

        function ne(e) {
            let t = function() {
                    let e = r.useContext(H);
                    return e || c(!1), e
                }(),
                n = t.matches[t.matches.length - 1];
            return n.route.id || c(!1), n.route.id
        }
        const re = {};
        i.startTransition;

        function ie(e) {
            c(!1)
        }

        function oe(e) {
            let {
                basename: n = "/",
                children: i = null,
                location: o,
                navigationType: s = t.Pop,
                navigator: a,
                static: l = !1,
                future: u
            } = e;
            Q() && c(!1);
            let d = n.replace(/^\/*/, "/"),
                h = r.useMemo((() => ({
                    basename: d,
                    navigator: a,
                    static: l,
                    future: D({
                        v7_relativeSplatPath: !1
                    }, u)
                })), [d, u, a, l]);
            "string" === typeof o && (o = m(o));
            let {
                pathname: f = "/",
                search: p = "",
                hash: g = "",
                state: y = null,
                key: v = "default"
            } = o, b = r.useMemo((() => {
                let e = T(f, d);
                return null == e ? null : {
                    location: {
                        pathname: e,
                        search: p,
                        hash: g,
                        state: y,
                        key: v
                    },
                    navigationType: s
                }
            }), [d, f, p, g, y, v, s]);
            return null == b ? null : r.createElement(q.Provider, {
                value: h
            }, r.createElement(G.Provider, {
                children: i,
                value: b
            }))
        }

        function se(e) {
            let {
                children: t,
                location: n
            } = e;
            return K(ae(t), n)
        }
        new Promise((() => {}));
        r.Component;

        function ae(e, t) {
            void 0 === t && (t = []);
            let n = [];
            return r.Children.forEach(e, ((e, i) => {
                if (!r.isValidElement(e)) return;
                let o = [...t, i];
                if (e.type === r.Fragment) return void n.push.apply(n, ae(e.props.children, o));
                e.type !== ie && c(!1), e.props.index && e.props.children && c(!1);
                let s = {
                    id: e.props.id || o.join("-"),
                    caseSensitive: e.props.caseSensitive,
                    element: e.props.element,
                    Component: e.props.Component,
                    index: e.props.index,
                    path: e.props.path,
                    loader: e.props.loader,
                    action: e.props.action,
                    errorElement: e.props.errorElement,
                    ErrorBoundary: e.props.ErrorBoundary,
                    hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement,
                    shouldRevalidate: e.props.shouldRevalidate,
                    handle: e.props.handle,
                    lazy: e.props.lazy
                };
                e.props.children && (s.children = ae(e.props.children, o)), n.push(s)
            })), n
        }
        new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
        try {
            window.__reactRouterVersion = "6"
        } catch (dg) {}
        new Map;
        const le = i.startTransition;
        a.flushSync, i.useId;

        function ue(e) {
            let {
                basename: t,
                children: n,
                future: i,
                window: o
            } = e, s = r.useRef();
            null == s.current && (s.current = function(e) {
                return void 0 === e && (e = {}), g((function(e, t) {
                    let {
                        pathname: n,
                        search: r,
                        hash: i
                    } = e.location;
                    return f("", {
                        pathname: n,
                        search: r,
                        hash: i
                    }, t.state && t.state.usr || null, t.state && t.state.key || "default")
                }), (function(e, t) {
                    return "string" === typeof t ? t : p(t)
                }), null, e)
            }({
                window: o,
                v5Compat: !0
            }));
            let a = s.current,
                [l, u] = r.useState({
                    action: a.action,
                    location: a.location
                }),
                {
                    v7_startTransition: c
                } = i || {},
                d = r.useCallback((e => {
                    c && le ? le((() => u(e))) : u(e)
                }), [u, c]);
            return r.useLayoutEffect((() => a.listen(d)), [a, d]), r.createElement(oe, {
                basename: t,
                children: n,
                location: l.location,
                navigationType: l.action,
                navigator: a,
                future: i
            })
        }
        "undefined" !== typeof window && "undefined" !== typeof window.document && window.document.createElement;
        var ce, de;
        (function(e) {
            e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState"
        })(ce || (ce = {})),
        function(e) {
            e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration"
        }(de || (de = {}));
        var he = n(579);
        const fe = () => (0, he.jsx)("div", {
            className: "splash",
            children: (0, he.jsx)("div", {
                className: "inner-splash",
                children: (0, he.jsx)("img", {
                    src: "/images/log.svg",
                    alt: "log"
                })
            })
        });
        var pe = function() {
                let e = [],
                    t = 0,
                    n = e => {
                        e()
                    },
                    r = e => {
                        e()
                    },
                    i = e => setTimeout(e, 0);
                const o = r => {
                        t ? e.push(r) : i((() => {
                            n(r)
                        }))
                    },
                    s = () => {
                        const t = e;
                        e = [], t.length && i((() => {
                            r((() => {
                                t.forEach((e => {
                                    n(e)
                                }))
                            }))
                        }))
                    };
                return {
                    batch: e => {
                        let n;
                        t++;
                        try {
                            n = e()
                        } finally {
                            t--, t || s()
                        }
                        return n
                    },
                    batchCalls: e => function() {
                        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                        o((() => {
                            e(...n)
                        }))
                    },
                    schedule: o,
                    setNotifyFunction: e => {
                        n = e
                    },
                    setBatchNotifyFunction: e => {
                        r = e
                    },
                    setScheduler: e => {
                        i = e
                    }
                }
            }(),
            me = "undefined" === typeof window || "Deno" in globalThis;

        function ge() {}

        function ye(e) {
            return "number" === typeof e && e >= 0 && e !== 1 / 0
        }

        function ve(e, t) {
            return Math.max(e + (t || 0) - Date.now(), 0)
        }

        function be(e, t) {
            return "function" === typeof e ? e(t) : e
        }

        function we(e, t) {
            return "function" === typeof e ? e(t) : e
        }

        function Ee(e, t) {
            const {
                type: n = "all",
                exact: r,
                fetchStatus: i,
                predicate: o,
                queryKey: s,
                stale: a
            } = e;
            if (s)
                if (r) {
                    if (t.queryHash !== Ae(s, t.options)) return !1
                } else if (!Ce(t.queryKey, s)) return !1;
            if ("all" !== n) {
                const e = t.isActive();
                if ("active" === n && !e) return !1;
                if ("inactive" === n && e) return !1
            }
            return ("boolean" !== typeof a || t.isStale() === a) && ((!i || i === t.state.fetchStatus) && !(o && !o(t)))
        }

        function xe(e, t) {
            const {
                exact: n,
                status: r,
                predicate: i,
                mutationKey: o
            } = e;
            if (o) {
                if (!t.options.mutationKey) return !1;
                if (n) {
                    if (ke(t.options.mutationKey) !== ke(o)) return !1
                } else if (!Ce(t.options.mutationKey, o)) return !1
            }
            return (!r || t.state.status === r) && !(i && !i(t))
        }

        function Ae(e, t) {
            return (t ? .queryKeyHashFn || ke)(e)
        }

        function ke(e) {
            return JSON.stringify(e, ((e, t) => Ne(t) ? Object.keys(t).sort().reduce(((e, n) => (e[n] = t[n], e)), {}) : t))
        }

        function Ce(e, t) {
            return e === t || typeof e === typeof t && (!(!e || !t || "object" !== typeof e || "object" !== typeof t) && !Object.keys(t).some((n => !Ce(e[n], t[n]))))
        }

        function Pe(e, t) {
            if (e === t) return e;
            const n = _e(e) && _e(t);
            if (n || Ne(e) && Ne(t)) {
                const r = n ? e : Object.keys(e),
                    i = r.length,
                    o = n ? t : Object.keys(t),
                    s = o.length,
                    a = n ? [] : {};
                let l = 0;
                for (let u = 0; u < s; u++) {
                    const i = n ? u : o[u];
                    (!n && r.includes(i) || n) && void 0 === e[i] && void 0 === t[i] ? (a[i] = void 0, l++) : (a[i] = Pe(e[i], t[i]), a[i] === e[i] && void 0 !== e[i] && l++)
                }
                return i === s && l === i ? e : a
            }
            return t
        }

        function Se(e, t) {
            if (!t || Object.keys(e).length !== Object.keys(t).length) return !1;
            for (const n in e)
                if (e[n] !== t[n]) return !1;
            return !0
        }

        function _e(e) {
            return Array.isArray(e) && e.length === Object.keys(e).length
        }

        function Ne(e) {
            if (!Me(e)) return !1;
            const t = e.constructor;
            if (void 0 === t) return !0;
            const n = t.prototype;
            return !!Me(n) && (!!n.hasOwnProperty("isPrototypeOf") && Object.getPrototypeOf(e) === Object.prototype)
        }

        function Me(e) {
            return "[object Object]" === Object.prototype.toString.call(e)
        }

        function Ie(e, t, n) {
            return "function" === typeof n.structuralSharing ? n.structuralSharing(e, t) : !1 !== n.structuralSharing ? Pe(e, t) : t
        }

        function Oe(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            const r = [...e, t];
            return n && r.length > n ? r.slice(1) : r
        }

        function Te(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            const r = [t, ...e];
            return n && r.length > n ? r.slice(0, -1) : r
        }
        var Re = Symbol();

        function Le(e, t) {
            return !e.queryFn && t ? .initialPromise ? () => t.initialPromise : e.queryFn && e.queryFn !== Re ? e.queryFn : () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`))
        }
        var Be = class {#
                e;
                destroy() {
                    this.clearGcTimeout()
                }
                scheduleGc() {
                    this.clearGcTimeout(), ye(this.gcTime) && (this.#e = setTimeout((() => {
                        this.optionalRemove()
                    }), this.gcTime))
                }
                updateGcTime(e) {
                    this.gcTime = Math.max(this.gcTime || 0, e ? ? (me ? 1 / 0 : 3e5))
                }
                clearGcTimeout() {
                    this.#e && (clearTimeout(this.#e), this.#e = void 0)
                }
            },
            Fe = class {
                constructor() {
                    this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
                }
                subscribe(e) {
                    return this.listeners.add(e), this.onSubscribe(), () => {
                        this.listeners.delete(e), this.onUnsubscribe()
                    }
                }
                hasListeners() {
                    return this.listeners.size > 0
                }
                onSubscribe() {}
                onUnsubscribe() {}
            },
            je = new class extends Fe {#
                t;#
                n;#
                r;
                constructor() {
                    super(), this.#r = e => {
                        if (!me && window.addEventListener) {
                            const t = () => e();
                            return window.addEventListener("visibilitychange", t, !1), () => {
                                window.removeEventListener("visibilitychange", t)
                            }
                        }
                    }
                }
                onSubscribe() {
                    this.#n || this.setEventListener(this.#r)
                }
                onUnsubscribe() {
                    this.hasListeners() || (this.#n ? .(), this.#n = void 0)
                }
                setEventListener(e) {
                    this.#r = e, this.#n ? .(), this.#n = e((e => {
                        "boolean" === typeof e ? this.setFocused(e) : this.onFocus()
                    }))
                }
                setFocused(e) {
                    this.#t !== e && (this.#t = e, this.onFocus())
                }
                onFocus() {
                    const e = this.isFocused();
                    this.listeners.forEach((t => {
                        t(e)
                    }))
                }
                isFocused() {
                    return "boolean" === typeof this.#t ? this.#t : "hidden" !== globalThis.document ? .visibilityState
                }
            },
            De = new class extends Fe {#
                i = !0;#
                n;#
                r;
                constructor() {
                    super(), this.#r = e => {
                        if (!me && window.addEventListener) {
                            const t = () => e(!0),
                                n = () => e(!1);
                            return window.addEventListener("online", t, !1), window.addEventListener("offline", n, !1), () => {
                                window.removeEventListener("online", t), window.removeEventListener("offline", n)
                            }
                        }
                    }
                }
                onSubscribe() {
                    this.#n || this.setEventListener(this.#r)
                }
                onUnsubscribe() {
                    this.hasListeners() || (this.#n ? .(), this.#n = void 0)
                }
                setEventListener(e) {
                    this.#r = e, this.#n ? .(), this.#n = e(this.setOnline.bind(this))
                }
                setOnline(e) {
                    this.#i !== e && (this.#i = e, this.listeners.forEach((t => {
                        t(e)
                    })))
                }
                isOnline() {
                    return this.#i
                }
            };

        function Ue(e) {
            return Math.min(1e3 * 2 ** e, 3e4)
        }

        function ze(e) {
            return "online" !== (e ? ? "online") || De.isOnline()
        }
        var qe = class extends Error {
            constructor(e) {
                super("CancelledError"), this.revert = e ? .revert, this.silent = e ? .silent
            }
        };

        function Ge(e) {
            return e instanceof qe
        }

        function He(e) {
            let t, n, r, i = !1,
                o = 0,
                s = !1;
            const a = new Promise(((e, t) => {
                    n = e, r = t
                })),
                l = () => je.isFocused() && ("always" === e.networkMode || De.isOnline()) && e.canRun(),
                u = () => ze(e.networkMode) && e.canRun(),
                c = r => {
                    s || (s = !0, e.onSuccess ? .(r), t ? .(), n(r))
                },
                d = n => {
                    s || (s = !0, e.onError ? .(n), t ? .(), r(n))
                },
                h = () => new Promise((n => {
                    t = e => {
                        (s || l()) && n(e)
                    }, e.onPause ? .()
                })).then((() => {
                    t = void 0, s || e.onContinue ? .()
                })),
                f = () => {
                    if (s) return;
                    let t;
                    const n = 0 === o ? e.initialPromise : void 0;
                    try {
                        t = n ? ? e.fn()
                    } catch (r) {
                        t = Promise.reject(r)
                    }
                    Promise.resolve(t).then(c).catch((t => {
                        if (s) return;
                        const n = e.retry ? ? (me ? 0 : 3),
                            r = e.retryDelay ? ? Ue,
                            a = "function" === typeof r ? r(o, t) : r,
                            u = !0 === n || "number" === typeof n && o < n || "function" === typeof n && n(o, t);
                        var c;
                        !i && u ? (o++, e.onFail ? .(o, t), (c = a, new Promise((e => {
                            setTimeout(e, c)
                        }))).then((() => l() ? void 0 : h())).then((() => {
                            i ? d(t) : f()
                        }))) : d(t)
                    }))
                };
            return {
                promise: a,
                cancel: t => {
                    s || (d(new qe(t)), e.abort ? .())
                },
                continue: () => (t ? .(), a),
                cancelRetry: () => {
                    i = !0
                },
                continueRetry: () => {
                    i = !1
                },
                canStart: u,
                start: () => (u() ? f() : h().then(f), a)
            }
        }
        var $e = class extends Be {#
            o;#
            s;#
            a;
            constructor(e) {
                super(), this.mutationId = e.mutationId, this.#s = e.mutationCache, this.#o = [], this.state = e.state || {
                    context: void 0,
                    data: void 0,
                    error: null,
                    failureCount: 0,
                    failureReason: null,
                    isPaused: !1,
                    status: "idle",
                    variables: void 0,
                    submittedAt: 0
                }, this.setOptions(e.options), this.scheduleGc()
            }
            setOptions(e) {
                this.options = e, this.updateGcTime(this.options.gcTime)
            }
            get meta() {
                return this.options.meta
            }
            addObserver(e) {
                this.#o.includes(e) || (this.#o.push(e), this.clearGcTimeout(), this.#s.notify({
                    type: "observerAdded",
                    mutation: this,
                    observer: e
                }))
            }
            removeObserver(e) {
                this.#o = this.#o.filter((t => t !== e)), this.scheduleGc(), this.#s.notify({
                    type: "observerRemoved",
                    mutation: this,
                    observer: e
                })
            }
            optionalRemove() {
                this.#o.length || ("pending" === this.state.status ? this.scheduleGc() : this.#s.remove(this))
            }
            continue () {
                return this.#a ? .continue() ? ? this.execute(this.state.variables)
            }
            async execute(e) {
                this.#a = He({
                    fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
                    onFail: (e, t) => {
                        this.#l({
                            type: "failed",
                            failureCount: e,
                            error: t
                        })
                    },
                    onPause: () => {
                        this.#l({
                            type: "pause"
                        })
                    },
                    onContinue: () => {
                        this.#l({
                            type: "continue"
                        })
                    },
                    retry: this.options.retry ? ? 0,
                    retryDelay: this.options.retryDelay,
                    networkMode: this.options.networkMode,
                    canRun: () => this.#s.canRun(this)
                });
                const t = "pending" === this.state.status,
                    n = !this.#a.canStart();
                try {
                    if (!t) {
                        this.#l({
                            type: "pending",
                            variables: e,
                            isPaused: n
                        }), await (this.#s.config.onMutate ? .(e, this));
                        const t = await (this.options.onMutate ? .(e));
                        t !== this.state.context && this.#l({
                            type: "pending",
                            context: t,
                            variables: e,
                            isPaused: n
                        })
                    }
                    const r = await this.#a.start();
                    return await (this.#s.config.onSuccess ? .(r, e, this.state.context, this)), await (this.options.onSuccess ? .(r, e, this.state.context)), await (this.#s.config.onSettled ? .(r, null, this.state.variables, this.state.context, this)), await (this.options.onSettled ? .(r, null, e, this.state.context)), this.#l({
                        type: "success",
                        data: r
                    }), r
                } catch (r) {
                    try {
                        throw await (this.#s.config.onError ? .(r, e, this.state.context, this)), await (this.options.onError ? .(r, e, this.state.context)), await (this.#s.config.onSettled ? .(void 0, r, this.state.variables, this.state.context, this)), await (this.options.onSettled ? .(void 0, r, e, this.state.context)), r
                    } finally {
                        this.#l({
                            type: "error",
                            error: r
                        })
                    }
                } finally {
                    this.#s.runNext(this)
                }
            }#
            l(e) {
                this.state = (t => {
                    switch (e.type) {
                        case "failed":
                            return { ...t,
                                failureCount: e.failureCount,
                                failureReason: e.error
                            };
                        case "pause":
                            return { ...t,
                                isPaused: !0
                            };
                        case "continue":
                            return { ...t,
                                isPaused: !1
                            };
                        case "pending":
                            return { ...t,
                                context: e.context,
                                data: void 0,
                                failureCount: 0,
                                failureReason: null,
                                error: null,
                                isPaused: e.isPaused,
                                status: "pending",
                                variables: e.variables,
                                submittedAt: Date.now()
                            };
                        case "success":
                            return { ...t,
                                data: e.data,
                                failureCount: 0,
                                failureReason: null,
                                error: null,
                                status: "success",
                                isPaused: !1
                            };
                        case "error":
                            return { ...t,
                                data: void 0,
                                error: e.error,
                                failureCount: t.failureCount + 1,
                                failureReason: e.error,
                                isPaused: !1,
                                status: "error"
                            }
                    }
                })(this.state), pe.batch((() => {
                    this.#o.forEach((t => {
                        t.onMutationUpdate(e)
                    })), this.#s.notify({
                        mutation: this,
                        type: "updated",
                        action: e
                    })
                }))
            }
        };
        var Qe = class extends Fe {#
                u;#
                c = void 0;#
                d;#
                h;
                constructor(e, t) {
                    super(), this.#u = e, this.setOptions(t), this.bindMethods(), this.#f()
                }
                bindMethods() {
                    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this)
                }
                setOptions(e) {
                    const t = this.options;
                    this.options = this.#u.defaultMutationOptions(e), Se(this.options, t) || this.#u.getMutationCache().notify({
                        type: "observerOptionsUpdated",
                        mutation: this.#d,
                        observer: this
                    }), t ? .mutationKey && this.options.mutationKey && ke(t.mutationKey) !== ke(this.options.mutationKey) ? this.reset() : "pending" === this.#d ? .state.status && this.#d.setOptions(this.options)
                }
                onUnsubscribe() {
                    this.hasListeners() || this.#d ? .removeObserver(this)
                }
                onMutationUpdate(e) {
                    this.#f(), this.#p(e)
                }
                getCurrentResult() {
                    return this.#c
                }
                reset() {
                    this.#d ? .removeObserver(this), this.#d = void 0, this.#f(), this.#p()
                }
                mutate(e, t) {
                    return this.#h = t, this.#d ? .removeObserver(this), this.#d = this.#u.getMutationCache().build(this.#u, this.options), this.#d.addObserver(this), this.#d.execute(e)
                }#
                f() {
                    const e = this.#d ? .state ? ? {
                        context: void 0,
                        data: void 0,
                        error: null,
                        failureCount: 0,
                        failureReason: null,
                        isPaused: !1,
                        status: "idle",
                        variables: void 0,
                        submittedAt: 0
                    };
                    this.#c = { ...e,
                        isPending: "pending" === e.status,
                        isSuccess: "success" === e.status,
                        isError: "error" === e.status,
                        isIdle: "idle" === e.status,
                        mutate: this.mutate,
                        reset: this.reset
                    }
                }#
                p(e) {
                    pe.batch((() => {
                        if (this.#h && this.hasListeners()) {
                            const t = this.#c.variables,
                                n = this.#c.context;
                            "success" === e ? .type ? (this.#h.onSuccess ? .(e.data, t, n), this.#h.onSettled ? .(e.data, null, t, n)) : "error" === e ? .type && (this.#h.onError ? .(e.error, t, n), this.#h.onSettled ? .(void 0, e.error, t, n))
                        }
                        this.listeners.forEach((e => {
                            e(this.#c)
                        }))
                    }))
                }
            },
            Ve = r.createContext(void 0),
            Ke = e => {
                const t = r.useContext(Ve);
                if (e) return e;
                if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one");
                return t
            },
            We = e => {
                let {
                    client: t,
                    children: n
                } = e;
                return r.useEffect((() => (t.mount(), () => {
                    t.unmount()
                })), [t]), (0, he.jsx)(Ve.Provider, {
                    value: t,
                    children: n
                })
            };

        function Je(e, t) {
            return "function" === typeof e ? e(...t) : !!e
        }

        function Ze() {}

        function Ye(e, t) {
            const n = Ke(t),
                [i] = r.useState((() => new Qe(n, e)));
            r.useEffect((() => {
                i.setOptions(e)
            }), [i, e]);
            const o = r.useSyncExternalStore(r.useCallback((e => i.subscribe(pe.batchCalls(e))), [i]), (() => i.getCurrentResult()), (() => i.getCurrentResult())),
                s = r.useCallback(((e, t) => {
                    i.mutate(e, t).catch(Ze)
                }), [i]);
            if (o.error && Je(i.options.throwOnError, [o.error])) throw o.error;
            return { ...o,
                mutate: s,
                mutateAsync: o.mutate
            }
        }
        const Xe = "2.10.2";
        var et, tt, nt = function(e, t, n, r) {
            if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
            if ("function" === typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e)
        };
        class rt extends Error {
            get docsBaseUrl() {
                return "https://wagmi.sh/core"
            }
            get version() {
                return `@wagmi/core@${Xe}`
            }
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                super(), et.add(this), Object.defineProperty(this, "details", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "docsPath", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "metaMessages", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "shortMessage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "WagmiCoreError"
                });
                const n = t.cause instanceof rt ? t.cause.details : t.cause ? .message ? t.cause.message : t.details,
                    r = t.cause instanceof rt && t.cause.docsPath || t.docsPath;
                this.message = [e || "An error occurred.", "", ...t.metaMessages ? [...t.metaMessages, ""] : [], ...r ? [`Docs: ${this.docsBaseUrl}${r}.html${t.docsSlug?`#${t.docsSlug}`:""}`] : [], ...n ? [`Details: ${n}`] : [], `Version: ${this.version}`].join("\n"), t.cause && (this.cause = t.cause), this.details = n, this.docsPath = r, this.metaMessages = t.metaMessages, this.shortMessage = e
            }
            walk(e) {
                return nt(this, et, "m", tt).call(this, this, e)
            }
        }
        et = new WeakSet, tt = function e(t, n) {
            return n ? .(t) ? t : t.cause ? nt(this, et, "m", e).call(this, t.cause, n) : t
        };
        class it extends rt {
            constructor() {
                super("Chain not configured."), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ChainNotConfiguredError"
                })
            }
        }
        class ot extends rt {
            constructor() {
                super("Connector already connected."), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ConnectorAlreadyConnectedError"
                })
            }
        }
        class st extends rt {
            constructor() {
                super("Connector not connected."), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ConnectorNotConnectedError"
                })
            }
        }
        class at extends rt {
            constructor(e) {
                let {
                    address: t,
                    connector: n
                } = e;
                super(`Account "${t}" not found for connector "${n.name}".`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ConnectorAccountNotFoundError"
                })
            }
        }

        function lt(e) {
            return {
                mutationFn: t => async function(e, t) {
                    let n;
                    if (n = "function" === typeof t.connector ? e._internal.connectors.setup(t.connector) : t.connector, n.uid === e.state.current) throw new ot;
                    try {
                        e.setState((e => ({ ...e,
                            status: "connecting"
                        }))), n.emitter.emit("message", {
                            type: "connecting"
                        });
                        const r = await n.connect({
                                chainId: t.chainId
                            }),
                            i = r.accounts;
                        return n.emitter.off("connect", e._internal.events.connect), n.emitter.on("change", e._internal.events.change), n.emitter.on("disconnect", e._internal.events.disconnect), await (e.storage ? .setItem("recentConnectorId", n.id)), e.setState((e => ({ ...e,
                            connections: new Map(e.connections).set(n.uid, {
                                accounts: i,
                                chainId: r.chainId,
                                connector: n
                            }),
                            current: n.uid,
                            status: "connected"
                        }))), {
                            accounts: i,
                            chainId: r.chainId
                        }
                    } catch (r) {
                        throw e.setState((e => ({ ...e,
                            status: e.current ? "connected" : "disconnected"
                        }))), r
                    }
                }(e, t),
                mutationKey: ["connect"]
            }
        }
        let ut = !1;

        function ct(e, t) {
            const {
                initialState: n,
                reconnectOnMount: r
            } = t;
            return n && !e._internal.store.persist.hasHydrated() && e.setState({ ...n,
                connections: r ? n.connections : new Map,
                status: r ? "reconnecting" : "disconnected"
            }), {
                async onMount() {
                    if (e._internal.ssr) {
                        await e._internal.store.persist.rehydrate();
                        const t = e._internal.mipd ? .getProviders().map(e._internal.connectors.providerDetailToConnector).map(e._internal.connectors.setup);
                        e._internal.connectors.setState((e => [...e, ...t ? ? []]))
                    }
                    r ? async function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if (ut) return [];
                        ut = !0, e.setState((e => ({ ...e,
                            status: e.current ? "reconnecting" : "connecting"
                        })));
                        const n = [];
                        if (t.connectors ? .length)
                            for (const u of t.connectors) {
                                let t;
                                t = "function" === typeof u ? e._internal.connectors.setup(u) : u, n.push(t)
                            } else n.push(...e.connectors);
                        let r;
                        try {
                            r = await (e.storage ? .getItem("recentConnectorId"))
                        } catch {}
                        const i = {};
                        for (const [, u] of e.state.connections) i[u.connector.id] = 1;
                        r && (i[r] = 0);
                        const o = Object.keys(i).length > 0 ? [...n].sort(((e, t) => (i[e.id] ? ? 10) - (i[t.id] ? ? 10))) : n;
                        let s = !1;
                        const a = [],
                            l = [];
                        for (const u of o) {
                            const t = await u.getProvider();
                            if (!t) continue;
                            if (l.some((e => e === t))) continue;
                            if (!await u.isAuthorized()) continue;
                            const n = await u.connect({
                                isReconnecting: !0
                            }).catch((() => null));
                            n && (u.emitter.off("connect", e._internal.events.connect), u.emitter.on("change", e._internal.events.change), u.emitter.on("disconnect", e._internal.events.disconnect), e.setState((e => {
                                const t = new Map(s ? e.connections : new Map).set(u.uid, {
                                    accounts: n.accounts,
                                    chainId: n.chainId,
                                    connector: u
                                });
                                return { ...e,
                                    current: s ? e.current : u.uid,
                                    connections: t
                                }
                            })), a.push({
                                accounts: n.accounts,
                                chainId: n.chainId,
                                connector: u
                            }), l.push(t), s = !0)
                        }
                        "reconnecting" !== e.state.status && "connecting" !== e.state.status || (s ? e.setState((e => ({ ...e,
                            status: "connected"
                        }))) : e.setState((e => ({ ...e,
                            connections: new Map,
                            current: null,
                            status: "disconnected"
                        })))), ut = !1
                    }(e) : e.storage && e.setState((e => ({ ...e,
                        connections: new Map
                    })))
                }
            }
        }

        function dt(e) {
            const {
                children: t,
                config: n,
                initialState: i,
                reconnectOnMount: o = !0
            } = e, {
                onMount: s
            } = ct(n, {
                initialState: i,
                reconnectOnMount: o
            });
            n._internal.ssr || s();
            const a = (0, r.useRef)(!0);
            return (0, r.useEffect)((() => {
                if (a.current && n._internal.ssr) return s(), () => {
                    a.current = !1
                }
            }), []), t
        }
        const ht = (0, r.createContext)(void 0);

        function ft(e) {
            const {
                children: t,
                config: n
            } = e, i = {
                value: n
            };
            return (0, r.createElement)(dt, e, (0, r.createElement)(ht.Provider, i, t))
        }
        class pt extends rt {
            constructor() {
                super(...arguments), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "WagmiError"
                })
            }
            get docsBaseUrl() {
                return "https://wagmi.sh/react"
            }
            get version() {
                return "wagmi@2.9.2"
            }
        }
        class mt extends pt {
            constructor() {
                super("`useConfig` must be used within `WagmiProvider`.", {
                    docsPath: "/api/WagmiProvider"
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "WagmiProviderNotFoundError"
                })
            }
        }

        function gt() {
            const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).config ? ? (0, r.useContext)(ht);
            if (!e) throw new mt;
            return e
        }

        function yt(e, t) {
            if (e === t) return !0;
            if (e && t && "object" === typeof e && "object" === typeof t) {
                if (e.constructor !== t.constructor) return !1;
                let n, r;
                if (Array.isArray(e) && Array.isArray(t)) {
                    if (n = e.length, n !== t.length) return !1;
                    for (r = n; 0 !== r--;)
                        if (!yt(e[r], t[r])) return !1;
                    return !0
                }
                if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === t.valueOf();
                if (e.toString !== Object.prototype.toString) return e.toString() === t.toString();
                const i = Object.keys(e);
                if (n = i.length, n !== Object.keys(t).length) return !1;
                for (r = n; 0 !== r--;)
                    if (!Object.prototype.hasOwnProperty.call(t, i[r])) return !1;
                for (r = n; 0 !== r--;) {
                    const n = i[r];
                    if (n && !yt(e[n], t[n])) return !1
                }
                return !0
            }
            return e !== e && t !== t
        }
        let vt = [];

        function bt(e) {
            const t = e.connectors;
            return yt(vt, t) ? vt : (vt = t, t)
        }

        function wt() {
            const e = gt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {});
            return (0, r.useSyncExternalStore)((t => function(e, t) {
                const {
                    onChange: n
                } = t;
                return e._internal.connectors.subscribe(((e, t) => {
                    n(Object.values(e), t)
                }))
            }(e, {
                onChange: t
            })), (() => bt(e)), (() => bt(e)))
        }
        const Et = e => {
            const {
                connectors: t,
                connect: n
            } = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {
                    mutation: t
                } = e, n = gt(e), i = lt(n), {
                    mutate: o,
                    mutateAsync: s,
                    ...a
                } = Ye({ ...t,
                    ...i
                });
                return (0, r.useEffect)((() => n.subscribe((e => {
                    let {
                        status: t
                    } = e;
                    return t
                }), ((e, t) => {
                    "connected" === t && "disconnected" === e && a.reset()
                }))), [n, a]), { ...a,
                    connect: o,
                    connectAsync: s,
                    connectors: wt({
                        config: n
                    })
                }
            }();
            return (0, he.jsxs)("div", {
                className: "wallet",
                children: [(0, he.jsx)("img", {
                    src: "/images/logo.svg",
                    alt: "logo"
                }), (0, he.jsx)("h2", {
                    className: "pt-4",
                    children: "Connect Wallet"
                }), (0, he.jsx)("div", {
                    className: "text-center flex-wrap flex-md-nowrap  d-flex align-items-center gap-4 justify-content-center pt-5 wallets",
                    children: t.map((e => (0, he.jsxs)("div", {
                        title: e.name,
                        className: "card-custom",
                        children: ["MetaMask" === e.name ? (0, he.jsxs)("svg", {
                            width: "56",
                            height: "57",
                            viewBox: "0 0 56 57",
                            fill: "none",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: [(0, he.jsx)("path", {
                                d: "M49.0087 6.59204L30.7996 20.1728L34.1669 12.1603L49.0087 6.59204Z",
                                fill: "#E2761B"
                            }), (0, he.jsx)("path", {
                                d: "M6.97198 6.59204L25.0347 20.3015L21.8321 12.1603L6.97198 6.59204ZM42.457 38.0722L37.6073 45.5334L47.9837 48.4002L50.9668 38.2376L42.457 38.0722ZM5.05042 38.2376L8.01512 48.4002L18.3916 45.5334L13.5419 38.0722L5.05042 38.2376Z",
                                fill: "#E4761B"
                            }), (0, he.jsx)("path", {
                                d: "M17.8061 25.4655L14.9146 29.8576L25.2178 30.3171L24.8518 19.1988L17.8061 25.4655ZM38.1747 25.4655L31.0374 19.0702L30.7995 30.3171L41.0845 29.8576L38.1747 25.4655ZM18.3917 45.5334L24.5773 42.5012L19.2335 38.3111L18.3917 45.5334ZM31.4034 42.5012L37.6074 45.5334L36.7472 38.3111L31.4034 42.5012Z",
                                fill: "#E4761B"
                            }), (0, he.jsx)("path", {
                                d: "M37.6073 45.5333L31.4034 42.5011L31.8975 46.5625L31.8426 48.2716L37.6073 45.5333ZM18.3916 45.5333L24.1563 48.2716L24.1197 46.5625L24.5772 42.5011L18.3916 45.5333Z",
                                fill: "#D7C1B3"
                            }), (0, he.jsx)("path", {
                                d: "M24.2478 35.6281L19.087 34.1027L22.7289 32.4304L24.2478 35.6281ZM31.7328 35.6281L33.2517 32.4304L36.9119 34.1027L31.7328 35.6281Z",
                                fill: "#233447"
                            }), (0, he.jsx)("path", {
                                d: "M18.3917 45.5334L19.2701 38.0722L13.542 38.2376L18.3917 45.5334ZM36.7289 38.0722L37.6074 45.5334L42.457 38.2376L36.7289 38.0722ZM41.0845 29.8576L30.7995 30.317L31.7511 35.6281L33.2701 32.4304L36.9302 34.1027L41.0845 29.8576ZM19.0871 34.1027L22.7472 32.4304L24.2479 35.6281L25.2178 30.317L14.9145 29.8576L19.0871 34.1027Z",
                                fill: "#CD6116"
                            }), (0, he.jsx)("path", {
                                d: "M14.9146 29.8576L19.2335 38.3111L19.0871 34.1027L14.9146 29.8576ZM36.9302 34.1027L36.7472 38.3111L41.0845 29.8576L36.9302 34.1027ZM25.2178 30.317L24.2479 35.6281L25.4557 41.8947L25.7302 33.6433L25.2178 30.317ZM30.7995 30.317L30.3054 33.6249L30.525 41.8947L31.7511 35.6281L30.7995 30.317Z",
                                fill: "#E4751F"
                            }), (0, he.jsx)("path", {
                                d: "M31.7511 35.6281L30.5249 41.8947L31.4034 42.5012L36.7472 38.3112L36.9302 34.1028L31.7511 35.6281ZM19.087 34.1028L19.2334 38.3112L24.5772 42.5012L25.4557 41.8947L24.2478 35.6281L19.087 34.1028Z",
                                fill: "#F6851B"
                            }), (0, he.jsx)("path", {
                                d: "M31.8426 48.2716L31.8975 46.5625L31.44 46.1582H24.5406L24.1197 46.5625L24.1563 48.2716L18.3916 45.5334L20.4047 47.1873L24.4857 50.0358H31.4949L35.5942 47.1873L37.6073 45.5334L31.8426 48.2716Z",
                                fill: "#C0AD9E"
                            }), (0, he.jsx)("path", {
                                d: "M31.4034 42.5012L30.525 41.8947H25.4557L24.5773 42.5012L24.1198 46.5625L24.5407 46.1582H31.44L31.8975 46.5625L31.4034 42.5012Z",
                                fill: "#161616"
                            }), (0, he.jsx)("path", {
                                d: "M49.7773 21.0549L51.3328 13.557L49.0086 6.59204L31.4034 19.7134L38.1746 25.4655L47.7459 28.2772L49.8688 25.7962L48.9537 25.1347L50.4178 23.7931L49.2831 22.911L50.7472 21.79L49.7773 21.0549ZM4.66614 13.557L6.22169 21.0549L5.23346 21.79L6.69751 22.911L5.58117 23.7931L7.04522 25.1347L6.13019 25.7962L8.23477 28.2772L17.806 25.4655L24.5773 19.7134L6.97202 6.59204L4.66614 13.557Z",
                                fill: "#763D16"
                            }), (0, he.jsx)("path", {
                                d: "M47.7458 28.2772L38.1746 25.4655L41.0844 29.8576L36.7472 38.3111L42.457 38.2376H50.9668L47.7458 28.2772ZM17.806 25.4655L8.23473 28.2772L5.05042 38.2376H13.5419L19.2334 38.3111L14.9145 29.8576L17.806 25.4655ZM30.7994 30.317L31.4034 19.7134L34.1851 12.1603H21.8321L24.5772 19.7134L25.2177 30.317L25.4373 33.6617L25.4556 41.8947H30.5249L30.5615 33.6617L30.7994 30.317Z",
                                fill: "#F6851B"
                            })]
                        }) : "WalletConnect" === e.name ? (0, he.jsxs)("svg", {
                            width: "56",
                            height: "57",
                            viewBox: "0 0 56 57",
                            fill: "none",
                            xmlns: "http://www.w3.org/2000/svg",
                            children: [(0, he.jsx)("circle", {
                                cx: "28",
                                cy: "28.5",
                                r: "28",
                                fill: "#3B99FC"
                            }), (0, he.jsx)("path", {
                                "fill-rule": "evenodd",
                                "clip-rule": "evenodd",
                                d: "M39.0237 21.3922C32.9354 15.3137 23.0644 15.3137 16.9762 21.3922L16.1719 22.1952C15.8675 22.4991 15.8675 22.9919 16.1719 23.2958L18.6785 25.7984C18.8307 25.9503 19.0774 25.9503 19.2296 25.7984L20.3095 24.7202C24.5568 20.4797 31.4431 20.4797 35.6904 24.7202L36.6987 25.727C36.8509 25.8789 37.0977 25.8789 37.2499 25.727L39.7564 23.2244C40.0609 22.9205 40.0609 22.4277 39.7564 22.1238L39.0237 21.3922ZM46.4383 28.795L44.2075 26.5678C43.903 26.2638 43.4095 26.2638 43.1051 26.5678L35.9659 33.6956C35.8898 33.7715 35.7664 33.7715 35.6903 33.6956L28.551 26.5676L28.551 26.5676C28.2466 26.2637 27.753 26.2637 27.4486 26.5676L20.3097 33.6956C20.2336 33.7716 20.1102 33.7716 20.0341 33.6956L12.8948 26.5676C12.5903 26.2637 12.0968 26.2637 11.7924 26.5676L9.56156 28.7949C9.25715 29.0988 9.25715 29.5916 9.56156 29.8955L19.6208 39.9387C19.9252 40.2426 20.4187 40.2426 20.7231 39.9387L27.8622 32.8109C27.9383 32.7349 28.0617 32.7349 28.1378 32.8109L35.277 39.9387C35.5814 40.2426 36.075 40.2426 36.3794 39.9387L46.4383 29.8956C46.7427 29.5917 46.7427 29.099 46.4383 28.795Z",
                                fill: "white"
                            })]
                        }) : (0, he.jsx)("img", {
                            style: {
                                width: 56,
                                height: 57
                            },
                            src: e.icon
                        }), (0, he.jsx)("div", {
                            style: {
                                marginTop: 10
                            }
                        }), (0, he.jsx)("p", {
                            className: "text-truncate",
                            style: {
                                color: " #B9DCEA !important",
                                cursor: "pointer"
                            },
                            children: e.name
                        }), (0, he.jsx)("button", {
                            className: "mt-3",
                            onClick: () => (e => {
                                n({
                                    connector: e
                                })
                            })(e),
                            children: "Connect"
                        }, e.uid)]
                    })))
                }), (0, he.jsxs)("div", {
                    className: "help pt-5",
                    children: ["Need help?", " ", (0, he.jsxs)("a", {
                        href: "https://learn.metamask.io/lessons/what-is-a-crypto-wallet",
                        children: [" ", "How to Connect Your Wallet"]
                    })]
                })]
            })
        };
        var xt = n(8139),
            At = n.n(xt);
        const kt = !("undefined" === typeof window || !window.document || !window.document.createElement);
        var Ct = !1,
            Pt = !1;
        try {
            var St = {
                get passive() {
                    return Ct = !0
                },
                get once() {
                    return Pt = Ct = !0
                }
            };
            kt && (window.addEventListener("test", St, St), window.removeEventListener("test", St, !0))
        } catch (dg) {}
        const _t = function(e, t, n, r) {
            if (r && "boolean" !== typeof r && !Pt) {
                var i = r.once,
                    o = r.capture,
                    s = n;
                !Pt && i && (s = n.__once || function e(r) {
                    this.removeEventListener(t, e, o), n.call(this, r)
                }, n.__once = s), e.addEventListener(t, s, Ct ? r : o)
            }
            e.addEventListener(t, n, r)
        };

        function Nt(e) {
            return e && e.ownerDocument || document
        }
        const Mt = function(e, t, n, r) {
            var i = r && "boolean" !== typeof r ? r.capture : r;
            e.removeEventListener(t, n, i), n.__once && e.removeEventListener(t, n.__once, i)
        };
        var It;

        function Ot(e) {
            if ((!It && 0 !== It || e) && kt) {
                var t = document.createElement("div");
                t.style.position = "absolute", t.style.top = "-9999px", t.style.width = "50px", t.style.height = "50px", t.style.overflow = "scroll", document.body.appendChild(t), It = t.offsetWidth - t.clientWidth, document.body.removeChild(t)
            }
            return It
        }
        const Tt = function(e) {
            const t = (0, r.useRef)(e);
            return (0, r.useEffect)((() => {
                t.current = e
            }), [e]), t
        };

        function Rt(e) {
            const t = Tt(e);
            return (0, r.useCallback)((function() {
                return t.current && t.current(...arguments)
            }), [t])
        }
        const Lt = e => e && "function" !== typeof e ? t => {
            e.current = t
        } : e;
        const Bt = function(e, t) {
            return (0, r.useMemo)((() => function(e, t) {
                const n = Lt(e),
                    r = Lt(t);
                return e => {
                    n && n(e), r && r(e)
                }
            }(e, t)), [e, t])
        };

        function Ft(e) {
            const t = function(e) {
                const t = (0, r.useRef)(e);
                return t.current = e, t
            }(e);
            (0, r.useEffect)((() => () => t.current()), [])
        }

        function jt(e, t) {
            return function(e) {
                var t = Nt(e);
                return t && t.defaultView || window
            }(e).getComputedStyle(e, t)
        }
        var Dt = /([A-Z])/g;
        var Ut = /^ms-/;

        function zt(e) {
            return function(e) {
                return e.replace(Dt, "-$1").toLowerCase()
            }(e).replace(Ut, "-ms-")
        }
        var qt = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;
        const Gt = function(e, t) {
            var n = "",
                r = "";
            if ("string" === typeof t) return e.style.getPropertyValue(zt(t)) || jt(e).getPropertyValue(zt(t));
            Object.keys(t).forEach((function(i) {
                var o = t[i];
                o || 0 === o ? ! function(e) {
                    return !(!e || !qt.test(e))
                }(i) ? n += zt(i) + ": " + o + ";" : r += i + "(" + o + ") " : e.style.removeProperty(zt(i))
            })), r && (n += "transform: " + r + ";"), e.style.cssText += ";" + n
        };
        const Ht = function(e, t, n, r) {
            return _t(e, t, n, r),
                function() {
                    Mt(e, t, n, r)
                }
        };

        function $t(e, t, n) {
            void 0 === n && (n = 5);
            var r = !1,
                i = setTimeout((function() {
                    r || function(e, t, n, r) {
                        if (void 0 === n && (n = !1), void 0 === r && (r = !0), e) {
                            var i = document.createEvent("HTMLEvents");
                            i.initEvent(t, n, r), e.dispatchEvent(i)
                        }
                    }(e, "transitionend", !0)
                }), t + n),
                o = Ht(e, "transitionend", (function() {
                    r = !0
                }), {
                    once: !0
                });
            return function() {
                clearTimeout(i), o()
            }
        }

        function Qt(e, t, n, r) {
            null == n && (n = function(e) {
                var t = Gt(e, "transitionDuration") || "",
                    n = -1 === t.indexOf("ms") ? 1e3 : 1;
                return parseFloat(t) * n
            }(e) || 0);
            var i = $t(e, n, r),
                o = Ht(e, "transitionend", t);
            return function() {
                i(), o()
            }
        }

        function Vt(e) {
            void 0 === e && (e = Nt());
            try {
                var t = e.activeElement;
                return t && t.nodeName ? t : null
            } catch (dg) {
                return e.body
            }
        }

        function Kt(e, t) {
            return e.contains ? e.contains(t) : e.compareDocumentPosition ? e === t || !!(16 & e.compareDocumentPosition(t)) : void 0
        }
        const Wt = `data-rr-ui-${"modal-open"}`;
        const Jt = class {
                constructor() {
                    let {
                        ownerDocument: e,
                        handleContainerOverflow: t = !0,
                        isRTL: n = !1
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    this.handleContainerOverflow = t, this.isRTL = n, this.modals = [], this.ownerDocument = e
                }
                getScrollbarWidth() {
                    return function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document;
                        const t = e.defaultView;
                        return Math.abs(t.innerWidth - e.documentElement.clientWidth)
                    }(this.ownerDocument)
                }
                getElement() {
                    return (this.ownerDocument || document).body
                }
                setModalAttributes(e) {}
                removeModalAttributes(e) {}
                setContainerStyle(e) {
                    const t = {
                            overflow: "hidden"
                        },
                        n = this.isRTL ? "paddingLeft" : "paddingRight",
                        r = this.getElement();
                    e.style = {
                        overflow: r.style.overflow,
                        [n]: r.style[n]
                    }, e.scrollBarWidth && (t[n] = `${parseInt(Gt(r,n)||"0",10)+e.scrollBarWidth}px`), r.setAttribute(Wt, ""), Gt(r, t)
                }
                reset() {
                    [...this.modals].forEach((e => this.remove(e)))
                }
                removeContainerStyle(e) {
                    const t = this.getElement();
                    t.removeAttribute(Wt), Object.assign(t.style, e.style)
                }
                add(e) {
                    let t = this.modals.indexOf(e);
                    return -1 !== t ? t : (t = this.modals.length, this.modals.push(e), this.setModalAttributes(e), 0 !== t || (this.state = {
                        scrollBarWidth: this.getScrollbarWidth(),
                        style: {}
                    }, this.handleContainerOverflow && this.setContainerStyle(this.state)), t)
                }
                remove(e) {
                    const t = this.modals.indexOf(e); - 1 !== t && (this.modals.splice(t, 1), !this.modals.length && this.handleContainerOverflow && this.removeContainerStyle(this.state), this.removeModalAttributes(e))
                }
                isTopModal(e) {
                    return !!this.modals.length && this.modals[this.modals.length - 1] === e
                }
            },
            Zt = (0, r.createContext)(kt ? window : void 0);
        Zt.Provider;

        function Yt() {
            return (0, r.useContext)(Zt)
        }
        const Xt = (e, t) => kt ? null == e ? (t || Nt()).body : ("function" === typeof e && (e = e()), e && "current" in e && (e = e.current), e && ("nodeType" in e || e.getBoundingClientRect) ? e : null) : null;
        const en = "undefined" !== typeof n.g && n.g.navigator && "ReactNative" === n.g.navigator.product,
            tn = "undefined" !== typeof document || en ? r.useLayoutEffect : r.useEffect;
        const nn = function(e) {
            let {
                children: t,
                in: n,
                onExited: i,
                mountOnEnter: o,
                unmountOnExit: s
            } = e;
            const a = (0, r.useRef)(null),
                l = (0, r.useRef)(n),
                u = Rt(i);
            (0, r.useEffect)((() => {
                n ? l.current = !0 : u(a.current)
            }), [n, u]);
            const c = Bt(a, t.ref),
                d = (0, r.cloneElement)(t, {
                    ref: c
                });
            return n ? d : s || !l.current && o ? null : d
        };
        const rn = ["onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "addEndListener", "children"];

        function on(e) {
            let {
                onEnter: t,
                onEntering: n,
                onEntered: i,
                onExit: o,
                onExiting: s,
                onExited: a,
                addEndListener: l,
                children: u
            } = e, c = function(e, t) {
                if (null == e) return {};
                var n = {};
                for (var r in e)
                    if ({}.hasOwnProperty.call(e, r)) {
                        if (t.indexOf(r) >= 0) continue;
                        n[r] = e[r]
                    }
                return n
            }(e, rn);
            const {
                major: d
            } = function() {
                const e = r.version.split(".");
                return {
                    major: +e[0],
                    minor: +e[1],
                    patch: +e[2]
                }
            }(), h = d >= 19 ? u.props.ref : u.ref, f = (0, r.useRef)(null), p = Bt(f, "function" === typeof u ? null : h), m = e => t => {
                e && f.current && e(f.current, t)
            }, g = (0, r.useCallback)(m(t), [t]), y = (0, r.useCallback)(m(n), [n]), v = (0, r.useCallback)(m(i), [i]), b = (0, r.useCallback)(m(o), [o]), w = (0, r.useCallback)(m(s), [s]), E = (0, r.useCallback)(m(a), [a]), x = (0, r.useCallback)(m(l), [l]);
            return Object.assign({}, c, {
                nodeRef: f
            }, t && {
                onEnter: g
            }, n && {
                onEntering: y
            }, i && {
                onEntered: v
            }, o && {
                onExit: b
            }, s && {
                onExiting: w
            }, a && {
                onExited: E
            }, l && {
                addEndListener: x
            }, {
                children: "function" === typeof u ? (e, t) => u(e, Object.assign({}, t, {
                    ref: p
                })) : (0, r.cloneElement)(u, {
                    ref: p
                })
            })
        }
        const sn = ["component"];
        const an = r.forwardRef(((e, t) => {
                let {
                    component: n
                } = e, r = function(e, t) {
                    if (null == e) return {};
                    var n = {};
                    for (var r in e)
                        if ({}.hasOwnProperty.call(e, r)) {
                            if (t.indexOf(r) >= 0) continue;
                            n[r] = e[r]
                        }
                    return n
                }(e, sn);
                const i = on(r);
                return (0, he.jsx)(n, Object.assign({
                    ref: t
                }, i))
            })),
            ln = an;

        function un(e) {
            let {
                children: t,
                in: n,
                onExited: i,
                onEntered: o,
                transition: s
            } = e;
            const [a, l] = (0, r.useState)(!n);
            n && a && l(!1);
            const u = function(e) {
                    let { in: t, onTransition: n
                    } = e;
                    const i = (0, r.useRef)(null),
                        o = (0, r.useRef)(!0),
                        s = Rt(n);
                    return tn((() => {
                        if (!i.current) return;
                        let e = !1;
                        return s({ in: t,
                            element: i.current,
                            initial: o.current,
                            isStale: () => e
                        }), () => {
                            e = !0
                        }
                    }), [t, s]), tn((() => (o.current = !1, () => {
                        o.current = !0
                    })), []), i
                }({ in: !!n,
                    onTransition: e => {
                        Promise.resolve(s(e)).then((() => {
                            e.isStale() || (e.in ? null == o || o(e.element, e.initial) : (l(!0), null == i || i(e.element)))
                        }), (t => {
                            throw e.in || l(!0), t
                        }))
                    }
                }),
                c = Bt(u, t.ref);
            return a && !n ? null : (0, r.cloneElement)(t, {
                ref: c
            })
        }

        function cn(e, t, n) {
            return e ? (0, he.jsx)(ln, Object.assign({}, n, {
                component: e
            })) : t ? (0, he.jsx)(un, Object.assign({}, n, {
                transition: t
            })) : (0, he.jsx)(nn, Object.assign({}, n))
        }
        const dn = ["show", "role", "className", "style", "children", "backdrop", "keyboard", "onBackdropClick", "onEscapeKeyDown", "transition", "runTransition", "backdropTransition", "runBackdropTransition", "autoFocus", "enforceFocus", "restoreFocus", "restoreFocusOptions", "renderDialog", "renderBackdrop", "manager", "container", "onShow", "onHide", "onExit", "onExited", "onExiting", "onEnter", "onEntering", "onEntered"];
        let hn;

        function fn(e) {
            const t = Yt(),
                n = e || function(e) {
                    return hn || (hn = new Jt({
                        ownerDocument: null == e ? void 0 : e.document
                    })), hn
                }(t),
                i = (0, r.useRef)({
                    dialog: null,
                    backdrop: null
                });
            return Object.assign(i.current, {
                add: () => n.add(i.current),
                remove: () => n.remove(i.current),
                isTopModal: () => n.isTopModal(i.current),
                setDialogRef: (0, r.useCallback)((e => {
                    i.current.dialog = e
                }), []),
                setBackdropRef: (0, r.useCallback)((e => {
                    i.current.backdrop = e
                }), [])
            })
        }
        const pn = (0, r.forwardRef)(((e, t) => {
            let {
                show: n = !1,
                role: i = "dialog",
                className: o,
                style: a,
                children: l,
                backdrop: u = !0,
                keyboard: c = !0,
                onBackdropClick: d,
                onEscapeKeyDown: h,
                transition: f,
                runTransition: p,
                backdropTransition: m,
                runBackdropTransition: g,
                autoFocus: y = !0,
                enforceFocus: v = !0,
                restoreFocus: b = !0,
                restoreFocusOptions: w,
                renderDialog: E,
                renderBackdrop: x = e => (0, he.jsx)("div", Object.assign({}, e)),
                manager: A,
                container: k,
                onShow: C,
                onHide: P = () => {},
                onExit: S,
                onExited: _,
                onExiting: N,
                onEnter: M,
                onEntering: I,
                onEntered: O
            } = e, T = function(e, t) {
                if (null == e) return {};
                var n = {};
                for (var r in e)
                    if ({}.hasOwnProperty.call(e, r)) {
                        if (t.indexOf(r) >= 0) continue;
                        n[r] = e[r]
                    }
                return n
            }(e, dn);
            const R = Yt(),
                L = function(e, t) {
                    const n = Yt(),
                        [i, o] = (0, r.useState)((() => Xt(e, null == n ? void 0 : n.document)));
                    if (!i) {
                        const t = Xt(e);
                        t && o(t)
                    }
                    return (0, r.useEffect)((() => {
                        t && i && t(i)
                    }), [t, i]), (0, r.useEffect)((() => {
                        const t = Xt(e);
                        t !== i && o(t)
                    }), [e, i]), i
                }(k),
                B = fn(A),
                F = function() {
                    const e = (0, r.useRef)(!0),
                        t = (0, r.useRef)((() => e.current));
                    return (0, r.useEffect)((() => (e.current = !0, () => {
                        e.current = !1
                    })), []), t.current
                }(),
                j = function(e) {
                    const t = (0, r.useRef)(null);
                    return (0, r.useEffect)((() => {
                        t.current = e
                    })), t.current
                }(n),
                [D, U] = (0, r.useState)(!n),
                z = (0, r.useRef)(null);
            (0, r.useImperativeHandle)(t, (() => B), [B]), kt && !j && n && (z.current = Vt(null == R ? void 0 : R.document)), n && D && U(!1);
            const q = Rt((() => {
                    if (B.add(), K.current = Ht(document, "keydown", Q), V.current = Ht(document, "focus", (() => setTimeout(H)), !0), C && C(), y) {
                        var e, t;
                        const n = Vt(null != (e = null == (t = B.dialog) ? void 0 : t.ownerDocument) ? e : null == R ? void 0 : R.document);
                        B.dialog && n && !Kt(B.dialog, n) && (z.current = n, B.dialog.focus())
                    }
                })),
                G = Rt((() => {
                    var e;
                    (B.remove(), null == K.current || K.current(), null == V.current || V.current(), b) && (null == (e = z.current) || null == e.focus || e.focus(w), z.current = null)
                }));
            (0, r.useEffect)((() => {
                n && L && q()
            }), [n, L, q]), (0, r.useEffect)((() => {
                D && G()
            }), [D, G]), Ft((() => {
                G()
            }));
            const H = Rt((() => {
                    if (!v || !F() || !B.isTopModal()) return;
                    const e = Vt(null == R ? void 0 : R.document);
                    B.dialog && e && !Kt(B.dialog, e) && B.dialog.focus()
                })),
                $ = Rt((e => {
                    e.target === e.currentTarget && (null == d || d(e), !0 === u && P())
                })),
                Q = Rt((e => {
                    c && function(e) {
                        return "Escape" === e.code || 27 === e.keyCode
                    }(e) && B.isTopModal() && (null == h || h(e), e.defaultPrevented || P())
                })),
                V = (0, r.useRef)(),
                K = (0, r.useRef)();
            if (!L) return null;
            const W = Object.assign({
                role: i,
                ref: B.setDialogRef,
                "aria-modal": "dialog" === i || void 0
            }, T, {
                style: a,
                className: o,
                tabIndex: -1
            });
            let J = E ? E(W) : (0, he.jsx)("div", Object.assign({}, W, {
                children: r.cloneElement(l, {
                    role: "document"
                })
            }));
            J = cn(f, p, {
                unmountOnExit: !0,
                mountOnEnter: !0,
                appear: !0,
                in: !!n,
                onExit: S,
                onExiting: N,
                onExited: function() {
                    U(!0), null == _ || _(...arguments)
                },
                onEnter: M,
                onEntering: I,
                onEntered: O,
                children: J
            });
            let Z = null;
            return u && (Z = x({
                ref: B.setBackdropRef,
                onClick: $
            }), Z = cn(m, g, { in: !!n,
                appear: !0,
                mountOnEnter: !0,
                unmountOnExit: !0,
                children: Z
            })), (0, he.jsx)(he.Fragment, {
                children: s.createPortal((0, he.jsxs)(he.Fragment, {
                    children: [Z, J]
                }), L)
            })
        }));
        pn.displayName = "Modal";
        const mn = Object.assign(pn, {
            Manager: Jt
        });
        var gn = Function.prototype.bind.call(Function.prototype.call, [].slice);

        function yn(e, t) {
            return gn(e.querySelectorAll(t))
        }

        function vn(e, t) {
            return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
        }
        const bn = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
            wn = ".sticky-top",
            En = ".navbar-toggler";
        class xn extends Jt {
            adjustAndStore(e, t, n) {
                const r = t.style[e];
                t.dataset[e] = r, Gt(t, {
                    [e]: `${parseFloat(Gt(t,e))+n}px`
                })
            }
            restore(e, t) {
                const n = t.dataset[e];
                void 0 !== n && (delete t.dataset[e], Gt(t, {
                    [e]: n
                }))
            }
            setContainerStyle(e) {
                super.setContainerStyle(e);
                const t = this.getElement();
                var n, r;
                if (r = "modal-open", (n = t).classList ? n.classList.add(r) : function(e, t) {
                        return e.classList ? !!t && e.classList.contains(t) : -1 !== (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ")
                    }(n, r) || ("string" === typeof n.className ? n.className = n.className + " " + r : n.setAttribute("class", (n.className && n.className.baseVal || "") + " " + r)), !e.scrollBarWidth) return;
                const i = this.isRTL ? "paddingLeft" : "paddingRight",
                    o = this.isRTL ? "marginLeft" : "marginRight";
                yn(t, bn).forEach((t => this.adjustAndStore(i, t, e.scrollBarWidth))), yn(t, wn).forEach((t => this.adjustAndStore(o, t, -e.scrollBarWidth))), yn(t, En).forEach((t => this.adjustAndStore(o, t, e.scrollBarWidth)))
            }
            removeContainerStyle(e) {
                super.removeContainerStyle(e);
                const t = this.getElement();
                var n, r;
                r = "modal-open", (n = t).classList ? n.classList.remove(r) : "string" === typeof n.className ? n.className = vn(n.className, r) : n.setAttribute("class", vn(n.className && n.className.baseVal || "", r));
                const i = this.isRTL ? "paddingLeft" : "paddingRight",
                    o = this.isRTL ? "marginLeft" : "marginRight";
                yn(t, bn).forEach((e => this.restore(i, e))), yn(t, wn).forEach((e => this.restore(o, e))), yn(t, En).forEach((e => this.restore(o, e)))
            }
        }
        let An;

        function kn(e, t) {
            return kn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                return e.__proto__ = t, e
            }, kn(e, t)
        }
        const Cn = !1,
            Pn = r.createContext(null);
        var Sn = "unmounted",
            _n = "exited",
            Nn = "entering",
            Mn = "entered",
            In = "exiting",
            On = function(e) {
                var t, n;

                function i(t, n) {
                    var r;
                    r = e.call(this, t, n) || this;
                    var i, o = n && !n.isMounting ? t.enter : t.appear;
                    return r.appearStatus = null, t.in ? o ? (i = _n, r.appearStatus = Nn) : i = Mn : i = t.unmountOnExit || t.mountOnEnter ? Sn : _n, r.state = {
                        status: i
                    }, r.nextCallback = null, r
                }
                n = e, (t = i).prototype = Object.create(n.prototype), t.prototype.constructor = t, kn(t, n), i.getDerivedStateFromProps = function(e, t) {
                    return e.in && t.status === Sn ? {
                        status: _n
                    } : null
                };
                var o = i.prototype;
                return o.componentDidMount = function() {
                    this.updateStatus(!0, this.appearStatus)
                }, o.componentDidUpdate = function(e) {
                    var t = null;
                    if (e !== this.props) {
                        var n = this.state.status;
                        this.props.in ? n !== Nn && n !== Mn && (t = Nn) : n !== Nn && n !== Mn || (t = In)
                    }
                    this.updateStatus(!1, t)
                }, o.componentWillUnmount = function() {
                    this.cancelNextCallback()
                }, o.getTimeouts = function() {
                    var e, t, n, r = this.props.timeout;
                    return e = t = n = r, null != r && "number" !== typeof r && (e = r.exit, t = r.enter, n = void 0 !== r.appear ? r.appear : t), {
                        exit: e,
                        enter: t,
                        appear: n
                    }
                }, o.updateStatus = function(e, t) {
                    if (void 0 === e && (e = !1), null !== t)
                        if (this.cancelNextCallback(), t === Nn) {
                            if (this.props.unmountOnExit || this.props.mountOnEnter) {
                                var n = this.props.nodeRef ? this.props.nodeRef.current : s.findDOMNode(this);
                                n && function(e) {
                                    e.scrollTop
                                }(n)
                            }
                            this.performEnter(e)
                        } else this.performExit();
                    else this.props.unmountOnExit && this.state.status === _n && this.setState({
                        status: Sn
                    })
                }, o.performEnter = function(e) {
                    var t = this,
                        n = this.props.enter,
                        r = this.context ? this.context.isMounting : e,
                        i = this.props.nodeRef ? [r] : [s.findDOMNode(this), r],
                        o = i[0],
                        a = i[1],
                        l = this.getTimeouts(),
                        u = r ? l.appear : l.enter;
                    !e && !n || Cn ? this.safeSetState({
                        status: Mn
                    }, (function() {
                        t.props.onEntered(o)
                    })) : (this.props.onEnter(o, a), this.safeSetState({
                        status: Nn
                    }, (function() {
                        t.props.onEntering(o, a), t.onTransitionEnd(u, (function() {
                            t.safeSetState({
                                status: Mn
                            }, (function() {
                                t.props.onEntered(o, a)
                            }))
                        }))
                    })))
                }, o.performExit = function() {
                    var e = this,
                        t = this.props.exit,
                        n = this.getTimeouts(),
                        r = this.props.nodeRef ? void 0 : s.findDOMNode(this);
                    t && !Cn ? (this.props.onExit(r), this.safeSetState({
                        status: In
                    }, (function() {
                        e.props.onExiting(r), e.onTransitionEnd(n.exit, (function() {
                            e.safeSetState({
                                status: _n
                            }, (function() {
                                e.props.onExited(r)
                            }))
                        }))
                    }))) : this.safeSetState({
                        status: _n
                    }, (function() {
                        e.props.onExited(r)
                    }))
                }, o.cancelNextCallback = function() {
                    null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null)
                }, o.safeSetState = function(e, t) {
                    t = this.setNextCallback(t), this.setState(e, t)
                }, o.setNextCallback = function(e) {
                    var t = this,
                        n = !0;
                    return this.nextCallback = function(r) {
                        n && (n = !1, t.nextCallback = null, e(r))
                    }, this.nextCallback.cancel = function() {
                        n = !1
                    }, this.nextCallback
                }, o.onTransitionEnd = function(e, t) {
                    this.setNextCallback(t);
                    var n = this.props.nodeRef ? this.props.nodeRef.current : s.findDOMNode(this),
                        r = null == e && !this.props.addEndListener;
                    if (n && !r) {
                        if (this.props.addEndListener) {
                            var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback],
                                o = i[0],
                                a = i[1];
                            this.props.addEndListener(o, a)
                        }
                        null != e && setTimeout(this.nextCallback, e)
                    } else setTimeout(this.nextCallback, 0)
                }, o.render = function() {
                    var e = this.state.status;
                    if (e === Sn) return null;
                    var t = this.props,
                        n = t.children,
                        i = (t.in, t.mountOnEnter, t.unmountOnExit, t.appear, t.enter, t.exit, t.timeout, t.addEndListener, t.onEnter, t.onEntering, t.onEntered, t.onExit, t.onExiting, t.onExited, t.nodeRef, function(e, t) {
                            if (null == e) return {};
                            var n = {};
                            for (var r in e)
                                if ({}.hasOwnProperty.call(e, r)) {
                                    if (t.includes(r)) continue;
                                    n[r] = e[r]
                                }
                            return n
                        }(t, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
                    return r.createElement(Pn.Provider, {
                        value: null
                    }, "function" === typeof n ? n(e, i) : r.cloneElement(r.Children.only(n), i))
                }, i
            }(r.Component);

        function Tn() {}
        On.contextType = Pn, On.propTypes = {}, On.defaultProps = { in: !1,
            mountOnEnter: !1,
            unmountOnExit: !1,
            appear: !1,
            enter: !0,
            exit: !0,
            onEnter: Tn,
            onEntering: Tn,
            onEntered: Tn,
            onExit: Tn,
            onExiting: Tn,
            onExited: Tn
        }, On.UNMOUNTED = Sn, On.EXITED = _n, On.ENTERING = Nn, On.ENTERED = Mn, On.EXITING = In;
        const Rn = On;

        function Ln(e, t) {
            const n = Gt(e, t) || "",
                r = -1 === n.indexOf("ms") ? 1e3 : 1;
            return parseFloat(n) * r
        }

        function Bn(e, t) {
            const n = Ln(e, "transitionDuration"),
                r = Ln(e, "transitionDelay"),
                i = Qt(e, (n => {
                    n.target === e && (i(), t(n))
                }), n + r)
        }
        const Fn = r.forwardRef(((e, t) => {
                let {
                    onEnter: n,
                    onEntering: i,
                    onEntered: o,
                    onExit: a,
                    onExiting: l,
                    onExited: u,
                    addEndListener: c,
                    children: d,
                    childRef: h,
                    ...f
                } = e;
                const p = (0, r.useRef)(null),
                    m = Bt(p, h),
                    g = e => {
                        var t;
                        m((t = e) && "setState" in t ? s.findDOMNode(t) : null != t ? t : null)
                    },
                    y = e => t => {
                        e && p.current && e(p.current, t)
                    },
                    v = (0, r.useCallback)(y(n), [n]),
                    b = (0, r.useCallback)(y(i), [i]),
                    w = (0, r.useCallback)(y(o), [o]),
                    E = (0, r.useCallback)(y(a), [a]),
                    x = (0, r.useCallback)(y(l), [l]),
                    A = (0, r.useCallback)(y(u), [u]),
                    k = (0, r.useCallback)(y(c), [c]);
                return (0, he.jsx)(Rn, {
                    ref: t,
                    ...f,
                    onEnter: v,
                    onEntered: w,
                    onEntering: b,
                    onExit: E,
                    onExited: A,
                    onExiting: x,
                    addEndListener: k,
                    nodeRef: p,
                    children: "function" === typeof d ? (e, t) => d(e, { ...t,
                        ref: g
                    }) : r.cloneElement(d, {
                        ref: g
                    })
                })
            })),
            jn = Fn,
            Dn = {
                [Nn]: "show",
                [Mn]: "show"
            },
            Un = r.forwardRef(((e, t) => {
                let {
                    className: n,
                    children: i,
                    transitionClasses: o = {},
                    onEnter: s,
                    ...a
                } = e;
                const l = { in: !1,
                        timeout: 300,
                        mountOnEnter: !1,
                        unmountOnExit: !1,
                        appear: !1,
                        ...a
                    },
                    u = (0, r.useCallback)(((e, t) => {
                        ! function(e) {
                            e.offsetHeight
                        }(e), null == s || s(e, t)
                    }), [s]);
                return (0, he.jsx)(jn, {
                    ref: t,
                    addEndListener: Bn,
                    ...l,
                    onEnter: u,
                    childRef: i.ref,
                    children: (e, t) => r.cloneElement(i, { ...t,
                        className: At()("fade", n, i.props.className, Dn[e], o[e])
                    })
                })
            }));
        Un.displayName = "Fade";
        const zn = Un,
            qn = ["xxl", "xl", "lg", "md", "sm", "xs"],
            Gn = "xs",
            Hn = r.createContext({
                prefixes: {},
                breakpoints: qn,
                minBreakpoint: Gn
            }),
            {
                Consumer: $n,
                Provider: Qn
            } = Hn;

        function Vn(e, t) {
            const {
                prefixes: n
            } = (0, r.useContext)(Hn);
            return e || n[t] || t
        }
        const Kn = r.forwardRef(((e, t) => {
            let {
                className: n,
                bsPrefix: r,
                as: i = "div",
                ...o
            } = e;
            return r = Vn(r, "modal-body"), (0, he.jsx)(i, {
                ref: t,
                className: At()(n, r),
                ...o
            })
        }));
        Kn.displayName = "ModalBody";
        const Wn = Kn,
            Jn = r.createContext({
                onHide() {}
            }),
            Zn = r.forwardRef(((e, t) => {
                let {
                    bsPrefix: n,
                    className: r,
                    contentClassName: i,
                    centered: o,
                    size: s,
                    fullscreen: a,
                    children: l,
                    scrollable: u,
                    ...c
                } = e;
                n = Vn(n, "modal");
                const d = `${n}-dialog`,
                    h = "string" === typeof a ? `${n}-fullscreen-${a}` : `${n}-fullscreen`;
                return (0, he.jsx)("div", { ...c,
                    ref: t,
                    className: At()(d, r, s && `${n}-${s}`, o && `${d}-centered`, u && `${d}-scrollable`, a && h),
                    children: (0, he.jsx)("div", {
                        className: At()(`${n}-content`, i),
                        children: l
                    })
                })
            }));
        Zn.displayName = "ModalDialog";
        const Yn = Zn,
            Xn = r.forwardRef(((e, t) => {
                let {
                    className: n,
                    bsPrefix: r,
                    as: i = "div",
                    ...o
                } = e;
                return r = Vn(r, "modal-footer"), (0, he.jsx)(i, {
                    ref: t,
                    className: At()(n, r),
                    ...o
                })
            }));
        Xn.displayName = "ModalFooter";
        const er = Xn;
        var tr = n(5173),
            nr = n.n(tr);
        const rr = {
                "aria-label": nr().string,
                onClick: nr().func,
                variant: nr().oneOf(["white"])
            },
            ir = r.forwardRef(((e, t) => {
                let {
                    className: n,
                    variant: r,
                    "aria-label": i = "Close",
                    ...o
                } = e;
                return (0, he.jsx)("button", {
                    ref: t,
                    type: "button",
                    className: At()("btn-close", r && `btn-close-${r}`, n),
                    "aria-label": i,
                    ...o
                })
            }));
        ir.displayName = "CloseButton", ir.propTypes = rr;
        const or = ir,
            sr = r.forwardRef(((e, t) => {
                let {
                    closeLabel: n = "Close",
                    closeVariant: i,
                    closeButton: o = !1,
                    onHide: s,
                    children: a,
                    ...l
                } = e;
                const u = (0, r.useContext)(Jn),
                    c = Rt((() => {
                        null == u || u.onHide(), null == s || s()
                    }));
                return (0, he.jsxs)("div", {
                    ref: t,
                    ...l,
                    children: [a, o && (0, he.jsx)(or, {
                        "aria-label": n,
                        variant: i,
                        onClick: c
                    })]
                })
            })),
            ar = r.forwardRef(((e, t) => {
                let {
                    bsPrefix: n,
                    className: r,
                    closeLabel: i = "Close",
                    closeButton: o = !1,
                    ...s
                } = e;
                return n = Vn(n, "modal-header"), (0, he.jsx)(sr, {
                    ref: t,
                    ...s,
                    className: At()(r, n),
                    closeLabel: i,
                    closeButton: o
                })
            }));
        ar.displayName = "ModalHeader";
        const lr = ar,
            ur = (cr = "h4", r.forwardRef(((e, t) => (0, he.jsx)("div", { ...e,
                ref: t,
                className: At()(e.className, cr)
            }))));
        var cr;
        const dr = r.forwardRef(((e, t) => {
            let {
                className: n,
                bsPrefix: r,
                as: i = ur,
                ...o
            } = e;
            return r = Vn(r, "modal-title"), (0, he.jsx)(i, {
                ref: t,
                className: At()(n, r),
                ...o
            })
        }));
        dr.displayName = "ModalTitle";
        const hr = dr;

        function fr(e) {
            return (0, he.jsx)(zn, { ...e,
                timeout: null
            })
        }

        function pr(e) {
            return (0, he.jsx)(zn, { ...e,
                timeout: null
            })
        }
        const mr = r.forwardRef(((e, t) => {
            let {
                bsPrefix: n,
                className: i,
                style: o,
                dialogClassName: s,
                contentClassName: a,
                children: l,
                dialogAs: u = Yn,
                "data-bs-theme": c,
                "aria-labelledby": d,
                "aria-describedby": h,
                "aria-label": f,
                show: p = !1,
                animation: m = !0,
                backdrop: g = !0,
                keyboard: y = !0,
                onEscapeKeyDown: v,
                onShow: b,
                onHide: w,
                container: E,
                autoFocus: x = !0,
                enforceFocus: A = !0,
                restoreFocus: k = !0,
                restoreFocusOptions: C,
                onEntered: P,
                onExit: S,
                onExiting: _,
                onEnter: N,
                onEntering: M,
                onExited: I,
                backdropClassName: O,
                manager: T,
                ...R
            } = e;
            const [L, B] = (0, r.useState)({}), [F, j] = (0, r.useState)(!1), D = (0, r.useRef)(!1), U = (0, r.useRef)(!1), z = (0, r.useRef)(null), [q, G] = (0, r.useState)(null), H = Bt(t, G), $ = Rt(w), Q = function() {
                const {
                    dir: e
                } = (0, r.useContext)(Hn);
                return "rtl" === e
            }();
            n = Vn(n, "modal");
            const V = (0, r.useMemo)((() => ({
                onHide: $
            })), [$]);

            function K() {
                return T || function(e) {
                    return An || (An = new xn(e)), An
                }({
                    isRTL: Q
                })
            }

            function W(e) {
                if (!kt) return;
                const t = K().getScrollbarWidth() > 0,
                    n = e.scrollHeight > Nt(e).documentElement.clientHeight;
                B({
                    paddingRight: t && !n ? Ot() : void 0,
                    paddingLeft: !t && n ? Ot() : void 0
                })
            }
            const J = Rt((() => {
                q && W(q.dialog)
            }));
            Ft((() => {
                Mt(window, "resize", J), null == z.current || z.current()
            }));
            const Z = () => {
                    D.current = !0
                },
                Y = e => {
                    D.current && q && e.target === q.dialog && (U.current = !0), D.current = !1
                },
                X = () => {
                    j(!0), z.current = Qt(q.dialog, (() => {
                        j(!1)
                    }))
                },
                ee = e => {
                    "static" !== g ? U.current || e.target !== e.currentTarget ? U.current = !1 : null == w || w() : (e => {
                        e.target === e.currentTarget && X()
                    })(e)
                },
                te = (0, r.useCallback)((e => (0, he.jsx)("div", { ...e,
                    className: At()(`${n}-backdrop`, O, !m && "show")
                })), [m, O, n]),
                ne = { ...o,
                    ...L
                };
            ne.display = "block";
            return (0, he.jsx)(Jn.Provider, {
                value: V,
                children: (0, he.jsx)(mn, {
                    show: p,
                    ref: H,
                    backdrop: g,
                    container: E,
                    keyboard: !0,
                    autoFocus: x,
                    enforceFocus: A,
                    restoreFocus: k,
                    restoreFocusOptions: C,
                    onEscapeKeyDown: e => {
                        y ? null == v || v(e) : (e.preventDefault(), "static" === g && X())
                    },
                    onShow: b,
                    onHide: w,
                    onEnter: (e, t) => {
                        e && W(e), null == N || N(e, t)
                    },
                    onEntering: (e, t) => {
                        null == M || M(e, t), _t(window, "resize", J)
                    },
                    onEntered: P,
                    onExit: e => {
                        null == z.current || z.current(), null == S || S(e)
                    },
                    onExiting: _,
                    onExited: e => {
                        e && (e.style.display = ""), null == I || I(e), Mt(window, "resize", J)
                    },
                    manager: K(),
                    transition: m ? fr : void 0,
                    backdropTransition: m ? pr : void 0,
                    renderBackdrop: te,
                    renderDialog: e => (0, he.jsx)("div", {
                        role: "dialog",
                        ...e,
                        style: ne,
                        className: At()(i, n, F && `${n}-static`, !m && "show"),
                        onClick: g ? ee : void 0,
                        onMouseUp: Y,
                        "data-bs-theme": c,
                        "aria-label": f,
                        "aria-labelledby": d,
                        "aria-describedby": h,
                        children: (0, he.jsx)(u, { ...R,
                            onMouseDown: Z,
                            className: s,
                            contentClassName: a,
                            children: l
                        })
                    })
                })
            })
        }));
        mr.displayName = "Modal";
        const gr = Object.assign(mr, {
            Body: Wn,
            Header: lr,
            Title: hr,
            Footer: er,
            Dialog: Yn,
            TRANSITION_DURATION: 300,
            BACKDROP_TRANSITION_DURATION: 150
        });

        function yr(e) {
            return {
                mutationFn: t => async function(e) {
                    let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (n.connector) t = n.connector;
                    else {
                        const {
                            connections: n,
                            current: r
                        } = e.state, i = n.get(r);
                        t = i ? .connector
                    }
                    const r = e.state.connections;
                    t && (await t.disconnect(), t.emitter.off("change", e._internal.events.change), t.emitter.off("disconnect", e._internal.events.disconnect), t.emitter.on("connect", e._internal.events.connect), r.delete(t.uid)), e.setState((e => {
                        if (0 === r.size) return { ...e,
                            connections: new Map,
                            current: null,
                            status: "disconnected"
                        };
                        const t = r.values().next().value;
                        return { ...e,
                            connections: new Map(r),
                            current: t.connector.uid
                        }
                    })); {
                        const t = e.state.current;
                        if (!t) return;
                        const n = e.state.connections.get(t) ? .connector;
                        if (!n) return;
                        await (e.storage ? .setItem("recentConnectorId", n.id))
                    }
                }(e, t),
                mutationKey: ["disconnect"]
            }
        }
        let vr = [];

        function br(e) {
            const t = [...e.state.connections.values()];
            return "reconnecting" === e.state.status || yt(vr, t) ? vr : (vr = t, t)
        }

        function wr() {
            const e = gt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {});
            return (0, r.useSyncExternalStore)((t => function(e, t) {
                const {
                    onChange: n
                } = t;
                return e.subscribe((() => br(e)), n, {
                    equalityFn: yt
                })
            }(e, {
                onChange: t
            })), (() => br(e)), (() => br(e)))
        }

        function Er(e) {
            const t = e.state.current,
                n = e.state.connections.get(t),
                r = n ? .accounts,
                i = r ? .[0],
                o = e.chains.find((e => e.id === n ? .chainId)),
                s = e.state.status;
            switch (s) {
                case "connected":
                    return {
                        address: i,
                        addresses: r,
                        chain: o,
                        chainId: n ? .chainId,
                        connector: n ? .connector,
                        isConnected: !0,
                        isConnecting: !1,
                        isDisconnected: !1,
                        isReconnecting: !1,
                        status: s
                    };
                case "reconnecting":
                    return {
                        address: i,
                        addresses: r,
                        chain: o,
                        chainId: n ? .chainId,
                        connector: n ? .connector,
                        isConnected: !!i,
                        isConnecting: !1,
                        isDisconnected: !1,
                        isReconnecting: !0,
                        status: s
                    };
                case "connecting":
                    return {
                        address: i,
                        addresses: r,
                        chain: o,
                        chainId: n ? .chainId,
                        connector: n ? .connector,
                        isConnected: !1,
                        isConnecting: !0,
                        isDisconnected: !1,
                        isReconnecting: !1,
                        status: s
                    };
                case "disconnected":
                    return {
                        address: void 0,
                        addresses: void 0,
                        chain: void 0,
                        chainId: void 0,
                        connector: void 0,
                        isConnected: !1,
                        isConnecting: !1,
                        isDisconnected: !0,
                        isReconnecting: !1,
                        status: s
                    }
            }
        }
        var xr = n(8443);
        const Ar = e => "object" === typeof e && !Array.isArray(e);

        function kr() {
            const e = gt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {});
            return function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,
                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : yt;
                const o = (0, r.useRef)([]),
                    s = (0, xr.useSyncExternalStoreWithSelector)(e, t, n, (e => e), ((e, t) => {
                        if (Ar(e) && Ar(t) && o.current.length) {
                            for (const n of o.current)
                                if (!i(e[n], t[n])) return !1;
                            return !0
                        }
                        return i(e, t)
                    }));
                if (Ar(s)) {
                    const e = { ...s
                    };
                    return Object.defineProperties(e, Object.entries(e).reduce(((e, t) => {
                        let [n, r] = t;
                        return { ...e,
                            [n]: {
                                configurable: !1,
                                enumerable: !0,
                                get: () => (o.current.includes(n) || o.current.push(n), r)
                            }
                        }
                    }), {})), e
                }
                return s
            }((t => function(e, t) {
                const {
                    onChange: n
                } = t;
                return e.subscribe((() => Er(e)), n, {
                    equalityFn(e, t) {
                        const {
                            connector: n,
                            ...r
                        } = e, {
                            connector: i,
                            ...o
                        } = t;
                        return yt(r, o) && n ? .id === i ? .id && n ? .uid === i ? .uid
                    }
                })
            }(e, {
                onChange: t
            })), (() => Er(e)))
        }
        var Cr = n(7962);
        async function Pr(e) {
            const t = await e.request({
                method: "eth_chainId"
            });
            return (0, Cr.ME)(t)
        }
        var Sr = n(4117);
        var _r = n(7965),
            Nr = n(2620),
            Mr = n(1376);
        const Ir = "/docs/contract/encodeDeployData";

        function Or(e) {
            const {
                abi: t,
                args: n,
                bytecode: r
            } = e;
            if (!n || 0 === n.length) return r;
            const i = t.find((e => "type" in e && "constructor" === e.type));
            if (!i) throw new _r.YW({
                docsPath: Ir
            });
            if (!("inputs" in i)) throw new _r.YF({
                docsPath: Ir
            });
            if (!i.inputs || 0 === i.inputs.length) throw new _r.YF({
                docsPath: Ir
            });
            const o = (0, Mr.h)(i.inputs, n);
            return (0, Nr.aP)([r, o])
        }
        var Tr = n(4034),
            Rr = n(1370);
        class Lr extends Rr.C {
            constructor() {
                let {
                    docsPath: e
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                super(["Could not find an Account to execute with this Action.", "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."].join("\n"), {
                    docsPath: e,
                    docsSlug: "account"
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "AccountNotFoundError"
                })
            }
        }
        var Br = n(6310);

        function Fr(e) {
            let {
                chain: t,
                currentChainId: n
            } = e;
            if (!t) throw new Br.jF;
            if (n !== t.id) throw new Br.EH({
                chain: t,
                currentChainId: n
            })
        }
        var jr = n(2343),
            Dr = n(3003),
            Ur = n(6615);
        var zr = n(1928),
            qr = n(6812);

        function Gr(e, t, n) {
            return r => e[t.name] ? .(r) ? ? e[n] ? .(r) ? ? t(e, r)
        }
        var Hr = n(2861),
            $r = n(4569);
        class Qr extends Rr.C {
            constructor() {
                super("`baseFeeMultiplier` must be greater than 1."), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "BaseFeeScalarError"
                })
            }
        }
        class Vr extends Rr.C {
            constructor() {
                super("Chain does not support EIP-1559 fees."), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "Eip1559FeesNotSupportedError"
                })
            }
        }
        class Kr extends Rr.C {
            constructor(e) {
                let {
                    maxPriorityFeePerGas: t
                } = e;
                super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0,$r.Q)(t)} gwei).`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "MaxFeePerGasTooLowError"
                })
            }
        }
        class Wr extends Rr.C {
            constructor(e) {
                let {
                    blockHash: t,
                    blockNumber: n
                } = e, r = "Block";
                t && (r = `Block at hash "${t}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "BlockNotFoundError"
                })
            }
        }
        const Jr = {
            "0x0": "legacy",
            "0x1": "eip2930",
            "0x2": "eip1559",
            "0x3": "eip4844"
        };

        function Zr(e) {
            const t = { ...e,
                blockHash: e.blockHash ? e.blockHash : null,
                blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
                chainId: e.chainId ? (0, Cr.ME)(e.chainId) : void 0,
                gas: e.gas ? BigInt(e.gas) : void 0,
                gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
                maxFeePerBlobGas: e.maxFeePerBlobGas ? BigInt(e.maxFeePerBlobGas) : void 0,
                maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
                maxPriorityFeePerGas: e.maxPriorityFeePerGas ? BigInt(e.maxPriorityFeePerGas) : void 0,
                nonce: e.nonce ? (0, Cr.ME)(e.nonce) : void 0,
                to: e.to ? e.to : null,
                transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
                type: e.type ? Jr[e.type] : void 0,
                typeHex: e.type ? e.type : void 0,
                value: e.value ? BigInt(e.value) : void 0,
                v: e.v ? BigInt(e.v) : void 0
            };
            return t.yParity = (() => {
                if (e.yParity) return Number(e.yParity);
                if ("bigint" === typeof t.v) {
                    if (0 n === t.v || 27 n === t.v) return 0;
                    if (1 n === t.v || 28 n === t.v) return 1;
                    if (t.v >= 35 n) return t.v % 2 n === 0 n ? 1 : 0
                }
            })(), "legacy" === t.type && (delete t.accessList, delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas, delete t.yParity), "eip2930" === t.type && (delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas), "eip1559" === t.type && delete t.maxFeePerBlobGas, t
        }

        function Yr(e) {
            const t = e.transactions ? .map((e => "string" === typeof e ? e : Zr(e)));
            return { ...e,
                baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
                blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
                difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
                excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
                gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
                gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
                hash: e.hash ? e.hash : null,
                logsBloom: e.logsBloom ? e.logsBloom : null,
                nonce: e.nonce ? e.nonce : null,
                number: e.number ? BigInt(e.number) : null,
                size: e.size ? BigInt(e.size) : void 0,
                timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
                transactions: t,
                totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null
            }
        }
        async function Xr(e) {
            let {
                blockHash: t,
                blockNumber: n,
                blockTag: r,
                includeTransactions: i
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const o = r ? ? "latest",
                s = i ? ? !1,
                a = void 0 !== n ? (0, Sr.cK)(n) : void 0;
            let l = null;
            if (l = t ? await e.request({
                    method: "eth_getBlockByHash",
                    params: [t, s]
                }) : await e.request({
                    method: "eth_getBlockByNumber",
                    params: [a || o, s]
                }), !l) throw new Wr({
                blockHash: t,
                blockNumber: n
            });
            return (e.chain ? .formatters ? .block ? .format || Yr)(l)
        }
        async function ei(e) {
            const t = await e.request({
                method: "eth_gasPrice"
            });
            return BigInt(t)
        }
        async function ti(e, t) {
            const {
                block: n,
                chain: r = e.chain,
                request: i
            } = t || {};
            if ("function" === typeof r ? .fees ? .defaultPriorityFee) {
                const t = n || await Gr(e, Xr, "getBlock")({});
                return r.fees.defaultPriorityFee({
                    block: t,
                    client: e,
                    request: i
                })
            }
            if ("undefined" !== typeof r ? .fees ? .defaultPriorityFee) return r ? .fees ? .defaultPriorityFee;
            try {
                const t = await e.request({
                    method: "eth_maxPriorityFeePerGas"
                });
                return (0, Cr.uU)(t)
            } catch {
                const [t, r] = await Promise.all([n ? Promise.resolve(n) : Gr(e, Xr, "getBlock")({}), Gr(e, ei, "getGasPrice")({})]);
                if ("bigint" !== typeof t.baseFeePerGas) throw new Vr;
                const i = r - t.baseFeePerGas;
                return i < 0 n ? 0 n : i
            }
        }
        async function ni(e, t) {
            const {
                block: n,
                chain: r = e.chain,
                request: i,
                type: o = "eip1559"
            } = t || {}, s = await (async () => "function" === typeof r ? .fees ? .baseFeeMultiplier ? r.fees.baseFeeMultiplier({
                block: n,
                client: e,
                request: i
            }) : r ? .fees ? .baseFeeMultiplier ? ? 1.2)();
            if (s < 1) throw new Qr;
            const a = 10 ** (s.toString().split(".")[1] ? .length ? ? 0),
                l = e => e * BigInt(Math.ceil(s * a)) / BigInt(a),
                u = n || await Gr(e, Xr, "getBlock")({});
            if ("function" === typeof r ? .fees ? .estimateFeesPerGas) {
                const t = await r.fees.estimateFeesPerGas({
                    block: n,
                    client: e,
                    multiply: l,
                    request: i,
                    type: o
                });
                if (null !== t) return t
            }
            if ("eip1559" === o) {
                if ("bigint" !== typeof u.baseFeePerGas) throw new Vr;
                const t = "bigint" === typeof i ? .maxPriorityFeePerGas ? i.maxPriorityFeePerGas : await ti(e, {
                        block: u,
                        chain: r,
                        request: i
                    }),
                    n = l(u.baseFeePerGas);
                return {
                    maxFeePerGas: i ? .maxFeePerGas ? ? n + t,
                    maxPriorityFeePerGas: t
                }
            }
            return {
                gasPrice: i ? .gasPrice ? ? l(await Gr(e, ei, "getGasPrice")({}))
            }
        }
        var ri = n(1273);
        class ii extends Rr.C {
            constructor(e, t) {
                let {
                    account: n,
                    docsPath: r,
                    chain: i,
                    data: o,
                    gas: s,
                    gasPrice: a,
                    maxFeePerGas: l,
                    maxPriorityFeePerGas: u,
                    nonce: c,
                    to: d,
                    value: h
                } = t;
                const f = (0, Dr.aO)({
                    from: n ? .address,
                    to: d,
                    value: "undefined" !== typeof h && `${(0,ri.c)(h)} ${i?.nativeCurrency?.symbol||"ETH"}`,
                    data: o,
                    gas: s,
                    gasPrice: "undefined" !== typeof a && `${(0,$r.Q)(a)} gwei`,
                    maxFeePerGas: "undefined" !== typeof l && `${(0,$r.Q)(l)} gwei`,
                    maxPriorityFeePerGas: "undefined" !== typeof u && `${(0,$r.Q)(u)} gwei`,
                    nonce: c
                });
                super(e.shortMessage, {
                    cause: e,
                    docsPath: r,
                    metaMessages: [...e.metaMessages ? [...e.metaMessages, " "] : [], "Estimate Gas Arguments:", f].filter(Boolean)
                }), Object.defineProperty(this, "cause", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "EstimateGasExecutionError"
                }), this.cause = e
            }
        }
        async function oi(e, t) {
            const n = t.account ? ? e.account,
                r = n ? (0, Tr.J)(n) : void 0;
            try {
                const {
                    accessList: n,
                    blobs: i,
                    blobVersionedHashes: o,
                    blockNumber: s,
                    blockTag: a,
                    data: l,
                    gas: u,
                    gasPrice: c,
                    maxFeePerBlobGas: d,
                    maxFeePerGas: h,
                    maxPriorityFeePerGas: f,
                    nonce: p,
                    to: m,
                    value: g,
                    ...y
                } = await Oi(e, { ...t,
                    parameters: "local" === r ? .type ? void 0 : ["blobVersionedHashes"]
                }), v = (s ? (0, Sr.cK)(s) : void 0) || a;
                (0, Hr.c)(t);
                const b = e.chain ? .formatters ? .transactionRequest ? .format,
                    w = (b || qr.Bv)({ ...(0, zr.o)(y, {
                            format: b
                        }),
                        from: r ? .address,
                        accessList: n,
                        blobs: i,
                        blobVersionedHashes: o,
                        data: l,
                        gas: u,
                        gasPrice: c,
                        maxFeePerBlobGas: d,
                        maxFeePerGas: h,
                        maxPriorityFeePerGas: f,
                        nonce: p,
                        to: m,
                        value: g
                    }),
                    E = await e.request({
                        method: "eth_estimateGas",
                        params: v ? [w, v] : [w]
                    });
                return BigInt(E)
            } catch (i) {
                throw function(e, t) {
                    let {
                        docsPath: n,
                        ...r
                    } = t;
                    const i = (() => {
                        const t = (0, Ur.l)(e, r);
                        return t instanceof jr.RM ? e : t
                    })();
                    return new ii(i, {
                        docsPath: n,
                        ...r
                    })
                }(i, { ...t,
                    account: r,
                    chain: e.chain
                })
            }
        }
        async function si(e, t) {
            let {
                address: n,
                blockTag: r = "latest",
                blockNumber: i
            } = t;
            const o = await e.request({
                method: "eth_getTransactionCount",
                params: [n, i ? (0, Sr.cK)(i) : r]
            });
            return (0, Cr.ME)(o)
        }
        var ai = n(7131);

        function li(e) {
            const {
                kzg: t
            } = e, n = e.to ? ? ("string" === typeof e.blobs[0] ? "hex" : "bytes"), r = "string" === typeof e.blobs[0] ? e.blobs.map((e => (0, ai.aT)(e))) : e.blobs, i = [];
            for (const o of r) i.push(Uint8Array.from(t.blobToKzgCommitment(o)));
            return "bytes" === n ? i : i.map((e => (0, Sr.My)(e)))
        }

        function ui(e) {
            const {
                kzg: t
            } = e, n = e.to ? ? ("string" === typeof e.blobs[0] ? "hex" : "bytes"), r = "string" === typeof e.blobs[0] ? e.blobs.map((e => (0, ai.aT)(e))) : e.blobs, i = "string" === typeof e.commitments[0] ? e.commitments.map((e => (0, ai.aT)(e))) : e.commitments, o = [];
            for (let s = 0; s < r.length; s++) {
                const e = r[s],
                    n = i[s];
                o.push(Uint8Array.from(t.computeBlobKzgProof(e, n)))
            }
            return "bytes" === n ? o : o.map((e => (0, Sr.My)(e)))
        }
        var ci = n(108),
            di = n(464);
        class hi extends di.Vw {
            constructor(e, t, n, r) {
                super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, di.O8)(this.buffer)
            }
            update(e) {
                (0, ci.t2)(this);
                const {
                    view: t,
                    buffer: n,
                    blockLen: r
                } = this, i = (e = (0, di.ZJ)(e)).length;
                for (let o = 0; o < i;) {
                    const s = Math.min(r - this.pos, i - o);
                    if (s !== r) n.set(e.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === r && (this.process(t, 0), this.pos = 0);
                    else {
                        const t = (0, di.O8)(e);
                        for (; r <= i - o; o += r) this.process(t, o)
                    }
                }
                return this.length += e.length, this.roundClean(), this
            }
            digestInto(e) {
                (0, ci.t2)(this), (0, ci.CG)(e, this), this.finished = !0;
                const {
                    buffer: t,
                    view: n,
                    blockLen: r,
                    isLE: i
                } = this;
                let {
                    pos: o
                } = this;
                t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0);
                for (let c = o; c < r; c++) t[c] = 0;
                ! function(e, t, n, r) {
                    if ("function" === typeof e.setBigUint64) return e.setBigUint64(t, n, r);
                    const i = BigInt(32),
                        o = BigInt(4294967295),
                        s = Number(n >> i & o),
                        a = Number(n & o),
                        l = r ? 4 : 0,
                        u = r ? 0 : 4;
                    e.setUint32(t + l, s, r), e.setUint32(t + u, a, r)
                }(n, r - 8, BigInt(8 * this.length), i), this.process(n, 0);
                const s = (0, di.O8)(e),
                    a = this.outputLen;
                if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
                const l = a / 4,
                    u = this.get();
                if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
                for (let c = 0; c < l; c++) s.setUint32(4 * c, u[c], i)
            }
            digest() {
                const {
                    buffer: e,
                    outputLen: t
                } = this;
                this.digestInto(e);
                const n = e.slice(0, t);
                return this.destroy(), n
            }
            _cloneInto(e) {
                e || (e = new this.constructor), e.set(...this.get());
                const {
                    blockLen: t,
                    buffer: n,
                    length: r,
                    finished: i,
                    destroyed: o,
                    pos: s
                } = this;
                return e.length = r, e.pos = s, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e
            }
        }
        const fi = (e, t, n) => e & t ^ ~e & n,
            pi = (e, t, n) => e & t ^ e & n ^ t & n,
            mi = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
            gi = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
            yi = new Uint32Array(64);
        class vi extends hi {
            constructor() {
                super(64, 32, 8, !1), this.A = 0 | gi[0], this.B = 0 | gi[1], this.C = 0 | gi[2], this.D = 0 | gi[3], this.E = 0 | gi[4], this.F = 0 | gi[5], this.G = 0 | gi[6], this.H = 0 | gi[7]
            }
            get() {
                const {
                    A: e,
                    B: t,
                    C: n,
                    D: r,
                    E: i,
                    F: o,
                    G: s,
                    H: a
                } = this;
                return [e, t, n, r, i, o, s, a]
            }
            set(e, t, n, r, i, o, s, a) {
                this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a
            }
            process(e, t) {
                for (let c = 0; c < 16; c++, t += 4) yi[c] = e.getUint32(t, !1);
                for (let c = 16; c < 64; c++) {
                    const e = yi[c - 15],
                        t = yi[c - 2],
                        n = (0, di.Ow)(e, 7) ^ (0, di.Ow)(e, 18) ^ e >>> 3,
                        r = (0, di.Ow)(t, 17) ^ (0, di.Ow)(t, 19) ^ t >>> 10;
                    yi[c] = r + yi[c - 7] + n + yi[c - 16] | 0
                }
                let {
                    A: n,
                    B: r,
                    C: i,
                    D: o,
                    E: s,
                    F: a,
                    G: l,
                    H: u
                } = this;
                for (let c = 0; c < 64; c++) {
                    const e = u + ((0, di.Ow)(s, 6) ^ (0, di.Ow)(s, 11) ^ (0, di.Ow)(s, 25)) + fi(s, a, l) + mi[c] + yi[c] | 0,
                        t = ((0, di.Ow)(n, 2) ^ (0, di.Ow)(n, 13) ^ (0, di.Ow)(n, 22)) + pi(n, r, i) | 0;
                    u = l, l = a, a = s, s = o + e | 0, o = i, i = r, r = n, n = e + t | 0
                }
                n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(n, r, i, o, s, a, l, u)
            }
            roundClean() {
                yi.fill(0)
            }
            destroy() {
                this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
            }
        }
        const bi = (0, di.ld)((() => new vi));
        var wi = n(1499);

        function Ei(e) {
            const {
                commitment: t,
                version: n = 1
            } = e, r = e.to ? ? ("string" === typeof t ? "hex" : "bytes"), i = function(e, t) {
                const n = t || "hex",
                    r = bi((0, wi.q)(e, {
                        strict: !1
                    }) ? (0, ai.ZJ)(e) : e);
                return "bytes" === n ? r : (0, Sr.nj)(r)
            }(t, "bytes");
            return i.set([n], 0), "bytes" === r ? i : (0, Sr.My)(i)
        }
        const xi = 32,
            Ai = 4096,
            ki = xi * Ai,
            Ci = 6 * ki - 1 - 1 * Ai * 6;
        class Pi extends Rr.C {
            constructor(e) {
                let {
                    maxSize: t,
                    size: n
                } = e;
                super("Blob size is too large.", {
                    metaMessages: [`Max: ${t} bytes`, `Given: ${n} bytes`]
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "BlobSizeTooLargeError"
                })
            }
        }
        class Si extends Rr.C {
            constructor() {
                super("Blob data must not be empty."), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "EmptyBlobError"
                })
            }
        }
        Rr.C;
        Rr.C;
        var _i = n(751),
            Ni = n(2017);

        function Mi(e) {
            const {
                data: t,
                kzg: n,
                to: r
            } = e, i = e.blobs ? ? function(e) {
                const t = e.to ? ? ("string" === typeof e.data ? "hex" : "bytes"),
                    n = "string" === typeof e.data ? (0, ai.aT)(e.data) : e.data,
                    r = (0, Ni.E)(n);
                if (!r) throw new Si;
                if (r > Ci) throw new Pi({
                    maxSize: Ci,
                    size: r
                });
                const i = [];
                let o = !0,
                    s = 0;
                for (; o;) {
                    const e = (0, _i.l)(new Uint8Array(ki));
                    let t = 0;
                    for (; t < Ai;) {
                        const r = n.slice(s, s + (xi - 1));
                        if (e.pushByte(0), e.pushBytes(r), r.length < 31) {
                            e.pushByte(128), o = !1;
                            break
                        }
                        t++, s += 31
                    }
                    i.push(e)
                }
                return "bytes" === t ? i.map((e => e.bytes)) : i.map((e => (0, Sr.My)(e.bytes)))
            }({
                data: t,
                to: r
            }), o = e.commitments ? ? li({
                blobs: i,
                kzg: n,
                to: r
            }), s = e.proofs ? ? ui({
                blobs: i,
                commitments: o,
                kzg: n,
                to: r
            }), a = [];
            for (let l = 0; l < i.length; l++) a.push({
                blob: i[l],
                commitment: o[l],
                proof: s[l]
            });
            return a
        }
        const Ii = ["blobVersionedHashes", "chainId", "fees", "gas", "nonce", "type"];
        async function Oi(e, t) {
            const {
                account: n = e.account,
                blobs: r,
                chain: i,
                chainId: o,
                gas: s,
                kzg: a,
                nonce: l,
                parameters: u = Ii,
                type: c
            } = t, d = n ? (0, Tr.J)(n) : void 0, h = { ...t,
                ...d ? {
                    from: d ? .address
                } : {}
            };
            let f;
            async function p() {
                return f || (f = await Gr(e, Xr, "getBlock")({
                    blockTag: "latest"
                }), f)
            }
            if ((u.includes("blobVersionedHashes") || u.includes("sidecars")) && r && a) {
                const e = li({
                    blobs: r,
                    kzg: a
                });
                if (u.includes("blobVersionedHashes")) {
                    const t = function(e) {
                        const {
                            commitments: t,
                            version: n
                        } = e, r = e.to ? ? ("string" === typeof t[0] ? "hex" : "bytes"), i = [];
                        for (const o of t) i.push(Ei({
                            commitment: o,
                            to: r,
                            version: n
                        }));
                        return i
                    }({
                        commitments: e,
                        to: "hex"
                    });
                    h.blobVersionedHashes = t
                }
                if (u.includes("sidecars")) {
                    const t = Mi({
                        blobs: r,
                        commitments: e,
                        proofs: ui({
                            blobs: r,
                            commitments: e,
                            kzg: a
                        }),
                        to: "hex"
                    });
                    h.sidecars = t
                }
            }
            if (u.includes("chainId") && (h.chainId = i ? i.id : "undefined" !== typeof o ? o : await Gr(e, Pr, "getChainId")({})), u.includes("nonce") && "undefined" === typeof l && d && (h.nonce = await Gr(e, si, "getTransactionCount")({
                    address: d.address,
                    blockTag: "pending"
                })), (u.includes("fees") || u.includes("type")) && "undefined" === typeof c) try {
                h.type = function(e) {
                    if (e.type) return e.type;
                    if ("undefined" !== typeof e.blobs || "undefined" !== typeof e.blobVersionedHashes || "undefined" !== typeof e.maxFeePerBlobGas || "undefined" !== typeof e.sidecars) return "eip4844";
                    if ("undefined" !== typeof e.maxFeePerGas || "undefined" !== typeof e.maxPriorityFeePerGas) return "eip1559";
                    if ("undefined" !== typeof e.gasPrice) return "undefined" !== typeof e.accessList ? "eip2930" : "legacy";
                    throw new Dr.Vg({
                        transaction: e
                    })
                }(h)
            } catch {
                const e = await p();
                h.type = "bigint" === typeof e ? .baseFeePerGas ? "eip1559" : "legacy"
            }
            if (u.includes("fees"))
                if ("legacy" !== h.type && "eip2930" !== h.type) {
                    if ("undefined" === typeof h.maxFeePerGas || "undefined" === typeof h.maxPriorityFeePerGas) {
                        const n = await p(),
                            {
                                maxFeePerGas: r,
                                maxPriorityFeePerGas: o
                            } = await ni(e, {
                                block: n,
                                chain: i,
                                request: h
                            });
                        if ("undefined" === typeof t.maxPriorityFeePerGas && t.maxFeePerGas && t.maxFeePerGas < o) throw new Kr({
                            maxPriorityFeePerGas: o
                        });
                        h.maxPriorityFeePerGas = o, h.maxFeePerGas = r
                    }
                } else {
                    if ("undefined" !== typeof t.maxFeePerGas || "undefined" !== typeof t.maxPriorityFeePerGas) throw new Vr;
                    const n = await p(),
                        {
                            gasPrice: r
                        } = await ni(e, {
                            block: n,
                            chain: i,
                            request: h,
                            type: "legacy"
                        });
                    h.gasPrice = r
                }
            return u.includes("gas") && "undefined" === typeof s && (h.gas = await Gr(e, oi, "estimateGas")({ ...h,
                account: d ? {
                    address: d.address,
                    type: "json-rpc"
                } : void 0
            })), (0, Hr.c)(h), delete h.parameters, h
        }
        async function Ti(e, t) {
            let {
                serializedTransaction: n
            } = t;
            return e.request({
                method: "eth_sendRawTransaction",
                params: [n]
            }, {
                retryCount: 0
            })
        }
        async function Ri(e, t) {
            const {
                account: n = e.account,
                chain: r = e.chain,
                accessList: i,
                blobs: o,
                data: s,
                gas: a,
                gasPrice: l,
                maxFeePerBlobGas: u,
                maxFeePerGas: c,
                maxPriorityFeePerGas: d,
                nonce: h,
                to: f,
                value: p,
                ...m
            } = t;
            if (!n) throw new Lr({
                docsPath: "/docs/actions/wallet/sendTransaction"
            });
            const g = (0, Tr.J)(n);
            try {
                let n;
                if ((0, Hr.c)(t), null !== r && (n = await Gr(e, Pr, "getChainId")({}), Fr({
                        currentChainId: n,
                        chain: r
                    })), "local" === g.type) {
                    const t = await Gr(e, Oi, "prepareTransactionRequest")({
                            account: g,
                            accessList: i,
                            blobs: o,
                            chain: r,
                            chainId: n,
                            data: s,
                            gas: a,
                            gasPrice: l,
                            maxFeePerBlobGas: u,
                            maxFeePerGas: c,
                            maxPriorityFeePerGas: d,
                            nonce: h,
                            parameters: [...Ii, "sidecars"],
                            to: f,
                            value: p,
                            ...m
                        }),
                        y = r ? .serializers ? .transaction,
                        v = await g.signTransaction(t, {
                            serializer: y
                        });
                    return await Gr(e, Ti, "sendRawTransaction")({
                        serializedTransaction: v
                    })
                }
                const y = e.chain ? .formatters ? .transactionRequest ? .format,
                    v = (y || qr.Bv)({ ...(0, zr.o)(m, {
                            format: y
                        }),
                        accessList: i,
                        blobs: o,
                        data: s,
                        from: g.address,
                        gas: a,
                        gasPrice: l,
                        maxFeePerBlobGas: u,
                        maxFeePerGas: c,
                        maxPriorityFeePerGas: d,
                        nonce: h,
                        to: f,
                        value: p
                    });
                return await e.request({
                    method: "eth_sendTransaction",
                    params: [v]
                }, {
                    retryCount: 0
                })
            } catch (y) {
                throw function(e, t) {
                    let {
                        docsPath: n,
                        ...r
                    } = t;
                    const i = (() => {
                        const t = (0, Ur.l)(e, r);
                        return t instanceof jr.RM ? e : t
                    })();
                    return new Dr.$s(i, {
                        docsPath: n,
                        ...r
                    })
                }(y, { ...t,
                    account: g,
                    chain: t.chain || void 0
                })
            }
        }
        var Li = n(3028);
        var Bi = n(3512),
            Fi = n(3491),
            ji = n(3556);
        const Di = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
            Ui = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

        function zi(e) {
            const {
                domain: t,
                message: n,
                primaryType: r,
                types: i
            } = e, o = (e, t) => {
                for (const n of e) {
                    const {
                        name: e,
                        type: r
                    } = n, s = t[e], a = r.match(Ui);
                    if (a && ("number" === typeof s || "bigint" === typeof s)) {
                        const [e, t, n] = a;
                        (0, Sr.cK)(s, {
                            signed: "int" === t,
                            size: parseInt(n) / 8
                        })
                    }
                    if ("address" === r && "string" === typeof s && !(0, ji.P)(s)) throw new Fi.M({
                        address: s
                    });
                    const l = r.match(Di);
                    if (l) {
                        const [e, t] = l;
                        if (t && (0, Ni.E)(s) !== parseInt(t)) throw new _r.BI({
                            expectedSize: parseInt(t),
                            givenSize: (0, Ni.E)(s)
                        })
                    }
                    const u = i[r];
                    u && o(u, s)
                }
            };
            if (i.EIP712Domain && t && o(i.EIP712Domain, t), "EIP712Domain" !== r) {
                const e = i[r];
                o(e, n)
            }
        }

        function qi(e) {
            let {
                domain: t
            } = e;
            return ["string" === typeof t ? .name && {
                name: "name",
                type: "string"
            }, t ? .version && {
                name: "version",
                type: "string"
            }, "number" === typeof t ? .chainId && {
                name: "chainId",
                type: "uint256"
            }, t ? .verifyingContract && {
                name: "verifyingContract",
                type: "address"
            }, t ? .salt && {
                name: "salt",
                type: "bytes32"
            }].filter(Boolean)
        }
        var Gi = n(7908);

        function Hi(e) {
            return {
                addChain: t => async function(e, t) {
                    let {
                        chain: n
                    } = t;
                    const {
                        id: r,
                        name: i,
                        nativeCurrency: o,
                        rpcUrls: s,
                        blockExplorers: a
                    } = n;
                    await e.request({
                        method: "wallet_addEthereumChain",
                        params: [{
                            chainId: (0, Sr.cK)(r),
                            chainName: i,
                            nativeCurrency: o,
                            rpcUrls: s.default.http,
                            blockExplorerUrls: a ? Object.values(a).map((e => {
                                let {
                                    url: t
                                } = e;
                                return t
                            })) : void 0
                        }]
                    }, {
                        retryCount: 0
                    })
                }(e, t),
                deployContract: t => function(e, t) {
                    const {
                        abi: n,
                        args: r,
                        bytecode: i,
                        ...o
                    } = t;
                    return Ri(e, { ...o,
                        data: Or({
                            abi: n,
                            args: r,
                            bytecode: i
                        })
                    })
                }(e, t),
                getAddresses: () => async function(e) {
                    return "local" === e.account ? .type ? [e.account.address] : (await e.request({
                        method: "eth_accounts"
                    })).map((e => (0, Li.o)(e)))
                }(e),
                getChainId: () => Pr(e),
                getPermissions: () => async function(e) {
                    return await e.request({
                        method: "wallet_getPermissions"
                    })
                }(e),
                prepareTransactionRequest: t => Oi(e, t),
                requestAddresses: () => async function(e) {
                    return (await e.request({
                        method: "eth_requestAccounts"
                    }, {
                        retryCount: 0
                    })).map((e => (0, Li.b)(e)))
                }(e),
                requestPermissions: t => async function(e, t) {
                    return e.request({
                        method: "wallet_requestPermissions",
                        params: [t]
                    }, {
                        retryCount: 0
                    })
                }(e, t),
                sendRawTransaction: t => Ti(e, t),
                sendTransaction: t => Ri(e, t),
                signMessage: t => async function(e, t) {
                    let {
                        account: n = e.account,
                        message: r
                    } = t;
                    if (!n) throw new Lr({
                        docsPath: "/docs/actions/wallet/signMessage"
                    });
                    const i = (0, Tr.J)(n);
                    if ("local" === i.type) return i.signMessage({
                        message: r
                    });
                    const o = "string" === typeof r ? (0, Sr.i3)(r) : r.raw instanceof Uint8Array ? (0, Sr.nj)(r.raw) : r.raw;
                    return e.request({
                        method: "personal_sign",
                        params: [o, i.address]
                    }, {
                        retryCount: 0
                    })
                }(e, t),
                signTransaction: t => async function(e, t) {
                    const {
                        account: n = e.account,
                        chain: r = e.chain,
                        ...i
                    } = t;
                    if (!n) throw new Lr({
                        docsPath: "/docs/actions/wallet/signTransaction"
                    });
                    const o = (0, Tr.J)(n);
                    (0, Hr.c)({
                        account: o,
                        ...t
                    });
                    const s = await Gr(e, Pr, "getChainId")({});
                    null !== r && Fr({
                        currentChainId: s,
                        chain: r
                    });
                    const a = r ? .formatters || e.chain ? .formatters,
                        l = a ? .transactionRequest ? .format || qr.Bv;
                    return "local" === o.type ? o.signTransaction({ ...i,
                        chainId: s
                    }, {
                        serializer: e.chain ? .serializers ? .transaction
                    }) : await e.request({
                        method: "eth_signTransaction",
                        params: [{ ...l(i),
                            chainId: (0, Sr.cK)(s),
                            from: o.address
                        }]
                    }, {
                        retryCount: 0
                    })
                }(e, t),
                signTypedData: t => async function(e, t) {
                    const {
                        account: n = e.account,
                        domain: r,
                        message: i,
                        primaryType: o
                    } = t;
                    if (!n) throw new Lr({
                        docsPath: "/docs/actions/wallet/signTypedData"
                    });
                    const s = (0, Tr.J)(n),
                        a = {
                            EIP712Domain: qi({
                                domain: r
                            }),
                            ...t.types
                        };
                    if (zi({
                            domain: r,
                            message: i,
                            primaryType: o,
                            types: a
                        }), "local" === s.type) return s.signTypedData({
                        domain: r,
                        message: i,
                        primaryType: o,
                        types: a
                    });
                    const l = (0, Bi.A)({
                        domain: r ? ? {},
                        message: i,
                        primaryType: o,
                        types: a
                    }, ((e, t) => (0, wi.q)(t) ? t.toLowerCase() : t));
                    return e.request({
                        method: "eth_signTypedData_v4",
                        params: [s.address, l]
                    }, {
                        retryCount: 0
                    })
                }(e, t),
                switchChain: t => async function(e, t) {
                    let {
                        id: n
                    } = t;
                    await e.request({
                        method: "wallet_switchEthereumChain",
                        params: [{
                            chainId: (0, Sr.cK)(n)
                        }]
                    }, {
                        retryCount: 0
                    })
                }(e, t),
                watchAsset: t => async function(e, t) {
                    return await e.request({
                        method: "wallet_watchAsset",
                        params: t
                    }, {
                        retryCount: 0
                    })
                }(e, t),
                writeContract: t => async function(e, t) {
                    const {
                        abi: n,
                        address: r,
                        args: i,
                        dataSuffix: o,
                        functionName: s,
                        ...a
                    } = t, l = (0, Gi.p)({
                        abi: n,
                        args: i,
                        functionName: s
                    });
                    return Gr(e, Ri, "sendTransaction")({
                        data: `${l}${o?o.replace("0x",""):""}`,
                        to: r,
                        ...a
                    })
                }(e, t)
            }
        }
        const $i = 256;
        let Qi, Vi = $i;

        function Ki() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 11;
            if (!Qi || Vi + e > 2 * $i) {
                Qi = "", Vi = 0;
                for (let e = 0; e < $i; e++) Qi += (256 + 256 * Math.random() | 0).toString(16).substring(1)
            }
            return Qi.substring(Vi, Vi++ + e)
        }

        function Wi(e) {
            const {
                batch: t,
                cacheTime: n = e.pollingInterval ? ? 4e3,
                ccipRead: r,
                key: i = "base",
                name: o = "Base Client",
                pollingInterval: s = 4e3,
                type: a = "base"
            } = e, l = e.chain, u = e.account ? (0, Tr.J)(e.account) : void 0, {
                config: c,
                request: d,
                value: h
            } = e.transport({
                chain: l,
                pollingInterval: s
            }), f = {
                account: u,
                batch: t,
                cacheTime: n,
                ccipRead: r,
                chain: l,
                key: i,
                name: o,
                pollingInterval: s,
                request: d,
                transport: { ...c,
                    ...h
                },
                type: a,
                uid: Ki()
            };
            return Object.assign(f, {
                extend: function e(t) {
                    return n => {
                        const r = n(t);
                        for (const e in f) delete r[e];
                        const i = { ...t,
                            ...r
                        };
                        return Object.assign(i, {
                            extend: e(i)
                        })
                    }
                }(f)
            })
        }
        var Ji = n(2494);
        class Zi extends Rr.C {
            constructor(e, t) {
                let {
                    code: n,
                    docsPath: r,
                    metaMessages: i,
                    shortMessage: o
                } = t;
                super(o, {
                    cause: e,
                    docsPath: r,
                    metaMessages: i || e ? .metaMessages
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "RpcError"
                }), Object.defineProperty(this, "code", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), this.name = e.name, this.code = e instanceof Ji.J8 ? e.code : n ? ? -1
            }
        }
        class Yi extends Zi {
            constructor(e, t) {
                super(e, t), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ProviderRpcError"
                }), Object.defineProperty(this, "data", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), this.data = t.data
            }
        }
        class Xi extends Zi {
            constructor(e) {
                super(e, {
                    code: Xi.code,
                    shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ParseRpcError"
                })
            }
        }
        Object.defineProperty(Xi, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32700
        });
        class eo extends Zi {
            constructor(e) {
                super(e, {
                    code: eo.code,
                    shortMessage: "JSON is not a valid request object."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "InvalidRequestRpcError"
                })
            }
        }
        Object.defineProperty(eo, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32600
        });
        class to extends Zi {
            constructor(e) {
                super(e, {
                    code: to.code,
                    shortMessage: "The method does not exist / is not available."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "MethodNotFoundRpcError"
                })
            }
        }
        Object.defineProperty(to, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32601
        });
        class no extends Zi {
            constructor(e) {
                super(e, {
                    code: no.code,
                    shortMessage: ["Invalid parameters were provided to the RPC method.", "Double check you have provided the correct parameters."].join("\n")
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "InvalidParamsRpcError"
                })
            }
        }
        Object.defineProperty(no, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32602
        });
        class ro extends Zi {
            constructor(e) {
                super(e, {
                    code: ro.code,
                    shortMessage: "An internal error was received."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "InternalRpcError"
                })
            }
        }
        Object.defineProperty(ro, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32603
        });
        class io extends Zi {
            constructor(e) {
                super(e, {
                    code: io.code,
                    shortMessage: ["Missing or invalid parameters.", "Double check you have provided the correct parameters."].join("\n")
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "InvalidInputRpcError"
                })
            }
        }
        Object.defineProperty(io, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32e3
        });
        class oo extends Zi {
            constructor(e) {
                super(e, {
                    code: oo.code,
                    shortMessage: "Requested resource not found."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ResourceNotFoundRpcError"
                })
            }
        }
        Object.defineProperty(oo, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32001
        });
        class so extends Zi {
            constructor(e) {
                super(e, {
                    code: so.code,
                    shortMessage: "Requested resource not available."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ResourceUnavailableRpcError"
                })
            }
        }
        Object.defineProperty(so, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32002
        });
        class ao extends Zi {
            constructor(e) {
                super(e, {
                    code: ao.code,
                    shortMessage: "Transaction creation failed."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "TransactionRejectedRpcError"
                })
            }
        }
        Object.defineProperty(ao, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32003
        });
        class lo extends Zi {
            constructor(e) {
                super(e, {
                    code: lo.code,
                    shortMessage: "Method is not implemented."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "MethodNotSupportedRpcError"
                })
            }
        }
        Object.defineProperty(lo, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32004
        });
        class uo extends Zi {
            constructor(e) {
                super(e, {
                    code: uo.code,
                    shortMessage: "Request exceeds defined limit."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "LimitExceededRpcError"
                })
            }
        }
        Object.defineProperty(uo, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32005
        });
        class co extends Zi {
            constructor(e) {
                super(e, {
                    code: co.code,
                    shortMessage: "Version of JSON-RPC protocol is not supported."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "JsonRpcVersionUnsupportedError"
                })
            }
        }
        Object.defineProperty(co, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: -32006
        });
        class ho extends Yi {
            constructor(e) {
                super(e, {
                    code: ho.code,
                    shortMessage: "User rejected the request."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "UserRejectedRequestError"
                })
            }
        }
        Object.defineProperty(ho, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 4001
        });
        class fo extends Yi {
            constructor(e) {
                super(e, {
                    code: fo.code,
                    shortMessage: "The requested method and/or account has not been authorized by the user."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "UnauthorizedProviderError"
                })
            }
        }
        Object.defineProperty(fo, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 4100
        });
        class po extends Yi {
            constructor(e) {
                super(e, {
                    code: po.code,
                    shortMessage: "The Provider does not support the requested method."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "UnsupportedProviderMethodError"
                })
            }
        }
        Object.defineProperty(po, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 4200
        });
        class mo extends Yi {
            constructor(e) {
                super(e, {
                    code: mo.code,
                    shortMessage: "The Provider is disconnected from all chains."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ProviderDisconnectedError"
                })
            }
        }
        Object.defineProperty(mo, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 4900
        });
        class go extends Yi {
            constructor(e) {
                super(e, {
                    code: go.code,
                    shortMessage: "The Provider is not connected to the requested chain."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ChainDisconnectedError"
                })
            }
        }
        Object.defineProperty(go, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 4901
        });
        class yo extends Yi {
            constructor(e) {
                super(e, {
                    code: yo.code,
                    shortMessage: "An error occurred when attempting to switch chain."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "SwitchChainError"
                })
            }
        }
        Object.defineProperty(yo, "code", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 4902
        });
        class vo extends Zi {
            constructor(e) {
                super(e, {
                    shortMessage: "An unknown RPC error occurred."
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "UnknownRpcError"
                })
            }
        }
        async function bo(e) {
            return new Promise((t => setTimeout(t, e)))
        }

        function wo(e) {
            let {
                delay: t = 100,
                retryCount: n = 2,
                shouldRetry: r = () => !0
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return new Promise(((i, o) => {
                const s = async function() {
                    let {
                        count: a = 0
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    try {
                        const t = await e();
                        i(t)
                    } catch (l) {
                        if (a < n && await r({
                                count: a,
                                error: l
                            })) return (async e => {
                            let {
                                error: n
                            } = e;
                            const r = "function" === typeof t ? t({
                                count: a,
                                error: n
                            }) : t;
                            r && await bo(r), s({
                                count: a + 1
                            })
                        })({
                            error: l
                        });
                        o(l)
                    }
                };
                s()
            }))
        }

        function Eo(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return async function(n) {
                let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const {
                    retryDelay: i = 150,
                    retryCount: o = 3
                } = { ...t,
                    ...r
                };
                return wo((async () => {
                    try {
                        return await e(n)
                    } catch (t) {
                        const e = t;
                        switch (e.code) {
                            case Xi.code:
                                throw new Xi(e);
                            case eo.code:
                                throw new eo(e);
                            case to.code:
                                throw new to(e);
                            case no.code:
                                throw new no(e);
                            case ro.code:
                                throw new ro(e);
                            case io.code:
                                throw new io(e);
                            case oo.code:
                                throw new oo(e);
                            case so.code:
                                throw new so(e);
                            case ao.code:
                                throw new ao(e);
                            case lo.code:
                                throw new lo(e);
                            case uo.code:
                                throw new uo(e);
                            case co.code:
                                throw new co(e);
                            case ho.code:
                                throw new ho(e);
                            case fo.code:
                                throw new fo(e);
                            case po.code:
                                throw new po(e);
                            case mo.code:
                                throw new mo(e);
                            case go.code:
                                throw new go(e);
                            case yo.code:
                                throw new yo(e);
                            case 5e3:
                                throw new ho(e);
                            default:
                                if (t instanceof Rr.C) throw t;
                                throw new vo(e)
                        }
                    }
                }), {
                    delay: e => {
                        let {
                            count: t,
                            error: n
                        } = e;
                        if (n && n instanceof Ji.Ci) {
                            const e = n ? .headers ? .get("Retry-After");
                            if (e ? .match(/\d/)) return 1e3 * parseInt(e)
                        }
                        return (1 << t) * i
                    },
                    retryCount: o,
                    shouldRetry: e => {
                        let {
                            error: t
                        } = e;
                        return function(e) {
                            if ("code" in e && "number" === typeof e.code) return -1 === e.code || (e.code === uo.code || e.code === ro.code);
                            if (e instanceof Ji.Ci && e.status) return 403 === e.status || (408 === e.status || (413 === e.status || (429 === e.status || (500 === e.status || (502 === e.status || (503 === e.status || 504 === e.status))))));
                            return !0
                        }(t)
                    }
                })
            }
        }

        function xo(e, t) {
            let {
                key: n,
                name: r,
                request: i,
                retryCount: o = 3,
                retryDelay: s = 150,
                timeout: a,
                type: l
            } = e;
            return {
                config: {
                    key: n,
                    name: r,
                    request: i,
                    retryCount: o,
                    retryDelay: s,
                    timeout: a,
                    type: l
                },
                request: Eo(i, {
                    retryCount: o,
                    retryDelay: s
                }),
                value: t
            }
        }
        async function Ao(e) {
            let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            if (n.connector) {
                const {
                    connector: e
                } = n, [r, i] = await Promise.all([e.getAccounts(), e.getChainId()]);
                t = {
                    accounts: r,
                    chainId: i,
                    connector: e
                }
            } else t = e.state.connections.get(e.state.current);
            if (!t) throw new st;
            const r = n.chainId ? ? t.chainId,
                i = t.connector;
            if (i.getClient) return i.getClient({
                chainId: r
            });
            const o = (0, Tr.J)(n.account ? ? t.accounts[0]);
            o.address = (0, Li.b)(o.address);
            const s = e.chains.find((e => e.id === r)),
                a = await t.connector.getProvider({
                    chainId: r
                });
            if (n.account && !t.accounts.some((e => e.toLowerCase() === o.address.toLowerCase()))) throw new at({
                address: o.address,
                connector: i
            });
            return Wi({
                account: o,
                chain: s,
                name: "Connector Client",
                transport: e => function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const {
                        key: n = "custom",
                        name: r = "Custom Provider",
                        retryDelay: i
                    } = t;
                    return o => {
                        let {
                            retryCount: s
                        } = o;
                        return xo({
                            key: n,
                            name: r,
                            request: e.request.bind(e),
                            retryCount: t.retryCount ? ? s,
                            retryDelay: i,
                            type: "custom"
                        })
                    }
                }(a)({ ...e,
                    retryCount: 0
                })
            })
        }

        function ko(e) {
            return JSON.stringify(e, ((e, t) => function(e) {
                if (!Co(e)) return !1;
                const t = e.constructor;
                if ("undefined" === typeof t) return !0;
                const n = t.prototype;
                return !!Co(n) && !!n.hasOwnProperty("isPrototypeOf")
            }(t) ? Object.keys(t).sort().reduce(((e, n) => (e[n] = t[n], e)), {}) : "bigint" === typeof t ? t.toString() : t))
        }

        function Co(e) {
            return "[object Object]" === Object.prototype.toString.call(e)
        }

        function Po(e) {
            const {
                _defaulted: t,
                behavior: n,
                gcTime: r,
                initialData: i,
                initialDataUpdatedAt: o,
                maxPages: s,
                meta: a,
                networkMode: l,
                queryFn: u,
                queryHash: c,
                queryKey: d,
                queryKeyHashFn: h,
                retry: f,
                retryDelay: p,
                structuralSharing: m,
                getPreviousPageParam: g,
                getNextPageParam: y,
                initialPageParam: v,
                _optimisticResults: b,
                enabled: w,
                notifyOnChangeProps: E,
                placeholderData: x,
                refetchInterval: A,
                refetchIntervalInBackground: k,
                refetchOnMount: C,
                refetchOnReconnect: P,
                refetchOnWindowFocus: S,
                retryOnMount: _,
                select: N,
                staleTime: M,
                suspense: I,
                throwOnError: O,
                config: T,
                connector: R,
                query: L,
                ...B
            } = e;
            return B
        }

        function So(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return {
                gcTime: 0,
                async queryFn(n) {
                    let {
                        queryKey: r
                    } = n;
                    const {
                        connector: i
                    } = t, {
                        connectorUid: o,
                        scopeKey: s,
                        ...a
                    } = r[1];
                    return async function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        const n = await Ao(e, t);
                        return n.extend(Hi), n.extend(Hi)
                    }(e, { ...a,
                        connector: i
                    })
                },
                queryKey: _o(t)
            }
        }

        function _o() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const {
                connector: t,
                ...n
            } = e;
            return ["walletClient", { ...Po(n),
                connectorUid: t ? .uid
            }]
        }
        var No = class extends Be {#
            m;#
            g;#
            y;#
            a;#
            v;#
            b;
            constructor(e) {
                super(), this.#b = !1, this.#v = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.#y = e.cache, this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.#m = function(e) {
                    const t = "function" === typeof e.initialData ? e.initialData() : e.initialData,
                        n = void 0 !== t,
                        r = n ? "function" === typeof e.initialDataUpdatedAt ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
                    return {
                        data: t,
                        dataUpdateCount: 0,
                        dataUpdatedAt: n ? r ? ? Date.now() : 0,
                        error: null,
                        errorUpdateCount: 0,
                        errorUpdatedAt: 0,
                        fetchFailureCount: 0,
                        fetchFailureReason: null,
                        fetchMeta: null,
                        isInvalidated: !1,
                        status: n ? "success" : "pending",
                        fetchStatus: "idle"
                    }
                }(this.options), this.state = e.state ? ? this.#m, this.scheduleGc()
            }
            get meta() {
                return this.options.meta
            }
            get promise() {
                return this.#a ? .promise
            }
            setOptions(e) {
                this.options = { ...this.#v,
                    ...e
                }, this.updateGcTime(this.options.gcTime)
            }
            optionalRemove() {
                this.observers.length || "idle" !== this.state.fetchStatus || this.#y.remove(this)
            }
            setData(e, t) {
                const n = Ie(this.state.data, e, this.options);
                return this.#l({
                    data: n,
                    type: "success",
                    dataUpdatedAt: t ? .updatedAt,
                    manual: t ? .manual
                }), n
            }
            setState(e, t) {
                this.#l({
                    type: "setState",
                    state: e,
                    setStateOptions: t
                })
            }
            cancel(e) {
                const t = this.#a ? .promise;
                return this.#a ? .cancel(e), t ? t.then(ge).catch(ge) : Promise.resolve()
            }
            destroy() {
                super.destroy(), this.cancel({
                    silent: !0
                })
            }
            reset() {
                this.destroy(), this.setState(this.#m)
            }
            isActive() {
                return this.observers.some((e => !1 !== we(e.options.enabled, this)))
            }
            isDisabled() {
                return this.getObserversCount() > 0 && !this.isActive()
            }
            isStale() {
                return !!this.state.isInvalidated || (this.getObserversCount() > 0 ? this.observers.some((e => e.getCurrentResult().isStale)) : void 0 === this.state.data)
            }
            isStaleByTime() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return this.state.isInvalidated || void 0 === this.state.data || !ve(this.state.dataUpdatedAt, e)
            }
            onFocus() {
                const e = this.observers.find((e => e.shouldFetchOnWindowFocus()));
                e ? .refetch({
                    cancelRefetch: !1
                }), this.#a ? .continue()
            }
            onOnline() {
                const e = this.observers.find((e => e.shouldFetchOnReconnect()));
                e ? .refetch({
                    cancelRefetch: !1
                }), this.#a ? .continue()
            }
            addObserver(e) {
                this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.#y.notify({
                    type: "observerAdded",
                    query: this,
                    observer: e
                }))
            }
            removeObserver(e) {
                this.observers.includes(e) && (this.observers = this.observers.filter((t => t !== e)), this.observers.length || (this.#a && (this.#b ? this.#a.cancel({
                    revert: !0
                }) : this.#a.cancelRetry()), this.scheduleGc()), this.#y.notify({
                    type: "observerRemoved",
                    query: this,
                    observer: e
                }))
            }
            getObserversCount() {
                return this.observers.length
            }
            invalidate() {
                this.state.isInvalidated || this.#l({
                    type: "invalidate"
                })
            }
            fetch(e, t) {
                if ("idle" !== this.state.fetchStatus)
                    if (void 0 !== this.state.data && t ? .cancelRefetch) this.cancel({
                        silent: !0
                    });
                    else if (this.#a) return this.#a.continueRetry(), this.#a.promise;
                if (e && this.setOptions(e), !this.options.queryFn) {
                    const e = this.observers.find((e => e.options.queryFn));
                    e && this.setOptions(e.options)
                }
                const n = new AbortController,
                    r = e => {
                        Object.defineProperty(e, "signal", {
                            enumerable: !0,
                            get: () => (this.#b = !0, n.signal)
                        })
                    },
                    i = {
                        fetchOptions: t,
                        options: this.options,
                        queryKey: this.queryKey,
                        state: this.state,
                        fetchFn: () => {
                            const e = Le(this.options, t),
                                n = {
                                    queryKey: this.queryKey,
                                    meta: this.meta
                                };
                            return r(n), this.#b = !1, this.options.persister ? this.options.persister(e, n, this) : e(n)
                        }
                    };
                r(i), this.options.behavior ? .onFetch(i, this), this.#g = this.state, "idle" !== this.state.fetchStatus && this.state.fetchMeta === i.fetchOptions ? .meta || this.#l({
                    type: "fetch",
                    meta: i.fetchOptions ? .meta
                });
                const o = e => {
                    Ge(e) && e.silent || this.#l({
                        type: "error",
                        error: e
                    }), Ge(e) || (this.#y.config.onError ? .(e, this), this.#y.config.onSettled ? .(this.state.data, e, this)), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
                };
                return this.#a = He({
                    initialPromise: t ? .initialPromise,
                    fn: i.fetchFn,
                    abort: n.abort.bind(n),
                    onSuccess: e => {
                        if (void 0 !== e) {
                            try {
                                this.setData(e)
                            } catch (t) {
                                return void o(t)
                            }
                            this.#y.config.onSuccess ? .(e, this), this.#y.config.onSettled ? .(e, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
                        } else o(new Error(`${this.queryHash} data is undefined`))
                    },
                    onError: o,
                    onFail: (e, t) => {
                        this.#l({
                            type: "failed",
                            failureCount: e,
                            error: t
                        })
                    },
                    onPause: () => {
                        this.#l({
                            type: "pause"
                        })
                    },
                    onContinue: () => {
                        this.#l({
                            type: "continue"
                        })
                    },
                    retry: i.options.retry,
                    retryDelay: i.options.retryDelay,
                    networkMode: i.options.networkMode,
                    canRun: () => !0
                }), this.#a.start()
            }#
            l(e) {
                this.state = (t => {
                    switch (e.type) {
                        case "failed":
                            return { ...t,
                                fetchFailureCount: e.failureCount,
                                fetchFailureReason: e.error
                            };
                        case "pause":
                            return { ...t,
                                fetchStatus: "paused"
                            };
                        case "continue":
                            return { ...t,
                                fetchStatus: "fetching"
                            };
                        case "fetch":
                            return { ...t,
                                ...Mo(t.data, this.options),
                                fetchMeta: e.meta ? ? null
                            };
                        case "success":
                            return { ...t,
                                data: e.data,
                                dataUpdateCount: t.dataUpdateCount + 1,
                                dataUpdatedAt: e.dataUpdatedAt ? ? Date.now(),
                                error: null,
                                isInvalidated: !1,
                                status: "success",
                                ...!e.manual && {
                                    fetchStatus: "idle",
                                    fetchFailureCount: 0,
                                    fetchFailureReason: null
                                }
                            };
                        case "error":
                            const n = e.error;
                            return Ge(n) && n.revert && this.#g ? { ...this.#g,
                                fetchStatus: "idle"
                            } : { ...t,
                                error: n,
                                errorUpdateCount: t.errorUpdateCount + 1,
                                errorUpdatedAt: Date.now(),
                                fetchFailureCount: t.fetchFailureCount + 1,
                                fetchFailureReason: n,
                                fetchStatus: "idle",
                                status: "error"
                            };
                        case "invalidate":
                            return { ...t,
                                isInvalidated: !0
                            };
                        case "setState":
                            return { ...t,
                                ...e.state
                            }
                    }
                })(this.state), pe.batch((() => {
                    this.observers.forEach((e => {
                        e.onQueryUpdate()
                    })), this.#y.notify({
                        query: this,
                        type: "updated",
                        action: e
                    })
                }))
            }
        };

        function Mo(e, t) {
            return {
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchStatus: ze(t.networkMode) ? "fetching" : "paused",
                ...void 0 === e && {
                    error: null,
                    status: "pending"
                }
            }
        }
        var Io = class extends Fe {
            constructor(e, t) {
                super(), this.options = t, this.#u = e, this.#w = null, this.bindMethods(), this.setOptions(t)
            }#
            u;#
            E = void 0;#
            x = void 0;#
            c = void 0;#
            A;#
            k;#
            w;#
            C;#
            P;#
            S;#
            _;#
            N;#
            M;#
            I = (() => new Set)();
            bindMethods() {
                this.refetch = this.refetch.bind(this)
            }
            onSubscribe() {
                1 === this.listeners.size && (this.#E.addObserver(this), Oo(this.#E, this.options) ? this.#O() : this.updateResult(), this.#T())
            }
            onUnsubscribe() {
                this.hasListeners() || this.destroy()
            }
            shouldFetchOnReconnect() {
                return To(this.#E, this.options, this.options.refetchOnReconnect)
            }
            shouldFetchOnWindowFocus() {
                return To(this.#E, this.options, this.options.refetchOnWindowFocus)
            }
            destroy() {
                this.listeners = new Set, this.#R(), this.#L(), this.#E.removeObserver(this)
            }
            setOptions(e, t) {
                const n = this.options,
                    r = this.#E;
                if (this.options = this.#u.defaultQueryOptions(e), void 0 !== this.options.enabled && "boolean" !== typeof this.options.enabled && "function" !== typeof this.options.enabled && "boolean" !== typeof we(this.options.enabled, this.#E)) throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
                this.#B(), this.#E.setOptions(this.options), n._defaulted && !Se(this.options, n) && this.#u.getQueryCache().notify({
                    type: "observerOptionsUpdated",
                    query: this.#E,
                    observer: this
                });
                const i = this.hasListeners();
                i && Ro(this.#E, r, this.options, n) && this.#O(), this.updateResult(t), !i || this.#E === r && we(this.options.enabled, this.#E) === we(n.enabled, this.#E) && be(this.options.staleTime, this.#E) === be(n.staleTime, this.#E) || this.#F();
                const o = this.#j();
                !i || this.#E === r && we(this.options.enabled, this.#E) === we(n.enabled, this.#E) && o === this.#M || this.#D(o)
            }
            getOptimisticResult(e) {
                const t = this.#u.getQueryCache().build(this.#u, e),
                    n = this.createResult(t, e);
                return function(e, t) {
                    if (!Se(e.getCurrentResult(), t)) return !0;
                    return !1
                }(this, n) && (this.#c = n, this.#k = this.options, this.#A = this.#E.state), n
            }
            getCurrentResult() {
                return this.#c
            }
            trackResult(e, t) {
                const n = {};
                return Object.keys(e).forEach((r => {
                    Object.defineProperty(n, r, {
                        configurable: !1,
                        enumerable: !0,
                        get: () => (this.trackProp(r), t ? .(r), e[r])
                    })
                })), n
            }
            trackProp(e) {
                this.#I.add(e)
            }
            getCurrentQuery() {
                return this.#E
            }
            refetch() {
                let { ...e
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return this.fetch({ ...e
                })
            }
            fetchOptimistic(e) {
                const t = this.#u.defaultQueryOptions(e),
                    n = this.#u.getQueryCache().build(this.#u, t);
                return n.isFetchingOptimistic = !0, n.fetch().then((() => this.createResult(n, t)))
            }
            fetch(e) {
                return this.#O({ ...e,
                    cancelRefetch: e.cancelRefetch ? ? !0
                }).then((() => (this.updateResult(), this.#c)))
            }#
            O(e) {
                this.#B();
                let t = this.#E.fetch(this.options, e);
                return e ? .throwOnError || (t = t.catch(ge)), t
            }#
            F() {
                this.#R();
                const e = be(this.options.staleTime, this.#E);
                if (me || this.#c.isStale || !ye(e)) return;
                const t = ve(this.#c.dataUpdatedAt, e) + 1;
                this.#_ = setTimeout((() => {
                    this.#c.isStale || this.updateResult()
                }), t)
            }#
            j() {
                return ("function" === typeof this.options.refetchInterval ? this.options.refetchInterval(this.#E) : this.options.refetchInterval) ? ? !1
            }#
            D(e) {
                this.#L(), this.#M = e, !me && !1 !== we(this.options.enabled, this.#E) && ye(this.#M) && 0 !== this.#M && (this.#N = setInterval((() => {
                    (this.options.refetchIntervalInBackground || je.isFocused()) && this.#O()
                }), this.#M))
            }#
            T() {
                this.#F(), this.#D(this.#j())
            }#
            R() {
                this.#_ && (clearTimeout(this.#_), this.#_ = void 0)
            }#
            L() {
                this.#N && (clearInterval(this.#N), this.#N = void 0)
            }
            createResult(e, t) {
                const n = this.#E,
                    r = this.options,
                    i = this.#c,
                    o = this.#A,
                    s = this.#k,
                    a = e !== n ? e.state : this.#x,
                    {
                        state: l
                    } = e;
                let u, c = { ...l
                    },
                    d = !1;
                if (t._optimisticResults) {
                    const i = this.hasListeners(),
                        o = !i && Oo(e, t),
                        s = i && Ro(e, n, t, r);
                    (o || s) && (c = { ...c,
                        ...Mo(l.data, e.options)
                    }), "isRestoring" === t._optimisticResults && (c.fetchStatus = "idle")
                }
                let {
                    error: h,
                    errorUpdatedAt: f,
                    status: p
                } = c;
                if (t.select && void 0 !== c.data)
                    if (i && c.data === o ? .data && t.select === this.#C) u = this.#P;
                    else try {
                        this.#C = t.select, u = t.select(c.data), u = Ie(i ? .data, u, t), this.#P = u, this.#w = null
                    } catch (w) {
                        this.#w = w
                    } else u = c.data;
                if (void 0 !== t.placeholderData && void 0 === u && "pending" === p) {
                    let e;
                    if (i ? .isPlaceholderData && t.placeholderData === s ? .placeholderData) e = i.data;
                    else if (e = "function" === typeof t.placeholderData ? t.placeholderData(this.#S ? .state.data, this.#S) : t.placeholderData, t.select && void 0 !== e) try {
                        e = t.select(e), this.#w = null
                    } catch (w) {
                        this.#w = w
                    }
                    void 0 !== e && (p = "success", u = Ie(i ? .data, e, t), d = !0)
                }
                this.#w && (h = this.#w, u = this.#P, f = Date.now(), p = "error");
                const m = "fetching" === c.fetchStatus,
                    g = "pending" === p,
                    y = "error" === p,
                    v = g && m,
                    b = void 0 !== u;
                return {
                    status: p,
                    fetchStatus: c.fetchStatus,
                    isPending: g,
                    isSuccess: "success" === p,
                    isError: y,
                    isInitialLoading: v,
                    isLoading: v,
                    data: u,
                    dataUpdatedAt: c.dataUpdatedAt,
                    error: h,
                    errorUpdatedAt: f,
                    failureCount: c.fetchFailureCount,
                    failureReason: c.fetchFailureReason,
                    errorUpdateCount: c.errorUpdateCount,
                    isFetched: c.dataUpdateCount > 0 || c.errorUpdateCount > 0,
                    isFetchedAfterMount: c.dataUpdateCount > a.dataUpdateCount || c.errorUpdateCount > a.errorUpdateCount,
                    isFetching: m,
                    isRefetching: m && !g,
                    isLoadingError: y && !b,
                    isPaused: "paused" === c.fetchStatus,
                    isPlaceholderData: d,
                    isRefetchError: y && b,
                    isStale: Lo(e, t),
                    refetch: this.refetch
                }
            }
            updateResult(e) {
                const t = this.#c,
                    n = this.createResult(this.#E, this.options);
                if (this.#A = this.#E.state, this.#k = this.options, void 0 !== this.#A.data && (this.#S = this.#E), Se(n, t)) return;
                this.#c = n;
                const r = {};
                !1 !== e ? .listeners && (() => {
                    if (!t) return !0;
                    const {
                        notifyOnChangeProps: e
                    } = this.options, n = "function" === typeof e ? e() : e;
                    if ("all" === n || !n && !this.#I.size) return !0;
                    const r = new Set(n ? ? this.#I);
                    return this.options.throwOnError && r.add("error"), Object.keys(this.#c).some((e => {
                        const n = e;
                        return this.#c[n] !== t[n] && r.has(n)
                    }))
                })() && (r.listeners = !0), this.#p({ ...r,
                    ...e
                })
            }#
            B() {
                const e = this.#u.getQueryCache().build(this.#u, this.options);
                if (e === this.#E) return;
                const t = this.#E;
                this.#E = e, this.#x = e.state, this.hasListeners() && (t ? .removeObserver(this), e.addObserver(this))
            }
            onQueryUpdate() {
                this.updateResult(), this.hasListeners() && this.#T()
            }#
            p(e) {
                pe.batch((() => {
                    e.listeners && this.listeners.forEach((e => {
                        e(this.#c)
                    })), this.#u.getQueryCache().notify({
                        query: this.#E,
                        type: "observerResultsUpdated"
                    })
                }))
            }
        };

        function Oo(e, t) {
            return function(e, t) {
                return !1 !== we(t.enabled, e) && void 0 === e.state.data && !("error" === e.state.status && !1 === t.retryOnMount)
            }(e, t) || void 0 !== e.state.data && To(e, t, t.refetchOnMount)
        }

        function To(e, t, n) {
            if (!1 !== we(t.enabled, e)) {
                const r = "function" === typeof n ? n(e) : n;
                return "always" === r || !1 !== r && Lo(e, t)
            }
            return !1
        }

        function Ro(e, t, n, r) {
            return (e !== t || !1 === we(r.enabled, e)) && (!n.suspense || "error" !== e.state.status) && Lo(e, n)
        }

        function Lo(e, t) {
            return !1 !== we(t.enabled, e) && e.isStaleByTime(be(t.staleTime, e))
        }

        function Bo() {
            let e = !1;
            return {
                clearReset: () => {
                    e = !1
                },
                reset: () => {
                    e = !0
                },
                isReset: () => e
            }
        }
        var Fo = r.createContext(Bo()),
            jo = () => r.useContext(Fo),
            Do = r.createContext(!1),
            Uo = () => r.useContext(Do),
            zo = (Do.Provider, (e, t) => {
                (e.suspense || e.throwOnError) && (t.isReset() || (e.retryOnMount = !1))
            }),
            qo = e => {
                r.useEffect((() => {
                    e.clearReset()
                }), [e])
            },
            Go = e => {
                let {
                    result: t,
                    errorResetBoundary: n,
                    throwOnError: r,
                    query: i
                } = e;
                return t.isError && !n.isReset() && !t.isFetching && i && Je(r, [t.error, i])
            },
            Ho = e => {
                e.suspense && ("number" !== typeof e.staleTime && (e.staleTime = 1e3), "number" === typeof e.gcTime && (e.gcTime = Math.max(e.gcTime, 1e3)))
            },
            $o = (e, t) => e ? .suspense && t.isPending,
            Qo = (e, t, n) => t.fetchOptimistic(e).catch((() => {
                n.clearReset()
            }));

        function Vo(e, t) {
            return function(e, t, n) {
                const i = Ke(n),
                    o = Uo(),
                    s = jo(),
                    a = i.defaultQueryOptions(e);
                i.getDefaultOptions().queries ? ._experimental_beforeQuery ? .(a), a._optimisticResults = o ? "isRestoring" : "optimistic", Ho(a), zo(a, s), qo(s);
                const [l] = r.useState((() => new t(i, a))), u = l.getOptimisticResult(a);
                if (r.useSyncExternalStore(r.useCallback((e => {
                        const t = o ? () => {} : l.subscribe(pe.batchCalls(e));
                        return l.updateResult(), t
                    }), [l, o]), (() => l.getCurrentResult()), (() => l.getCurrentResult())), r.useEffect((() => {
                        l.setOptions(a, {
                            listeners: !1
                        })
                    }), [a, l]), $o(a, u)) throw Qo(a, l, s);
                if (Go({
                        result: u,
                        errorResetBoundary: s,
                        throwOnError: a.throwOnError,
                        query: i.getQueryCache().get(a.queryHash)
                    })) throw u.error;
                return i.getDefaultOptions().queries ? ._experimental_afterQuery ? .(a, u), a.notifyOnChangeProps ? u : l.trackResult(u)
            }(e, Io, t)
        }

        function Ko(e) {
            return e.state.chainId
        }

        function Wo() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const {
                query: t = {},
                ...n
            } = e, i = gt(n), o = Ke(), {
                address: s,
                connector: a,
                status: l
            } = kr({
                config: i
            }), u = function() {
                const e = gt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {});
                return (0, r.useSyncExternalStore)((t => function(e, t) {
                    const {
                        onChange: n
                    } = t;
                    return e.subscribe((e => e.chainId), n)
                }(e, {
                    onChange: t
                })), (() => Ko(e)), (() => Ko(e)))
            }({
                config: i
            }), {
                queryKey: c,
                ...d
            } = So(i, { ...e,
                chainId: e.chainId ? ? u,
                connector: e.connector ? ? a
            }), h = Boolean("disconnected" !== l && (t.enabled ? ? !0)), f = (0, r.useRef)(s);
            return (0, r.useEffect)((() => {
                    const e = f.current;
                    !s && e ? (o.removeQueries({
                        queryKey: c
                    }), f.current = void 0) : s !== e && (o.invalidateQueries({
                        queryKey: c
                    }), f.current = s)
                }), [s, o]),
                function(e) {
                    const t = Vo({ ...e,
                        queryKeyHashFn: ko
                    });
                    return t.queryKey = e.queryKey, t
                }({ ...t,
                    ...d,
                    queryKey: c,
                    enabled: h,
                    staleTime: 1 / 0
                })
        }
        var Jo = n(2770),
            Zo = n(1313),
            Yo = n(1898),
            Xo = n(8604),
            es = n(9048),
            ts = n(7942);

        function ns(e, t) {
            if (!(e instanceof Rr.C)) return !1;
            const n = e.walk((e => e instanceof ts.M));
            return n instanceof ts.M && ("ResolverNotFound" === n.data ? .errorName || ("ResolverWildcardNotSupported" === n.data ? .errorName || ("ResolverNotContract" === n.data ? .errorName || ("ResolverError" === n.data ? .errorName || ("HttpError" === n.data ? .errorName || (!!n.reason ? .includes("Wildcard on non-extended resolvers is not supported") || "reverse" === t && n.reason === es.fD[50]))))))
        }
        var rs = n(1064);

        function is(e) {
            if (66 !== e.length) return null;
            if (0 !== e.indexOf("[")) return null;
            if (65 !== e.indexOf("]")) return null;
            const t = `0x${e.slice(1,65)}`;
            return (0, wi.q)(t) ? t : null
        }

        function os(e) {
            let t = new Uint8Array(32).fill(0);
            if (!e) return (0, Sr.My)(t);
            const n = e.split(".");
            for (let r = n.length - 1; r >= 0; r -= 1) {
                const e = is(n[r]),
                    i = e ? (0, ai.ZJ)(e) : (0, rs.S)((0, ai.Af)(n[r]), "bytes");
                t = (0, rs.S)((0, Nr.xW)([t, i]), "bytes")
            }
            return (0, Sr.My)(t)
        }

        function ss(e) {
            return `[${e.slice(2)}]`
        }

        function as(e) {
            const t = new Uint8Array(32).fill(0);
            return e ? is(e) || (0, rs.S)((0, ai.Af)(e)) : (0, Sr.My)(t)
        }

        function ls(e) {
            const t = e.replace(/^\.|\.$/gm, "");
            if (0 === t.length) return new Uint8Array(1);
            const n = new Uint8Array((0, ai.Af)(t).byteLength + 2);
            let r = 0;
            const i = t.split(".");
            for (let o = 0; o < i.length; o++) {
                let e = (0, ai.Af)(i[o]);
                e.byteLength > 255 && (e = (0, ai.Af)(ss(as(i[o])))), n[r] = e.length, n.set(e, r + 1), r += e.length + 1
            }
            return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n
        }
        const us = 3;

        function cs(e, t) {
            let {
                abi: n,
                address: r,
                args: i,
                docsPath: o,
                functionName: s,
                sender: a
            } = t;
            const {
                code: l,
                data: u,
                message: c,
                shortMessage: d
            } = e instanceof ts.$S ? e : e instanceof Rr.C ? e.walk((e => "data" in e)) || e.walk() : {}, h = e instanceof _r.O ? new ts.rR({
                functionName: s
            }) : [us, ro.code].includes(l) && (u || c || d) ? new ts.M({
                abi: n,
                data: "object" === typeof u ? u.data : u,
                functionName: s,
                message: d ? ? c
            }) : e;
            return new ts.bG(h, {
                abi: n,
                args: i,
                contractAddress: r,
                docsPath: o,
                functionName: s,
                sender: a
            })
        }
        var ds = n(9357);
        async function hs(e, t) {
            const {
                abi: n,
                address: r,
                args: i,
                functionName: o,
                ...s
            } = t, a = (0, Gi.p)({
                abi: n,
                args: i,
                functionName: o
            });
            try {
                const {
                    data: t
                } = await Gr(e, ds.T1, "call")({ ...s,
                    data: a,
                    to: r
                });
                return (0, Zo.e)({
                    abi: n,
                    args: i,
                    functionName: o,
                    data: t || "0x"
                })
            } catch (l) {
                throw cs(l, {
                    abi: n,
                    address: r,
                    args: i,
                    docsPath: "/docs/contract/readContract",
                    functionName: o
                })
            }
        }
        class fs extends Rr.C {
            constructor(e) {
                let {
                    data: t
                } = e;
                super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
                    metaMessages: ["- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.", "", `Provided data: ${JSON.stringify(t)}`]
                }), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "EnsAvatarInvalidMetadataError"
                })
            }
        }
        class ps extends Rr.C {
            constructor(e) {
                let {
                    reason: t
                } = e;
                super(`ENS NFT avatar URI is invalid. ${t}`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "EnsAvatarInvalidNftUriError"
                })
            }
        }
        class ms extends Rr.C {
            constructor(e) {
                let {
                    uri: t
                } = e;
                super(`Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "EnsAvatarUriResolutionError"
                })
            }
        }
        class gs extends Rr.C {
            constructor(e) {
                let {
                    namespace: t
                } = e;
                super(`ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "EnsAvatarUnsupportedNamespaceError"
                })
            }
        }
        const ys = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
            vs = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
            bs = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
            ws = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;

        function Es(e, t) {
            return e ? e.endsWith("/") ? e.slice(0, -1) : e : t
        }

        function xs(e) {
            let {
                uri: t,
                gatewayUrls: n
            } = e;
            const r = bs.test(t);
            if (r) return {
                uri: t,
                isOnChain: !0,
                isEncoded: r
            };
            const i = Es(n ? .ipfs, "https://ipfs.io"),
                o = Es(n ? .arweave, "https://arweave.net"),
                s = t.match(ys),
                {
                    protocol: a,
                    subpath: l,
                    target: u,
                    subtarget: c = ""
                } = s ? .groups || {},
                d = "ipns:/" === a || "ipns/" === l,
                h = "ipfs:/" === a || "ipfs/" === l || vs.test(t);
            if (t.startsWith("http") && !d && !h) {
                let e = t;
                return n ? .arweave && (e = t.replace(/https:\/\/arweave.net/g, n ? .arweave)), {
                    uri: e,
                    isOnChain: !1,
                    isEncoded: !1
                }
            }
            if ((d || h) && u) return {
                uri: `${i}/${d?"ipns":"ipfs"}/${u}${c}`,
                isOnChain: !1,
                isEncoded: !1
            };
            if ("ar:/" === a && u) return {
                uri: `${o}/${u}${c||""}`,
                isOnChain: !1,
                isEncoded: !1
            };
            let f = t.replace(ws, "");
            if (f.startsWith("<svg") && (f = `data:image/svg+xml;base64,${btoa(f)}`), f.startsWith("data:") || f.startsWith("{")) return {
                uri: f,
                isOnChain: !0,
                isEncoded: !1
            };
            throw new ms({
                uri: t
            })
        }

        function As(e) {
            if ("object" !== typeof e || !("image" in e) && !("image_url" in e) && !("image_data" in e)) throw new fs({
                data: e
            });
            return e.image || e.image_url || e.image_data
        }
        async function ks(e) {
            let {
                gatewayUrls: t,
                uri: n
            } = e;
            const {
                uri: r,
                isOnChain: i
            } = xs({
                uri: n,
                gatewayUrls: t
            });
            if (i) return r;
            const o = await async function(e) {
                try {
                    const t = await fetch(e, {
                        method: "HEAD"
                    });
                    if (200 === t.status) {
                        const e = t.headers.get("content-type");
                        return e ? .startsWith("image/")
                    }
                    return !1
                } catch (t) {
                    return ("object" !== typeof t || "undefined" === typeof t.response) && !!globalThis.hasOwnProperty("Image") && new Promise((t => {
                        const n = new Image;
                        n.onload = () => {
                            t(!0)
                        }, n.onerror = () => {
                            t(!1)
                        }, n.src = e
                    }))
                }
            }(r);
            if (o) return r;
            throw new ms({
                uri: n
            })
        }
        async function Cs(e, t) {
            let {
                gatewayUrls: n,
                record: r
            } = t;
            return /eip155:/i.test(r) ? async function(e, t) {
                let {
                    gatewayUrls: n,
                    record: r
                } = t;
                const i = function(e) {
                        let t = e;
                        t.startsWith("did:nft:") && (t = t.replace("did:nft:", "").replace(/_/g, "/"));
                        const [n, r, i] = t.split("/"), [o, s] = n.split(":"), [a, l] = r.split(":");
                        if (!o || "eip155" !== o.toLowerCase()) throw new ps({
                            reason: "Only EIP-155 supported"
                        });
                        if (!s) throw new ps({
                            reason: "Chain ID not found"
                        });
                        if (!l) throw new ps({
                            reason: "Contract address not found"
                        });
                        if (!i) throw new ps({
                            reason: "Token ID not found"
                        });
                        if (!a) throw new ps({
                            reason: "ERC namespace not found"
                        });
                        return {
                            chainID: parseInt(s),
                            namespace: a.toLowerCase(),
                            contractAddress: l,
                            tokenID: i
                        }
                    }(r),
                    o = await async function(e, t) {
                        let {
                            nft: n
                        } = t;
                        if ("erc721" === n.namespace) return hs(e, {
                            address: n.contractAddress,
                            abi: [{
                                name: "tokenURI",
                                type: "function",
                                stateMutability: "view",
                                inputs: [{
                                    name: "tokenId",
                                    type: "uint256"
                                }],
                                outputs: [{
                                    name: "",
                                    type: "string"
                                }]
                            }],
                            functionName: "tokenURI",
                            args: [BigInt(n.tokenID)]
                        });
                        if ("erc1155" === n.namespace) return hs(e, {
                            address: n.contractAddress,
                            abi: [{
                                name: "uri",
                                type: "function",
                                stateMutability: "view",
                                inputs: [{
                                    name: "_id",
                                    type: "uint256"
                                }],
                                outputs: [{
                                    name: "",
                                    type: "string"
                                }]
                            }],
                            functionName: "uri",
                            args: [BigInt(n.tokenID)]
                        });
                        throw new gs({
                            namespace: n.namespace
                        })
                    }(e, {
                        nft: i
                    }),
                    {
                        uri: s,
                        isOnChain: a,
                        isEncoded: l
                    } = xs({
                        uri: o,
                        gatewayUrls: n
                    });
                if (a && (s.includes("data:application/json;base64,") || s.startsWith("{"))) {
                    const e = l ? atob(s.replace("data:application/json;base64,", "")) : s;
                    return ks({
                        uri: As(JSON.parse(e)),
                        gatewayUrls: n
                    })
                }
                let u = i.tokenID;
                "erc1155" === i.namespace && (u = u.replace("0x", "").padStart(64, "0"));
                return async function(e) {
                    let {
                        gatewayUrls: t,
                        uri: n
                    } = e;
                    try {
                        const e = await fetch(n).then((e => e.json()));
                        return await ks({
                            gatewayUrls: t,
                            uri: As(e)
                        })
                    } catch {
                        throw new ms({
                            uri: n
                        })
                    }
                }({
                    gatewayUrls: n,
                    uri: s.replace(/(?:0x)?{id}/, u)
                })
            }(e, {
                gatewayUrls: n,
                record: r
            }) : ks({
                uri: r,
                gatewayUrls: n
            })
        }
        async function Ps(e, t) {
            let {
                blockNumber: n,
                blockTag: r,
                name: i,
                key: o,
                gatewayUrls: s,
                strict: a,
                universalResolverAddress: l
            } = t, u = l;
            if (!u) {
                if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                u = (0, Yo.M)({
                    blockNumber: n,
                    chain: e.chain,
                    contract: "ensUniversalResolver"
                })
            }
            try {
                const t = {
                        address: u,
                        abi: Jo.Ag,
                        functionName: "resolve",
                        args: [(0, Sr.nj)(ls(i)), (0, Gi.p)({
                            abi: Jo.SJ,
                            functionName: "text",
                            args: [os(i), o]
                        })],
                        blockNumber: n,
                        blockTag: r
                    },
                    a = Gr(e, hs, "readContract"),
                    l = s ? await a({ ...t,
                        args: [...t.args, s]
                    }) : await a(t);
                if ("0x" === l[0]) return null;
                const c = (0, Zo.e)({
                    abi: Jo.SJ,
                    functionName: "text",
                    data: l[0]
                });
                return "" === c ? null : c
            } catch (c) {
                if (a) throw c;
                if (ns(c, "resolve")) return null;
                throw c
            }
        }

        function Ss(e, t) {
            let {
                method: n
            } = t;
            const r = {};
            return "fallback" === e.transport.type && e.transport.onResponse ? .((e => {
                let {
                    method: t,
                    response: i,
                    status: o,
                    transport: s
                } = e;
                "success" === o && n === t && (r[i] = s.request)
            })), t => r[t] || e.request
        }
        class _s extends Rr.C {
            constructor(e) {
                super(`Filter type "${e}" is not supported.`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "FilterTypeNotSupportedError"
                })
            }
        }
        var Ns = n(284),
            Ms = n(9052),
            Is = n(2283);
        const Os = "/docs/contract/encodeEventTopics";

        function Ts(e) {
            const {
                abi: t,
                eventName: n,
                args: r
            } = e;
            let i = t[0];
            if (n) {
                const e = (0, Is.iY)({
                    abi: t,
                    name: n
                });
                if (!e) throw new _r.M_(n, {
                    docsPath: Os
                });
                i = e
            }
            if ("event" !== i.type) throw new _r.M_(void 0, {
                docsPath: Os
            });
            const o = (0, Ms.B)(i),
                s = (0, Ns.h)(o);
            let a = [];
            if (r && "inputs" in i) {
                const e = i.inputs ? .filter((e => "indexed" in e && e.indexed)),
                    t = Array.isArray(r) ? r : Object.values(r).length > 0 ? e ? .map((e => r[e.name])) ? ? [] : [];
                t.length > 0 && (a = e ? .map(((e, n) => Array.isArray(t[n]) ? t[n].map(((r, i) => Rs({
                    param: e,
                    value: t[n][i]
                }))) : t[n] ? Rs({
                    param: e,
                    value: t[n]
                }) : null)) ? ? [])
            }
            return [s, ...a]
        }

        function Rs(e) {
            let {
                param: t,
                value: n
            } = e;
            if ("string" === t.type || "bytes" === t.type) return (0, rs.S)((0, ai.ZJ)(n));
            if ("tuple" === t.type || t.type.match(/^(.*)\[(\d+)?\]$/)) throw new _s(t.type);
            return (0, Mr.h)([t], [n])
        }
        async function Ls(e, t) {
            const {
                address: n,
                abi: r,
                args: i,
                eventName: o,
                fromBlock: s,
                strict: a,
                toBlock: l
            } = t, u = Ss(e, {
                method: "eth_newFilter"
            }), c = o ? Ts({
                abi: r,
                args: i,
                eventName: o
            }) : void 0, d = await e.request({
                method: "eth_newFilter",
                params: [{
                    address: n,
                    fromBlock: "bigint" === typeof s ? (0, Sr.cK)(s) : s,
                    toBlock: "bigint" === typeof l ? (0, Sr.cK)(l) : l,
                    topics: c
                }]
            });
            return {
                abi: r,
                args: i,
                eventName: o,
                id: d,
                request: u(d),
                strict: Boolean(a),
                type: "event"
            }
        }
        async function Bs(e) {
            let {
                address: t,
                args: n,
                event: r,
                events: i,
                fromBlock: o,
                strict: s,
                toBlock: a
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const l = i ? ? (r ? [r] : void 0),
                u = Ss(e, {
                    method: "eth_newFilter"
                });
            let c = [];
            l && (c = [l.flatMap((e => Ts({
                abi: [e],
                eventName: e.name,
                args: n
            })))], r && (c = c[0]));
            const d = await e.request({
                method: "eth_newFilter",
                params: [{
                    address: t,
                    fromBlock: "bigint" === typeof o ? (0, Sr.cK)(o) : o,
                    toBlock: "bigint" === typeof a ? (0, Sr.cK)(a) : a,
                    ...c.length ? {
                        topics: c
                    } : {}
                }]
            });
            return {
                abi: l,
                args: n,
                eventName: r ? r.name : void 0,
                fromBlock: o,
                id: d,
                request: u(d),
                strict: Boolean(s),
                toBlock: a,
                type: "event"
            }
        }
        async function Fs(e) {
            const t = Ss(e, {
                    method: "eth_newPendingTransactionFilter"
                }),
                n = await e.request({
                    method: "eth_newPendingTransactionFilter"
                });
            return {
                id: n,
                request: t(n),
                type: "transaction"
            }
        }
        const js = new Map,
            Ds = new Map;
        async function Us(e, t) {
            let {
                cacheKey: n,
                cacheTime: r = 1 / 0
            } = t;
            const i = function(e) {
                    const t = (e, t) => ({
                            clear: () => t.delete(e),
                            get: () => t.get(e),
                            set: n => t.set(e, n)
                        }),
                        n = t(e, js),
                        r = t(e, Ds);
                    return {
                        clear: () => {
                            n.clear(), r.clear()
                        },
                        promise: n,
                        response: r
                    }
                }(n),
                o = i.response.get();
            if (o && r > 0) {
                if ((new Date).getTime() - o.created.getTime() < r) return o.data
            }
            let s = i.promise.get();
            s || (s = e(), i.promise.set(s));
            try {
                const e = await s;
                return i.response.set({
                    created: new Date,
                    data: e
                }), e
            } finally {
                i.promise.clear()
            }
        }
        const zs = e => `blockNumber.${e}`;
        async function qs(e) {
            let {
                cacheTime: t = e.cacheTime
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const n = await Us((() => e.request({
                method: "eth_blockNumber"
            })), {
                cacheKey: zs(e.uid),
                cacheTime: t
            });
            return BigInt(n)
        }
        var Gs = n(9577),
            Hs = n(3206);
        const $s = "/docs/contract/decodeEventLog";

        function Qs(e) {
            const {
                abi: t,
                data: n,
                strict: r,
                topics: i
            } = e, o = r ? ? !0, [s, ...a] = i;
            if (!s) throw new _r._z({
                docsPath: $s
            });
            const l = t.find((e => "event" === e.type && s === (0, Ns.h)((0, Ms.B)(e))));
            if (!l || !("name" in l) || "event" !== l.type) throw new _r.kE(s, {
                docsPath: $s
            });
            const {
                name: u,
                inputs: c
            } = l, d = c ? .some((e => !("name" in e && e.name)));
            let h = d ? [] : {};
            const f = c.filter((e => "indexed" in e && e.indexed));
            for (let g = 0; g < f.length; g++) {
                const e = f[g],
                    t = a[g];
                if (!t) throw new _r.l3({
                    abiItem: l,
                    param: e
                });
                h[d ? g : e.name || g] = Vs({
                    param: e,
                    value: t
                })
            }
            const p = c.filter((e => !("indexed" in e && e.indexed)));
            if (p.length > 0)
                if (n && "0x" !== n) try {
                    const e = (0, Hs.n)(p, n);
                    if (e)
                        if (d) h = [...h, ...e];
                        else
                            for (let t = 0; t < p.length; t++) h[p[t].name] = e[t]
                } catch (m) {
                    if (o) {
                        if (m instanceof _r.Iy || m instanceof Gs.SK) throw new _r.fo({
                            abiItem: l,
                            data: n,
                            params: p,
                            size: (0, Ni.E)(n)
                        });
                        throw m
                    }
                } else if (o) throw new _r.fo({
                    abiItem: l,
                    data: "0x",
                    params: p,
                    size: 0
                });
            return {
                eventName: u,
                args: Object.values(h).length > 0 ? h : void 0
            }
        }

        function Vs(e) {
            let {
                param: t,
                value: n
            } = e;
            if ("string" === t.type || "bytes" === t.type || "tuple" === t.type || t.type.match(/^(.*)\[(\d+)?\]$/)) return n;
            return ((0, Hs.n)([t], n) || [])[0]
        }

        function Ks(e) {
            let {
                abi: t,
                eventName: n,
                logs: r,
                strict: i = !0
            } = e;
            return r.map((e => {
                try {
                    const r = Qs({ ...e,
                        abi: t,
                        strict: i
                    });
                    return n && !n.includes(r.eventName) ? null : { ...r,
                        ...e
                    }
                } catch (r) {
                    let t, n;
                    if (r instanceof _r.kE) return null;
                    if (r instanceof _r.fo || r instanceof _r.l3) {
                        if (i) return null;
                        t = r.abiItem.name, n = r.abiItem.inputs ? .some((e => !("name" in e && e.name)))
                    }
                    return { ...e,
                        args: n ? [] : {},
                        eventName: t
                    }
                }
            })).filter(Boolean)
        }

        function Ws(e) {
            let {
                args: t,
                eventName: n
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            return { ...e,
                blockHash: e.blockHash ? e.blockHash : null,
                blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
                logIndex: e.logIndex ? Number(e.logIndex) : null,
                transactionHash: e.transactionHash ? e.transactionHash : null,
                transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
                ...n ? {
                    args: t,
                    eventName: n
                } : {}
            }
        }
        async function Js(e) {
            let {
                address: t,
                blockHash: n,
                fromBlock: r,
                toBlock: i,
                event: o,
                events: s,
                args: a,
                strict: l
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const u = l ? ? !1,
                c = s ? ? (o ? [o] : void 0);
            let d, h = [];
            c && (h = [c.flatMap((e => Ts({
                abi: [e],
                eventName: e.name,
                args: a
            })))], o && (h = h[0])), d = n ? await e.request({
                method: "eth_getLogs",
                params: [{
                    address: t,
                    topics: h,
                    blockHash: n
                }]
            }) : await e.request({
                method: "eth_getLogs",
                params: [{
                    address: t,
                    topics: h,
                    fromBlock: "bigint" === typeof r ? (0, Sr.cK)(r) : r,
                    toBlock: "bigint" === typeof i ? (0, Sr.cK)(i) : i
                }]
            });
            const f = d.map((e => Ws(e)));
            return c ? Ks({
                abi: c,
                logs: f,
                strict: u
            }) : f
        }
        async function Zs(e, t) {
            const {
                abi: n,
                address: r,
                args: i,
                blockHash: o,
                eventName: s,
                fromBlock: a,
                toBlock: l,
                strict: u
            } = t, c = s ? (0, Is.iY)({
                abi: n,
                name: s
            }) : void 0, d = c ? void 0 : n.filter((e => "event" === e.type));
            return Gr(e, Js, "getLogs")({
                address: r,
                args: i,
                blockHash: o,
                event: c,
                events: d,
                fromBlock: a,
                toBlock: l,
                strict: u
            })
        }
        async function Ys(e, t) {
            let {
                blockCount: n,
                blockNumber: r,
                blockTag: i = "latest",
                rewardPercentiles: o
            } = t;
            const s = r ? (0, Sr.cK)(r) : void 0;
            return function(e) {
                return {
                    baseFeePerGas: e.baseFeePerGas.map((e => BigInt(e))),
                    gasUsedRatio: e.gasUsedRatio,
                    oldestBlock: BigInt(e.oldestBlock),
                    reward: e.reward ? .map((e => e.map((e => BigInt(e)))))
                }
            }(await e.request({
                method: "eth_feeHistory",
                params: [(0, Sr.cK)(n), s || i, o]
            }))
        }
        async function Xs(e, t) {
            let {
                filter: n
            } = t;
            const r = "strict" in n && n.strict,
                i = await n.request({
                    method: "eth_getFilterChanges",
                    params: [n.id]
                });
            if ("string" === typeof i[0]) return i;
            const o = i.map((e => Ws(e)));
            return "abi" in n && n.abi ? Ks({
                abi: n.abi,
                logs: o,
                strict: r
            }) : o
        }
        async function ea(e, t) {
            let {
                address: n,
                blockNumber: r,
                blockTag: i,
                storageKeys: o
            } = t;
            const s = i ? ? "latest",
                a = void 0 !== r ? (0, Sr.cK)(r) : void 0;
            return function(e) {
                return { ...e,
                    balance: e.balance ? BigInt(e.balance) : void 0,
                    nonce: e.nonce ? (0, Cr.ME)(e.nonce) : void 0,
                    storageProof: e.storageProof ? (t = e.storageProof, t.map((e => ({ ...e,
                        value: BigInt(e.value)
                    })))) : void 0
                };
                var t
            }(await e.request({
                method: "eth_getProof",
                params: [n, o, a || s]
            }))
        }
        async function ta(e, t) {
            let {
                blockHash: n,
                blockNumber: r,
                blockTag: i,
                hash: o,
                index: s
            } = t;
            const a = i || "latest",
                l = void 0 !== r ? (0, Sr.cK)(r) : void 0;
            let u = null;
            if (o ? u = await e.request({
                    method: "eth_getTransactionByHash",
                    params: [o]
                }) : n ? u = await e.request({
                    method: "eth_getTransactionByBlockHashAndIndex",
                    params: [n, (0, Sr.cK)(s)]
                }) : (l || a) && (u = await e.request({
                    method: "eth_getTransactionByBlockNumberAndIndex",
                    params: [l || a, (0, Sr.cK)(s)]
                })), !u) throw new Dr.Kz({
                blockHash: n,
                blockNumber: r,
                blockTag: a,
                hash: o,
                index: s
            });
            return (e.chain ? .formatters ? .transaction ? .format || Zr)(u)
        }
        const na = {
            "0x0": "reverted",
            "0x1": "success"
        };

        function ra(e) {
            const t = { ...e,
                blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
                contractAddress: e.contractAddress ? e.contractAddress : null,
                cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
                effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
                gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
                logs: e.logs ? e.logs.map((e => Ws(e))) : null,
                to: e.to ? e.to : null,
                transactionIndex: e.transactionIndex ? (0, Cr.ME)(e.transactionIndex) : null,
                status: e.status ? na[e.status] : null,
                type: e.type ? Jr[e.type] || e.type : null
            };
            return e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)), e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)), t
        }
        async function ia(e, t) {
            let {
                hash: n
            } = t;
            const r = await e.request({
                method: "eth_getTransactionReceipt",
                params: [n]
            });
            if (!r) throw new Dr.Kc({
                hash: n
            });
            return (e.chain ? .formatters ? .transactionReceipt ? .format || ra)(r)
        }
        async function oa(e, t) {
            let {
                filter: n
            } = t;
            return n.request({
                method: "eth_uninstallFilter",
                params: [n.id]
            })
        }
        const sa = "\x19Ethereum Signed Message:\n";
        const aa = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572",
            la = (BigInt(0), BigInt(1)),
            ua = BigInt(2);

        function ca(e) {
            return e instanceof Uint8Array || null != e && "object" === typeof e && "Uint8Array" === e.constructor.name
        }

        function da(e) {
            if (!ca(e)) throw new Error("Uint8Array expected")
        }
        const ha = Array.from({
            length: 256
        }, ((e, t) => t.toString(16).padStart(2, "0")));

        function fa(e) {
            da(e);
            let t = "";
            for (let n = 0; n < e.length; n++) t += ha[e[n]];
            return t
        }

        function pa(e) {
            if ("string" !== typeof e) throw new Error("hex string expected, got " + typeof e);
            return BigInt("" === e ? "0" : `0x${e}`)
        }
        const ma = {
            _0: 48,
            _9: 57,
            _A: 65,
            _F: 70,
            _a: 97,
            _f: 102
        };

        function ga(e) {
            return e >= ma._0 && e <= ma._9 ? e - ma._0 : e >= ma._A && e <= ma._F ? e - (ma._A - 10) : e >= ma._a && e <= ma._f ? e - (ma._a - 10) : void 0
        }

        function ya(e) {
            if ("string" !== typeof e) throw new Error("hex string expected, got " + typeof e);
            const t = e.length,
                n = t / 2;
            if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
            const r = new Uint8Array(n);
            for (let i = 0, o = 0; i < n; i++, o += 2) {
                const t = ga(e.charCodeAt(o)),
                    n = ga(e.charCodeAt(o + 1));
                if (void 0 === t || void 0 === n) {
                    const t = e[o] + e[o + 1];
                    throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + o)
                }
                r[i] = 16 * t + n
            }
            return r
        }

        function va(e) {
            return pa(fa(e))
        }

        function ba(e) {
            return da(e), pa(fa(Uint8Array.from(e).reverse()))
        }

        function wa(e, t) {
            return ya(e.toString(16).padStart(2 * t, "0"))
        }

        function Ea(e, t) {
            return wa(e, t).reverse()
        }

        function xa(e, t, n) {
            let r;
            if ("string" === typeof t) try {
                r = ya(t)
            } catch (dg) {
                throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${dg}`)
            } else {
                if (!ca(t)) throw new Error(`${e} must be hex string or Uint8Array`);
                r = Uint8Array.from(t)
            }
            const i = r.length;
            if ("number" === typeof n && i !== n) throw new Error(`${e} expected ${n} bytes, got ${i}`);
            return r
        }

        function Aa() {
            let e = 0;
            for (let n = 0; n < arguments.length; n++) {
                const t = n < 0 || arguments.length <= n ? void 0 : arguments[n];
                da(t), e += t.length
            }
            const t = new Uint8Array(e);
            for (let n = 0, r = 0; n < arguments.length; n++) {
                const e = n < 0 || arguments.length <= n ? void 0 : arguments[n];
                t.set(e, r), r += e.length
            }
            return t
        }

        function ka(e, t) {
            if (e.length !== t.length) return !1;
            let n = 0;
            for (let r = 0; r < e.length; r++) n |= e[r] ^ t[r];
            return 0 === n
        }
        const Ca = e => (ua << BigInt(e - 1)) - la,
            Pa = e => new Uint8Array(e),
            Sa = e => Uint8Array.from(e);

        function _a(e, t, n) {
            if ("number" !== typeof e || e < 2) throw new Error("hashLen must be a number");
            if ("number" !== typeof t || t < 2) throw new Error("qByteLen must be a number");
            if ("function" !== typeof n) throw new Error("hmacFn must be a function");
            let r = Pa(e),
                i = Pa(e),
                o = 0;
            const s = () => {
                    r.fill(1), i.fill(0), o = 0
                },
                a = function() {
                    for (var e = arguments.length, t = new Array(e), o = 0; o < e; o++) t[o] = arguments[o];
                    return n(i, r, ...t)
                },
                l = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Pa();
                    i = a(Sa([0]), e), r = a(), 0 !== e.length && (i = a(Sa([1]), e), r = a())
                },
                u = () => {
                    if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
                    let e = 0;
                    const n = [];
                    for (; e < t;) {
                        r = a();
                        const t = r.slice();
                        n.push(t), e += r.length
                    }
                    return Aa(...n)
                };
            return (e, t) => {
                let n;
                for (s(), l(e); !(n = t(u()));) l();
                return s(), n
            }
        }
        const Na = {
            bigint: e => "bigint" === typeof e,
            function: e => "function" === typeof e,
            boolean: e => "boolean" === typeof e,
            string: e => "string" === typeof e,
            stringOrUint8Array: e => "string" === typeof e || ca(e),
            isSafeInteger: e => Number.isSafeInteger(e),
            array: e => Array.isArray(e),
            field: (e, t) => t.Fp.isValid(e),
            hash: e => "function" === typeof e && Number.isSafeInteger(e.outputLen)
        };

        function Ma(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const r = (t, n, r) => {
                const i = Na[n];
                if ("function" !== typeof i) throw new Error(`Invalid validator "${n}", expected function`);
                const o = e[t];
                if ((!r || void 0 !== o) && !i(o, e)) throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${n}`)
            };
            for (const [i, o] of Object.entries(t)) r(i, o, !1);
            for (const [i, o] of Object.entries(n)) r(i, o, !0);
            return e
        }
        const Ia = BigInt(0),
            Oa = BigInt(1),
            Ta = BigInt(2),
            Ra = BigInt(3),
            La = BigInt(4),
            Ba = BigInt(5),
            Fa = BigInt(8);
        BigInt(9), BigInt(16);

        function ja(e, t) {
            const n = e % t;
            return n >= Ia ? n : t + n
        }

        function Da(e, t, n) {
            if (n <= Ia || t < Ia) throw new Error("Expected power/modulo > 0");
            if (n === Oa) return Ia;
            let r = Oa;
            for (; t > Ia;) t & Oa && (r = r * e % n), e = e * e % n, t >>= Oa;
            return r
        }

        function Ua(e, t, n) {
            let r = e;
            for (; t-- > Ia;) r *= r, r %= n;
            return r
        }

        function za(e, t) {
            if (e === Ia || t <= Ia) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
            let n = ja(e, t),
                r = t,
                i = Ia,
                o = Oa,
                s = Oa,
                a = Ia;
            for (; n !== Ia;) {
                const e = r / n,
                    t = r % n,
                    l = i - s * e,
                    u = o - a * e;
                r = n, n = t, i = s, o = a, s = l, a = u
            }
            if (r !== Oa) throw new Error("invert: does not exist");
            return ja(i, t)
        }

        function qa(e) {
            if (e % La === Ra) {
                const t = (e + Oa) / La;
                return function(e, n) {
                    const r = e.pow(n, t);
                    if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                    return r
                }
            }
            if (e % Fa === Ba) {
                const t = (e - Ba) / Fa;
                return function(e, n) {
                    const r = e.mul(n, Ta),
                        i = e.pow(r, t),
                        o = e.mul(n, i),
                        s = e.mul(e.mul(o, Ta), i),
                        a = e.mul(o, e.sub(s, e.ONE));
                    if (!e.eql(e.sqr(a), n)) throw new Error("Cannot find square root");
                    return a
                }
            }
            return function(e) {
                const t = (e - Oa) / Ta;
                let n, r, i;
                for (n = e - Oa, r = 0; n % Ta === Ia; n /= Ta, r++);
                for (i = Ta; i < e && Da(i, t, e) !== e - Oa; i++);
                if (1 === r) {
                    const t = (e + Oa) / La;
                    return function(e, n) {
                        const r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                        return r
                    }
                }
                const o = (n + Oa) / Ta;
                return function(e, s) {
                    if (e.pow(s, t) === e.neg(e.ONE)) throw new Error("Cannot find square root");
                    let a = r,
                        l = e.pow(e.mul(e.ONE, i), n),
                        u = e.pow(s, o),
                        c = e.pow(s, n);
                    for (; !e.eql(c, e.ONE);) {
                        if (e.eql(c, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let r = e.sqr(c); t < a && !e.eql(r, e.ONE); t++) r = e.sqr(r);
                        const n = e.pow(l, Oa << BigInt(a - t - 1));
                        l = e.sqr(n), u = e.mul(u, n), c = e.mul(c, l), a = t
                    }
                    return u
                }
            }(e)
        }
        const Ga = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

        function Ha(e, t) {
            const n = void 0 !== t ? t : e.toString(2).length;
            return {
                nBitLength: n,
                nByteLength: Math.ceil(n / 8)
            }
        }

        function $a(e) {
            if ("bigint" !== typeof e) throw new Error("field order must be bigint");
            const t = e.toString(2).length;
            return Math.ceil(t / 8)
        }

        function Qa(e) {
            const t = $a(e);
            return t + Math.ceil(t / 2)
        }
        class Va extends di.Vw {
            constructor(e, t) {
                super(), this.finished = !1, this.destroyed = !1, (0, ci.tW)(e);
                const n = (0, di.ZJ)(t);
                if (this.iHash = e.create(), "function" !== typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
                this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                const r = this.blockLen,
                    i = new Uint8Array(r);
                i.set(n.length > r ? e.create().update(n).digest() : n);
                for (let o = 0; o < i.length; o++) i[o] ^= 54;
                this.iHash.update(i), this.oHash = e.create();
                for (let o = 0; o < i.length; o++) i[o] ^= 106;
                this.oHash.update(i), i.fill(0)
            }
            update(e) {
                return (0, ci.t2)(this), this.iHash.update(e), this
            }
            digestInto(e) {
                (0, ci.t2)(this), (0, ci.ee)(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
            }
            digest() {
                const e = new Uint8Array(this.oHash.outputLen);
                return this.digestInto(e), e
            }
            _cloneInto(e) {
                e || (e = Object.create(Object.getPrototypeOf(this), {}));
                const {
                    oHash: t,
                    iHash: n,
                    finished: r,
                    destroyed: i,
                    blockLen: o,
                    outputLen: s
                } = this;
                return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
            }
            destroy() {
                this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
            }
        }
        const Ka = (e, t, n) => new Va(e, t).update(n).digest();
        Ka.create = (e, t) => new Va(e, t);
        const Wa = BigInt(0),
            Ja = BigInt(1);

        function Za(e) {
            return Ma(e.Fp, Ga.reduce(((e, t) => (e[t] = "function", e)), {
                ORDER: "bigint",
                MASK: "bigint",
                BYTES: "isSafeInteger",
                BITS: "isSafeInteger"
            })), Ma(e, {
                n: "bigint",
                h: "bigint",
                Gx: "field",
                Gy: "field"
            }, {
                nBitLength: "isSafeInteger",
                nByteLength: "isSafeInteger"
            }), Object.freeze({ ...Ha(e.n, e.nBitLength),
                ...e,
                p: e.Fp.ORDER
            })
        }
        const {
            Ph: Ya,
            aT: Xa
        } = e, el = {
            Err: class extends Error {
                constructor() {
                    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "")
                }
            },
            _parseInt(e) {
                const {
                    Err: t
                } = el;
                if (e.length < 2 || 2 !== e[0]) throw new t("Invalid signature integer tag");
                const n = e[1],
                    r = e.subarray(2, n + 2);
                if (!n || r.length !== n) throw new t("Invalid signature integer: wrong length");
                if (128 & r[0]) throw new t("Invalid signature integer: negative");
                if (0 === r[0] && !(128 & r[1])) throw new t("Invalid signature integer: unnecessary leading zero");
                return {
                    d: Ya(r),
                    l: e.subarray(n + 2)
                }
            },
            toSig(e) {
                const {
                    Err: t
                } = el, n = "string" === typeof e ? Xa(e) : e;
                da(n);
                let r = n.length;
                if (r < 2 || 48 != n[0]) throw new t("Invalid signature tag");
                if (n[1] !== r - 2) throw new t("Invalid signature: incorrect length");
                const {
                    d: i,
                    l: o
                } = el._parseInt(n.subarray(2)), {
                    d: s,
                    l: a
                } = el._parseInt(o);
                if (a.length) throw new t("Invalid signature: left bytes after parsing");
                return {
                    r: i,
                    s: s
                }
            },
            hexFromSig(e) {
                const t = e => 8 & Number.parseInt(e[0], 16) ? "00" + e : e,
                    n = e => {
                        const t = e.toString(16);
                        return 1 & t.length ? `0${t}` : t
                    },
                    r = t(n(e.s)),
                    i = t(n(e.r)),
                    o = r.length / 2,
                    s = i.length / 2,
                    a = n(o),
                    l = n(s);
                return `30${n(s+o+4)}02${l}${i}02${a}${r}`
            }
        }, tl = BigInt(0), nl = BigInt(1), rl = (BigInt(2), BigInt(3));
        BigInt(4);

        function il(e) {
            const t = function(e) {
                    const t = Za(e);
                    Ma(t, {
                        a: "field",
                        b: "field"
                    }, {
                        allowedPrivateKeyLengths: "array",
                        wrapPrivateKey: "boolean",
                        isTorsionFree: "function",
                        clearCofactor: "function",
                        allowInfinityPoint: "boolean",
                        fromBytes: "function",
                        toBytes: "function"
                    });
                    const {
                        endo: n,
                        Fp: r,
                        a: i
                    } = t;
                    if (n) {
                        if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                        if ("object" !== typeof n || "bigint" !== typeof n.beta || "function" !== typeof n.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                    }
                    return Object.freeze({ ...t
                    })
                }(e),
                {
                    Fp: n
                } = t,
                r = t.toBytes || ((e, t, r) => {
                    const i = t.toAffine();
                    return Aa(Uint8Array.from([4]), n.toBytes(i.x), n.toBytes(i.y))
                }),
                i = t.fromBytes || (e => {
                    const t = e.subarray(1);
                    return {
                        x: n.fromBytes(t.subarray(0, n.BYTES)),
                        y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES))
                    }
                });

            function o(e) {
                const {
                    a: r,
                    b: i
                } = t, o = n.sqr(e), s = n.mul(o, e);
                return n.add(n.add(s, n.mul(e, r)), i)
            }
            if (!n.eql(n.sqr(t.Gy), o(t.Gx))) throw new Error("bad generator point: equation left != right");

            function s(e) {
                return "bigint" === typeof e && tl < e && e < t.n
            }

            function a(e) {
                if (!s(e)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
            }

            function l(e) {
                const {
                    allowedPrivateKeyLengths: n,
                    nByteLength: r,
                    wrapPrivateKey: i,
                    n: o
                } = t;
                if (n && "bigint" !== typeof e) {
                    if (ca(e) && (e = fa(e)), "string" !== typeof e || !n.includes(e.length)) throw new Error("Invalid key");
                    e = e.padStart(2 * r, "0")
                }
                let s;
                try {
                    s = "bigint" === typeof e ? e : va(xa("private key", e, r))
                } catch (l) {
                    throw new Error(`private key must be ${r} bytes, hex or bigint, not ${typeof e}`)
                }
                return i && (s = ja(s, o)), a(s), s
            }
            const u = new Map;

            function c(e) {
                if (!(e instanceof d)) throw new Error("ProjectivePoint expected")
            }
            class d {
                constructor(e, t, r) {
                    if (this.px = e, this.py = t, this.pz = r, null == e || !n.isValid(e)) throw new Error("x required");
                    if (null == t || !n.isValid(t)) throw new Error("y required");
                    if (null == r || !n.isValid(r)) throw new Error("z required")
                }
                static fromAffine(e) {
                    const {
                        x: t,
                        y: r
                    } = e || {};
                    if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error("invalid affine point");
                    if (e instanceof d) throw new Error("projective point not allowed");
                    const i = e => n.eql(e, n.ZERO);
                    return i(t) && i(r) ? d.ZERO : new d(t, r, n.ONE)
                }
                get x() {
                    return this.toAffine().x
                }
                get y() {
                    return this.toAffine().y
                }
                static normalizeZ(e) {
                    const t = n.invertBatch(e.map((e => e.pz)));
                    return e.map(((e, n) => e.toAffine(t[n]))).map(d.fromAffine)
                }
                static fromHex(e) {
                    const t = d.fromAffine(i(xa("pointHex", e)));
                    return t.assertValidity(), t
                }
                static fromPrivateKey(e) {
                    return d.BASE.multiply(l(e))
                }
                _setWindowSize(e) {
                    this._WINDOW_SIZE = e, u.delete(this)
                }
                assertValidity() {
                    if (this.is0()) {
                        if (t.allowInfinityPoint && !n.is0(this.py)) return;
                        throw new Error("bad point: ZERO")
                    }
                    const {
                        x: e,
                        y: r
                    } = this.toAffine();
                    if (!n.isValid(e) || !n.isValid(r)) throw new Error("bad point: x or y not FE");
                    const i = n.sqr(r),
                        s = o(e);
                    if (!n.eql(i, s)) throw new Error("bad point: equation left != right");
                    if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
                }
                hasEvenY() {
                    const {
                        y: e
                    } = this.toAffine();
                    if (n.isOdd) return !n.isOdd(e);
                    throw new Error("Field doesn't support isOdd")
                }
                equals(e) {
                    c(e);
                    const {
                        px: t,
                        py: r,
                        pz: i
                    } = this, {
                        px: o,
                        py: s,
                        pz: a
                    } = e, l = n.eql(n.mul(t, a), n.mul(o, i)), u = n.eql(n.mul(r, a), n.mul(s, i));
                    return l && u
                }
                negate() {
                    return new d(this.px, n.neg(this.py), this.pz)
                }
                double() {
                    const {
                        a: e,
                        b: r
                    } = t, i = n.mul(r, rl), {
                        px: o,
                        py: s,
                        pz: a
                    } = this;
                    let l = n.ZERO,
                        u = n.ZERO,
                        c = n.ZERO,
                        h = n.mul(o, o),
                        f = n.mul(s, s),
                        p = n.mul(a, a),
                        m = n.mul(o, s);
                    return m = n.add(m, m), c = n.mul(o, a), c = n.add(c, c), l = n.mul(e, c), u = n.mul(i, p), u = n.add(l, u), l = n.sub(f, u), u = n.add(f, u), u = n.mul(l, u), l = n.mul(m, l), c = n.mul(i, c), p = n.mul(e, p), m = n.sub(h, p), m = n.mul(e, m), m = n.add(m, c), c = n.add(h, h), h = n.add(c, h), h = n.add(h, p), h = n.mul(h, m), u = n.add(u, h), p = n.mul(s, a), p = n.add(p, p), h = n.mul(p, m), l = n.sub(l, h), c = n.mul(p, f), c = n.add(c, c), c = n.add(c, c), new d(l, u, c)
                }
                add(e) {
                    c(e);
                    const {
                        px: r,
                        py: i,
                        pz: o
                    } = this, {
                        px: s,
                        py: a,
                        pz: l
                    } = e;
                    let u = n.ZERO,
                        h = n.ZERO,
                        f = n.ZERO;
                    const p = t.a,
                        m = n.mul(t.b, rl);
                    let g = n.mul(r, s),
                        y = n.mul(i, a),
                        v = n.mul(o, l),
                        b = n.add(r, i),
                        w = n.add(s, a);
                    b = n.mul(b, w), w = n.add(g, y), b = n.sub(b, w), w = n.add(r, o);
                    let E = n.add(s, l);
                    return w = n.mul(w, E), E = n.add(g, v), w = n.sub(w, E), E = n.add(i, o), u = n.add(a, l), E = n.mul(E, u), u = n.add(y, v), E = n.sub(E, u), f = n.mul(p, w), u = n.mul(m, v), f = n.add(u, f), u = n.sub(y, f), f = n.add(y, f), h = n.mul(u, f), y = n.add(g, g), y = n.add(y, g), v = n.mul(p, v), w = n.mul(m, w), y = n.add(y, v), v = n.sub(g, v), v = n.mul(p, v), w = n.add(w, v), g = n.mul(y, w), h = n.add(h, g), g = n.mul(E, w), u = n.mul(b, u), u = n.sub(u, g), g = n.mul(b, y), f = n.mul(E, f), f = n.add(f, g), new d(u, h, f)
                }
                subtract(e) {
                    return this.add(e.negate())
                }
                is0() {
                    return this.equals(d.ZERO)
                }
                wNAF(e) {
                    return f.wNAFCached(this, u, e, (e => {
                        const t = n.invertBatch(e.map((e => e.pz)));
                        return e.map(((e, n) => e.toAffine(t[n]))).map(d.fromAffine)
                    }))
                }
                multiplyUnsafe(e) {
                    const r = d.ZERO;
                    if (e === tl) return r;
                    if (a(e), e === nl) return this;
                    const {
                        endo: i
                    } = t;
                    if (!i) return f.unsafeLadder(this, e);
                    let {
                        k1neg: o,
                        k1: s,
                        k2neg: l,
                        k2: u
                    } = i.splitScalar(e), c = r, h = r, p = this;
                    for (; s > tl || u > tl;) s & nl && (c = c.add(p)), u & nl && (h = h.add(p)), p = p.double(), s >>= nl, u >>= nl;
                    return o && (c = c.negate()), l && (h = h.negate()), h = new d(n.mul(h.px, i.beta), h.py, h.pz), c.add(h)
                }
                multiply(e) {
                    a(e);
                    let r, i, o = e;
                    const {
                        endo: s
                    } = t;
                    if (s) {
                        const {
                            k1neg: e,
                            k1: t,
                            k2neg: a,
                            k2: l
                        } = s.splitScalar(o);
                        let {
                            p: u,
                            f: c
                        } = this.wNAF(t), {
                            p: h,
                            f: p
                        } = this.wNAF(l);
                        u = f.constTimeNegate(e, u), h = f.constTimeNegate(a, h), h = new d(n.mul(h.px, s.beta), h.py, h.pz), r = u.add(h), i = c.add(p)
                    } else {
                        const {
                            p: e,
                            f: t
                        } = this.wNAF(o);
                        r = e, i = t
                    }
                    return d.normalizeZ([r, i])[0]
                }
                multiplyAndAddUnsafe(e, t, n) {
                    const r = d.BASE,
                        i = (e, t) => t !== tl && t !== nl && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t),
                        o = i(this, t).add(i(e, n));
                    return o.is0() ? void 0 : o
                }
                toAffine(e) {
                    const {
                        px: t,
                        py: r,
                        pz: i
                    } = this, o = this.is0();
                    null == e && (e = o ? n.ONE : n.inv(i));
                    const s = n.mul(t, e),
                        a = n.mul(r, e),
                        l = n.mul(i, e);
                    if (o) return {
                        x: n.ZERO,
                        y: n.ZERO
                    };
                    if (!n.eql(l, n.ONE)) throw new Error("invZ was invalid");
                    return {
                        x: s,
                        y: a
                    }
                }
                isTorsionFree() {
                    const {
                        h: e,
                        isTorsionFree: n
                    } = t;
                    if (e === nl) return !0;
                    if (n) return n(d, this);
                    throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                }
                clearCofactor() {
                    const {
                        h: e,
                        clearCofactor: n
                    } = t;
                    return e === nl ? this : n ? n(d, this) : this.multiplyUnsafe(t.h)
                }
                toRawBytes() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return this.assertValidity(), r(d, this, e)
                }
                toHex() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return fa(this.toRawBytes(e))
                }
            }
            d.BASE = new d(t.Gx, t.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO);
            const h = t.nBitLength,
                f = function(e, t) {
                    const n = (e, t) => {
                            const n = t.negate();
                            return e ? n : t
                        },
                        r = e => ({
                            windows: Math.ceil(t / e) + 1,
                            windowSize: 2 ** (e - 1)
                        });
                    return {
                        constTimeNegate: n,
                        unsafeLadder(t, n) {
                            let r = e.ZERO,
                                i = t;
                            for (; n > Wa;) n & Ja && (r = r.add(i)), i = i.double(), n >>= Ja;
                            return r
                        },
                        precomputeWindow(e, t) {
                            const {
                                windows: n,
                                windowSize: i
                            } = r(t), o = [];
                            let s = e,
                                a = s;
                            for (let r = 0; r < n; r++) {
                                a = s, o.push(a);
                                for (let e = 1; e < i; e++) a = a.add(s), o.push(a);
                                s = a.double()
                            }
                            return o
                        },
                        wNAF(t, i, o) {
                            const {
                                windows: s,
                                windowSize: a
                            } = r(t);
                            let l = e.ZERO,
                                u = e.BASE;
                            const c = BigInt(2 ** t - 1),
                                d = 2 ** t,
                                h = BigInt(t);
                            for (let e = 0; e < s; e++) {
                                const t = e * a;
                                let r = Number(o & c);
                                o >>= h, r > a && (r -= d, o += Ja);
                                const s = t,
                                    f = t + Math.abs(r) - 1,
                                    p = e % 2 !== 0,
                                    m = r < 0;
                                0 === r ? u = u.add(n(p, i[s])) : l = l.add(n(m, i[f]))
                            }
                            return {
                                p: l,
                                f: u
                            }
                        },
                        wNAFCached(e, t, n, r) {
                            const i = e._WINDOW_SIZE || 1;
                            let o = t.get(e);
                            return o || (o = this.precomputeWindow(e, i), 1 !== i && t.set(e, r(o))), this.wNAF(i, o, n)
                        }
                    }
                }(d, t.endo ? Math.ceil(h / 2) : h);
            return {
                CURVE: t,
                ProjectivePoint: d,
                normPrivateKeyToScalar: l,
                weierstrassEquation: o,
                isWithinCurveOrder: s
            }
        }

        function ol(e) {
            const t = function(e) {
                    const t = Za(e);
                    return Ma(t, {
                        hash: "hash",
                        hmac: "function",
                        randomBytes: "function"
                    }, {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean"
                    }), Object.freeze({
                        lowS: !0,
                        ...t
                    })
                }(e),
                {
                    Fp: n,
                    n: r
                } = t,
                i = n.BYTES + 1,
                o = 2 * n.BYTES + 1;

            function s(e) {
                return ja(e, r)
            }

            function a(e) {
                return za(e, r)
            }
            const {
                ProjectivePoint: l,
                normPrivateKeyToScalar: u,
                weierstrassEquation: c,
                isWithinCurveOrder: d
            } = il({ ...t,
                toBytes(e, t, r) {
                    const i = t.toAffine(),
                        o = n.toBytes(i.x),
                        s = Aa;
                    return r ? s(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o) : s(Uint8Array.from([4]), o, n.toBytes(i.y))
                },
                fromBytes(e) {
                    const t = e.length,
                        r = e[0],
                        s = e.subarray(1);
                    if (t !== i || 2 !== r && 3 !== r) {
                        if (t === o && 4 === r) {
                            return {
                                x: n.fromBytes(s.subarray(0, n.BYTES)),
                                y: n.fromBytes(s.subarray(n.BYTES, 2 * n.BYTES))
                            }
                        }
                        throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)
                    } {
                        const e = va(s);
                        if (!(tl < (a = e) && a < n.ORDER)) throw new Error("Point is not on curve");
                        const t = c(e);
                        let i;
                        try {
                            i = n.sqrt(t)
                        } catch (l) {
                            const e = l instanceof Error ? ": " + l.message : "";
                            throw new Error("Point is not on curve" + e)
                        }
                        return 1 === (1 & r) !== ((i & nl) === nl) && (i = n.neg(i)), {
                            x: e,
                            y: i
                        }
                    }
                    var a
                }
            }), h = e => fa(wa(e, t.nByteLength));

            function f(e) {
                return e > r >> nl
            }
            const p = (e, t, n) => va(e.slice(t, n));
            class m {
                constructor(e, t, n) {
                    this.r = e, this.s = t, this.recovery = n, this.assertValidity()
                }
                static fromCompact(e) {
                    const n = t.nByteLength;
                    return e = xa("compactSignature", e, 2 * n), new m(p(e, 0, n), p(e, n, 2 * n))
                }
                static fromDER(e) {
                    const {
                        r: t,
                        s: n
                    } = el.toSig(xa("DER", e));
                    return new m(t, n)
                }
                assertValidity() {
                    if (!d(this.r)) throw new Error("r must be 0 < r < CURVE.n");
                    if (!d(this.s)) throw new Error("s must be 0 < s < CURVE.n")
                }
                addRecoveryBit(e) {
                    return new m(this.r, this.s, e)
                }
                recoverPublicKey(e) {
                    const {
                        r: r,
                        s: i,
                        recovery: o
                    } = this, u = b(xa("msgHash", e));
                    if (null == o || ![0, 1, 2, 3].includes(o)) throw new Error("recovery id invalid");
                    const c = 2 === o || 3 === o ? r + t.n : r;
                    if (c >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
                    const d = 0 === (1 & o) ? "02" : "03",
                        f = l.fromHex(d + h(c)),
                        p = a(c),
                        m = s(-u * p),
                        g = s(i * p),
                        y = l.BASE.multiplyAndAddUnsafe(f, m, g);
                    if (!y) throw new Error("point at infinify");
                    return y.assertValidity(), y
                }
                hasHighS() {
                    return f(this.s)
                }
                normalizeS() {
                    return this.hasHighS() ? new m(this.r, s(-this.s), this.recovery) : this
                }
                toDERRawBytes() {
                    return ya(this.toDERHex())
                }
                toDERHex() {
                    return el.hexFromSig({
                        r: this.r,
                        s: this.s
                    })
                }
                toCompactRawBytes() {
                    return ya(this.toCompactHex())
                }
                toCompactHex() {
                    return h(this.r) + h(this.s)
                }
            }
            const g = {
                isValidPrivateKey(e) {
                    try {
                        return u(e), !0
                    } catch (t) {
                        return !1
                    }
                },
                normPrivateKeyToScalar: u,
                randomPrivateKey: () => {
                    const e = Qa(t.n);
                    return function(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        const r = e.length,
                            i = $a(t),
                            o = Qa(t);
                        if (r < 16 || r < o || r > 1024) throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);
                        const s = ja(n ? va(e) : ba(e), t - Oa) + Oa;
                        return n ? Ea(s, i) : wa(s, i)
                    }(t.randomBytes(e), t.n)
                },
                precompute() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l.BASE;
                    return t._setWindowSize(e), t.multiply(BigInt(3)), t
                }
            };

            function y(e) {
                const t = ca(e),
                    n = "string" === typeof e,
                    r = (t || n) && e.length;
                return t ? r === i || r === o : n ? r === 2 * i || r === 2 * o : e instanceof l
            }
            const v = t.bits2int || function(e) {
                    const n = va(e),
                        r = 8 * e.length - t.nBitLength;
                    return r > 0 ? n >> BigInt(r) : n
                },
                b = t.bits2int_modN || function(e) {
                    return s(v(e))
                },
                w = Ca(t.nBitLength);

            function E(e) {
                if ("bigint" !== typeof e) throw new Error("bigint expected");
                if (!(tl <= e && e < w)) throw new Error(`bigint expected < 2^${t.nBitLength}`);
                return wa(e, t.nByteLength)
            }

            function x(e, r) {
                let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : A;
                if (["recovered", "canonical"].some((e => e in i))) throw new Error("sign() legacy options not supported");
                const {
                    hash: o,
                    randomBytes: c
                } = t;
                let {
                    lowS: h,
                    prehash: p,
                    extraEntropy: g
                } = i;
                null == h && (h = !0), e = xa("msgHash", e), p && (e = xa("prehashed msgHash", o(e)));
                const y = b(e),
                    w = u(r),
                    x = [E(w), E(y)];
                if (null != g && !1 !== g) {
                    const e = !0 === g ? c(n.BYTES) : g;
                    x.push(xa("extraEntropy", e))
                }
                const k = Aa(...x),
                    C = y;
                return {
                    seed: k,
                    k2sig: function(e) {
                        const t = v(e);
                        if (!d(t)) return;
                        const n = a(t),
                            r = l.BASE.multiply(t).toAffine(),
                            i = s(r.x);
                        if (i === tl) return;
                        const o = s(n * s(C + i * w));
                        if (o === tl) return;
                        let u = (r.x === i ? 0 : 2) | Number(r.y & nl),
                            c = o;
                        return h && f(o) && (c = function(e) {
                            return f(e) ? s(-e) : e
                        }(o), u ^= 1), new m(i, c, u)
                    }
                }
            }
            const A = {
                    lowS: t.lowS,
                    prehash: !1
                },
                k = {
                    lowS: t.lowS,
                    prehash: !1
                };
            return l.BASE._setWindowSize(8), {
                CURVE: t,
                getPublicKey: function(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return l.fromPrivateKey(e).toRawBytes(t)
                },
                getSharedSecret: function(e, t) {
                    let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (y(e)) throw new Error("first arg must be private key");
                    if (!y(t)) throw new Error("second arg must be public key");
                    return l.fromHex(t).multiply(u(e)).toRawBytes(n)
                },
                sign: function(e, n) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : A;
                    const {
                        seed: i,
                        k2sig: o
                    } = x(e, n, r), s = t;
                    return _a(s.hash.outputLen, s.nByteLength, s.hmac)(i, o)
                },
                verify: function(e, n, r) {
                    let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : k;
                    const o = e;
                    if (n = xa("msgHash", n), r = xa("publicKey", r), "strict" in i) throw new Error("options.strict was renamed to lowS");
                    const {
                        lowS: u,
                        prehash: c
                    } = i;
                    let d, h;
                    try {
                        if ("string" === typeof o || ca(o)) try {
                            d = m.fromDER(o)
                        } catch (x) {
                            if (!(x instanceof el.Err)) throw x;
                            d = m.fromCompact(o)
                        } else {
                            if ("object" !== typeof o || "bigint" !== typeof o.r || "bigint" !== typeof o.s) throw new Error("PARSE"); {
                                const {
                                    r: e,
                                    s: t
                                } = o;
                                d = new m(e, t)
                            }
                        }
                        h = l.fromHex(r)
                    } catch (A) {
                        if ("PARSE" === A.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                        return !1
                    }
                    if (u && d.hasHighS()) return !1;
                    c && (n = t.hash(n));
                    const {
                        r: f,
                        s: p
                    } = d, g = b(n), y = a(p), v = s(g * y), w = s(f * y), E = l.BASE.multiplyAndAddUnsafe(h, v, w) ? .toAffine();
                    return !!E && s(E.x) === f
                },
                ProjectivePoint: l,
                Signature: m,
                utils: g
            }
        }

        function sl(e) {
            return {
                hash: e,
                hmac: function(t) {
                    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                    return Ka(e, t, (0, di.Id)(...r))
                },
                randomBytes: di.po
            }
        }
        const al = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
            ll = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
            ul = BigInt(1),
            cl = BigInt(2),
            dl = (e, t) => (e + t / cl) / t;

        function hl(e) {
            const t = al,
                n = BigInt(3),
                r = BigInt(6),
                i = BigInt(11),
                o = BigInt(22),
                s = BigInt(23),
                a = BigInt(44),
                l = BigInt(88),
                u = e * e * e % t,
                c = u * u * e % t,
                d = Ua(c, n, t) * c % t,
                h = Ua(d, n, t) * c % t,
                f = Ua(h, cl, t) * u % t,
                p = Ua(f, i, t) * f % t,
                m = Ua(p, o, t) * p % t,
                g = Ua(m, a, t) * m % t,
                y = Ua(g, l, t) * g % t,
                v = Ua(y, a, t) * m % t,
                b = Ua(v, n, t) * c % t,
                w = Ua(b, s, t) * p % t,
                E = Ua(w, r, t) * u % t,
                x = Ua(E, cl, t);
            if (!fl.eql(fl.sqr(x), e)) throw new Error("Cannot find square root");
            return x
        }
        const fl = function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                if (e <= Ia) throw new Error(`Expected Field ORDER > 0, got ${e}`);
                const {
                    nBitLength: i,
                    nByteLength: o
                } = Ha(e, t);
                if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
                const s = qa(e),
                    a = Object.freeze({
                        ORDER: e,
                        BITS: i,
                        BYTES: o,
                        MASK: Ca(i),
                        ZERO: Ia,
                        ONE: Oa,
                        create: t => ja(t, e),
                        isValid: t => {
                            if ("bigint" !== typeof t) throw new Error("Invalid field element: expected bigint, got " + typeof t);
                            return Ia <= t && t < e
                        },
                        is0: e => e === Ia,
                        isOdd: e => (e & Oa) === Oa,
                        neg: t => ja(-t, e),
                        eql: (e, t) => e === t,
                        sqr: t => ja(t * t, e),
                        add: (t, n) => ja(t + n, e),
                        sub: (t, n) => ja(t - n, e),
                        mul: (t, n) => ja(t * n, e),
                        pow: (e, t) => function(e, t, n) {
                            if (n < Ia) throw new Error("Expected power > 0");
                            if (n === Ia) return e.ONE;
                            if (n === Oa) return t;
                            let r = e.ONE,
                                i = t;
                            for (; n > Ia;) n & Oa && (r = e.mul(r, i)), i = e.sqr(i), n >>= Oa;
                            return r
                        }(a, e, t),
                        div: (t, n) => ja(t * za(n, e), e),
                        sqrN: e => e * e,
                        addN: (e, t) => e + t,
                        subN: (e, t) => e - t,
                        mulN: (e, t) => e * t,
                        inv: t => za(t, e),
                        sqrt: r.sqrt || (e => s(a, e)),
                        invertBatch: e => function(e, t) {
                            const n = new Array(t.length),
                                r = t.reduce(((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r))), e.ONE),
                                i = e.inv(r);
                            return t.reduceRight(((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r))), i), n
                        }(a, e),
                        cmov: (e, t, n) => n ? t : e,
                        toBytes: e => n ? Ea(e, o) : wa(e, o),
                        fromBytes: e => {
                            if (e.length !== o) throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`);
                            return n ? ba(e) : va(e)
                        }
                    });
                return Object.freeze(a)
            }(al, void 0, void 0, {
                sqrt: hl
            }),
            pl = function(e, t) {
                const n = t => ol({ ...e,
                    ...sl(t)
                });
                return Object.freeze({ ...n(t),
                    create: n
                })
            }({
                a: BigInt(0),
                b: BigInt(7),
                Fp: fl,
                n: ll,
                Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                h: BigInt(1),
                lowS: !0,
                endo: {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar: e => {
                        const t = ll,
                            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                            r = -ul * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                            o = n,
                            s = BigInt("0x100000000000000000000000000000000"),
                            a = dl(o * e, t),
                            l = dl(-r * e, t);
                        let u = ja(e - a * n - l * i, t),
                            c = ja(-a * r - l * o, t);
                        const d = u > s,
                            h = c > s;
                        if (d && (u = t - u), h && (c = t - c), u > s || c > s) throw new Error("splitScalar: Endomorphism failed, k=" + e);
                        return {
                            k1neg: d,
                            k1: u,
                            k2neg: h,
                            k2: c
                        }
                    }
                }
            }, bi);
        BigInt(0);
        pl.ProjectivePoint;
        async function ml(e, t) {
            let {
                address: n,
                hash: r,
                signature: i,
                ...o
            } = t;
            const s = (0, wi.q)(i) ? i : "object" === typeof i && "r" in i && "s" in i ? function(e) {
                let {
                    r: t,
                    s: n,
                    v: r,
                    yParity: i
                } = e;
                const o = (() => {
                    if (0 === i || 1 === i) return i;
                    if (r && (27 n === r || 28 n === r || r >= 35 n)) return r % 2 n === 0 n ? 1 : 0;
                    throw new Error("Invalid `v` or `yParity` value")
                })();
                return `0x${new pl.Signature((0,Cr.uU)(t),(0,Cr.uU)(n)).toCompactHex()}${0===o?"1b":"1c"}`
            }(i) : (0, Sr.My)(i);
            try {
                const {
                    data: t
                } = await Gr(e, ds.T1, "call")({
                    data: Or({
                        abi: Jo._,
                        args: [n, r, s],
                        bytecode: aa
                    }),
                    ...o
                });
                return a = t ? ? "0x0", l = "0x1", ka((0, wi.q)(a) ? (0, ai.ZJ)(a) : a, (0, wi.q)(l) ? (0, ai.ZJ)(l) : l)
            } catch (u) {
                if (u instanceof ts.zX) return !1;
                throw u
            }
            var a, l
        }
        async function gl(e, t) {
            let {
                address: n,
                message: r,
                signature: i,
                ...o
            } = t;
            const s = function(e, t) {
                const n = "string" === typeof e ? (0, ai.Af)(e) : e.raw instanceof Uint8Array ? e.raw : (0, ai.ZJ)(e.raw),
                    r = (0, ai.Af)(`${sa}${n.length}`);
                return (0, rs.S)((0, Nr.xW)([r, n]), t)
            }(r);
            return ml(e, {
                address: n,
                hash: s,
                signature: i,
                ...o
            })
        }

        function yl(e) {
            const {
                domain: t = {},
                message: n,
                primaryType: r
            } = e, i = {
                EIP712Domain: qi({
                    domain: t
                }),
                ...e.types
            };
            zi({
                domain: t,
                message: n,
                primaryType: r,
                types: i
            });
            const o = ["0x1901"];
            return t && o.push(function(e) {
                let {
                    domain: t,
                    types: n
                } = e;
                return vl({
                    data: t,
                    primaryType: "EIP712Domain",
                    types: n
                })
            }({
                domain: t,
                types: i
            })), "EIP712Domain" !== r && o.push(vl({
                data: n,
                primaryType: r,
                types: i
            })), (0, rs.S)((0, Nr.xW)(o))
        }

        function vl(e) {
            let {
                data: t,
                primaryType: n,
                types: r
            } = e;
            const i = bl({
                data: t,
                primaryType: n,
                types: r
            });
            return (0, rs.S)(i)
        }

        function bl(e) {
            let {
                data: t,
                primaryType: n,
                types: r
            } = e;
            const i = [{
                    type: "bytes32"
                }],
                o = [wl({
                    primaryType: n,
                    types: r
                })];
            for (const s of r[n]) {
                const [e, n] = xl({
                    types: r,
                    name: s.name,
                    type: s.type,
                    value: t[s.name]
                });
                i.push(e), o.push(n)
            }
            return (0, Mr.h)(i, o)
        }

        function wl(e) {
            let {
                primaryType: t,
                types: n
            } = e;
            const r = (0, Sr.nj)(function(e) {
                let {
                    primaryType: t,
                    types: n
                } = e, r = "";
                const i = El({
                    primaryType: t,
                    types: n
                });
                i.delete(t);
                const o = [t, ...Array.from(i).sort()];
                for (const s of o) r += `${s}(${n[s].map((e=>{let{name:t,type:n}=e;return`
                $ {
                    n
                }
                $ {
                    t
                }
                `})).join(",")})`;
                return r
            }({
                primaryType: t,
                types: n
            }));
            return (0, rs.S)(r)
        }

        function El(e) {
            let {
                primaryType: t,
                types: n
            } = e, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Set;
            const i = t.match(/^\w*/u),
                o = i ? .[0];
            if (r.has(o) || void 0 === n[o]) return r;
            r.add(o);
            for (const s of n[o]) El({
                primaryType: s.type,
                types: n
            }, r);
            return r
        }

        function xl(e) {
            let {
                types: t,
                name: n,
                type: r,
                value: i
            } = e;
            if (void 0 !== t[r]) return [{
                type: "bytes32"
            }, (0, rs.S)(bl({
                data: i,
                primaryType: r,
                types: t
            }))];
            if ("bytes" === r) {
                return i = `0x${(i.length%2?"0":"")+i.slice(2)}`, [{
                    type: "bytes32"
                }, (0, rs.S)(i)]
            }
            if ("string" === r) return [{
                type: "bytes32"
            }, (0, rs.S)((0, Sr.nj)(i))];
            if (r.lastIndexOf("]") === r.length - 1) {
                const e = r.slice(0, r.lastIndexOf("[")),
                    o = i.map((r => xl({
                        name: n,
                        type: e,
                        types: t,
                        value: r
                    })));
                return [{
                    type: "bytes32"
                }, (0, rs.S)((0, Mr.h)(o.map((e => {
                    let [t] = e;
                    return t
                })), o.map((e => {
                    let [, t] = e;
                    return t
                }))))]
            }
            return [{
                type: r
            }, i]
        }
        const Al = new Map,
            kl = new Map;
        let Cl = 0;

        function Pl(e, t, n) {
            const r = ++Cl,
                i = () => Al.get(e) || [],
                o = () => {
                    const t = kl.get(e);
                    1 === i().length && t && t(), (() => {
                        const t = i();
                        Al.set(e, t.filter((e => e.id !== r)))
                    })()
                },
                s = i();
            if (Al.set(e, [...s, {
                    id: r,
                    fns: t
                }]), s && s.length > 0) return o;
            const a = {};
            for (const u in t) a[u] = function() {
                const e = i();
                if (0 !== e.length) {
                    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                    for (const t of e) t.fns[u] ? .(...n)
                }
            };
            const l = n(a);
            return "function" === typeof l && kl.set(e, l), o
        }

        function Sl(e, t) {
            let {
                emitOnBegin: n,
                initialWaitTime: r,
                interval: i
            } = t, o = !0;
            const s = () => o = !1;
            return (async () => {
                let t;
                n && (t = await e({
                    unpoll: s
                }));
                const a = await (r ? .(t)) ? ? i;
                await bo(a);
                const l = async () => {
                    o && (await e({
                        unpoll: s
                    }), await bo(i), l())
                };
                l()
            })(), s
        }

        function _l(e, t) {
            let {
                emitOnBegin: n = !1,
                emitMissed: r = !1,
                onBlockNumber: i,
                onError: o,
                poll: s,
                pollingInterval: a = e.pollingInterval
            } = t;
            let l;
            return ("undefined" !== typeof s ? s : "webSocket" !== e.transport.type && ("fallback" !== e.transport.type || "webSocket" !== e.transport.transports[0].config.type)) ? Pl((0, Bi.A)(["watchBlockNumber", e.uid, n, r, a]), {
                onBlockNumber: i,
                onError: o
            }, (t => Sl((async () => {
                try {
                    const n = await Gr(e, qs, "getBlockNumber")({
                        cacheTime: 0
                    });
                    if (l) {
                        if (n === l) return;
                        if (n - l > 1 && r)
                            for (let e = l + 1 n; e < n; e++) t.onBlockNumber(e, l), l = e
                    }(!l || n > l) && (t.onBlockNumber(n, l), l = n)
                } catch (n) {
                    t.onError ? .(n)
                }
            }), {
                emitOnBegin: n,
                interval: a
            }))) : Pl((0, Bi.A)(["watchBlockNumber", e.uid, n, r]), {
                onBlockNumber: i,
                onError: o
            }, (t => {
                let n = !0,
                    r = () => n = !1;
                return (async () => {
                    try {
                        const i = (() => {
                                if ("fallback" === e.transport.type) {
                                    const t = e.transport.transports.find((e => "webSocket" === e.config.type));
                                    return t ? t.value : e.transport
                                }
                                return e.transport
                            })(),
                            {
                                unsubscribe: o
                            } = await i.subscribe({
                                params: ["newHeads"],
                                onData(e) {
                                    if (!n) return;
                                    const r = (0, Cr.uU)(e.result ? .number);
                                    t.onBlockNumber(r, l), l = r
                                },
                                onError(e) {
                                    t.onError ? .(e)
                                }
                            });
                        r = o, n || r()
                    } catch (i) {
                        o ? .(i)
                    }
                })(), () => r()
            }))
        }

        function Nl(e) {
            return {
                call: t => (0, ds.T1)(e, t),
                createBlockFilter: () => async function(e) {
                    const t = Ss(e, {
                            method: "eth_newBlockFilter"
                        }),
                        n = await e.request({
                            method: "eth_newBlockFilter"
                        });
                    return {
                        id: n,
                        request: t(n),
                        type: "block"
                    }
                }(e),
                createContractEventFilter: t => Ls(e, t),
                createEventFilter: t => Bs(e, t),
                createPendingTransactionFilter: () => Fs(e),
                estimateContractGas: t => async function(e, t) {
                    const {
                        abi: n,
                        address: r,
                        args: i,
                        functionName: o,
                        ...s
                    } = t, a = (0, Gi.p)({
                        abi: n,
                        args: i,
                        functionName: o
                    });
                    try {
                        return await Gr(e, oi, "estimateGas")({
                            data: a,
                            to: r,
                            ...s
                        })
                    } catch (l) {
                        const e = s.account ? (0, Tr.J)(s.account) : void 0;
                        throw cs(l, {
                            abi: n,
                            address: r,
                            args: i,
                            docsPath: "/docs/contract/estimateContractGas",
                            functionName: o,
                            sender: e ? .address
                        })
                    }
                }(e, t),
                estimateGas: t => oi(e, t),
                getBalance: t => async function(e, t) {
                    let {
                        address: n,
                        blockNumber: r,
                        blockTag: i = "latest"
                    } = t;
                    const o = r ? (0, Sr.cK)(r) : void 0,
                        s = await e.request({
                            method: "eth_getBalance",
                            params: [n, o || i]
                        });
                    return BigInt(s)
                }(e, t),
                getBlobBaseFee: () => async function(e) {
                    const t = await e.request({
                        method: "eth_blobBaseFee"
                    });
                    return BigInt(t)
                }(e),
                getBlock: t => Xr(e, t),
                getBlockNumber: t => qs(e, t),
                getBlockTransactionCount: t => async function(e) {
                    let {
                        blockHash: t,
                        blockNumber: n,
                        blockTag: r = "latest"
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const i = void 0 !== n ? (0, Sr.cK)(n) : void 0;
                    let o;
                    return o = t ? await e.request({
                        method: "eth_getBlockTransactionCountByHash",
                        params: [t]
                    }) : await e.request({
                        method: "eth_getBlockTransactionCountByNumber",
                        params: [i || r]
                    }), (0, Cr.ME)(o)
                }(e, t),
                getBytecode: t => async function(e, t) {
                    let {
                        address: n,
                        blockNumber: r,
                        blockTag: i = "latest"
                    } = t;
                    const o = void 0 !== r ? (0, Sr.cK)(r) : void 0,
                        s = await e.request({
                            method: "eth_getCode",
                            params: [n, o || i]
                        });
                    if ("0x" !== s) return s
                }(e, t),
                getChainId: () => Pr(e),
                getContractEvents: t => Zs(e, t),
                getEnsAddress: t => async function(e, t) {
                    let {
                        blockNumber: n,
                        blockTag: r,
                        coinType: i,
                        name: o,
                        gatewayUrls: s,
                        strict: a,
                        universalResolverAddress: l
                    } = t, u = l;
                    if (!u) {
                        if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                        u = (0, Yo.M)({
                            blockNumber: n,
                            chain: e.chain,
                            contract: "ensUniversalResolver"
                        })
                    }
                    try {
                        const t = (0, Gi.p)({
                                abi: Jo.Rm,
                                functionName: "addr",
                                ...null != i ? {
                                    args: [os(o), BigInt(i)]
                                } : {
                                    args: [os(o)]
                                }
                            }),
                            a = {
                                address: u,
                                abi: Jo.Ag,
                                functionName: "resolve",
                                args: [(0, Sr.nj)(ls(o)), t],
                                blockNumber: n,
                                blockTag: r
                            },
                            l = Gr(e, hs, "readContract"),
                            c = s ? await l({ ...a,
                                args: [...a.args, s]
                            }) : await l(a);
                        if ("0x" === c[0]) return null;
                        const d = (0, Zo.e)({
                            abi: Jo.Rm,
                            args: null != i ? [os(o), BigInt(i)] : void 0,
                            functionName: "addr",
                            data: c[0]
                        });
                        return "0x" === d || "0x00" === (0, Xo.B)(d) ? null : d
                    } catch (c) {
                        if (a) throw c;
                        if (ns(c, "resolve")) return null;
                        throw c
                    }
                }(e, t),
                getEnsAvatar: t => async function(e, t) {
                    let {
                        blockNumber: n,
                        blockTag: r,
                        assetGatewayUrls: i,
                        name: o,
                        gatewayUrls: s,
                        strict: a,
                        universalResolverAddress: l
                    } = t;
                    const u = await Gr(e, Ps, "getEnsText")({
                        blockNumber: n,
                        blockTag: r,
                        key: "avatar",
                        name: o,
                        universalResolverAddress: l,
                        gatewayUrls: s,
                        strict: a
                    });
                    if (!u) return null;
                    try {
                        return await Cs(e, {
                            record: u,
                            gatewayUrls: i
                        })
                    } catch {
                        return null
                    }
                }(e, t),
                getEnsName: t => async function(e, t) {
                    let {
                        address: n,
                        blockNumber: r,
                        blockTag: i,
                        gatewayUrls: o,
                        strict: s,
                        universalResolverAddress: a
                    } = t, l = a;
                    if (!l) {
                        if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                        l = (0, Yo.M)({
                            blockNumber: r,
                            chain: e.chain,
                            contract: "ensUniversalResolver"
                        })
                    }
                    const u = `${n.toLowerCase().substring(2)}.addr.reverse`;
                    try {
                        const t = {
                                address: l,
                                abi: Jo.oX,
                                functionName: "reverse",
                                args: [(0, Sr.nj)(ls(u))],
                                blockNumber: r,
                                blockTag: i
                            },
                            s = Gr(e, hs, "readContract"),
                            [a, c] = o ? await s({ ...t,
                                args: [...t.args, o]
                            }) : await s(t);
                        return n.toLowerCase() !== c.toLowerCase() ? null : a
                    } catch (c) {
                        if (s) throw c;
                        if (ns(c, "reverse")) return null;
                        throw c
                    }
                }(e, t),
                getEnsResolver: t => async function(e, t) {
                    let {
                        blockNumber: n,
                        blockTag: r,
                        name: i,
                        universalResolverAddress: o
                    } = t, s = o;
                    if (!s) {
                        if (!e.chain) throw new Error("client chain not configured. universalResolverAddress is required.");
                        s = (0, Yo.M)({
                            blockNumber: n,
                            chain: e.chain,
                            contract: "ensUniversalResolver"
                        })
                    }
                    const [a] = await Gr(e, hs, "readContract")({
                        address: s,
                        abi: [{
                            inputs: [{
                                type: "bytes"
                            }],
                            name: "findResolver",
                            outputs: [{
                                type: "address"
                            }, {
                                type: "bytes32"
                            }],
                            stateMutability: "view",
                            type: "function"
                        }],
                        functionName: "findResolver",
                        args: [(0, Sr.nj)(ls(i))],
                        blockNumber: n,
                        blockTag: r
                    });
                    return a
                }(e, t),
                getEnsText: t => Ps(e, t),
                getFeeHistory: t => Ys(e, t),
                estimateFeesPerGas: t => async function(e, t) {
                    return ni(e, t)
                }(e, t),
                getFilterChanges: e => Xs(0, e),
                getFilterLogs: e => async function(e, t) {
                    let {
                        filter: n
                    } = t;
                    const r = n.strict ? ? !1,
                        i = (await n.request({
                            method: "eth_getFilterLogs",
                            params: [n.id]
                        })).map((e => Ws(e)));
                    return n.abi ? Ks({
                        abi: n.abi,
                        logs: i,
                        strict: r
                    }) : i
                }(0, e),
                getGasPrice: () => ei(e),
                getLogs: t => Js(e, t),
                getProof: t => ea(e, t),
                estimateMaxPriorityFeePerGas: t => async function(e, t) {
                    return ti(e, t)
                }(e, t),
                getStorageAt: t => async function(e, t) {
                    let {
                        address: n,
                        blockNumber: r,
                        blockTag: i = "latest",
                        slot: o
                    } = t;
                    const s = void 0 !== r ? (0, Sr.cK)(r) : void 0;
                    return await e.request({
                        method: "eth_getStorageAt",
                        params: [n, o, s || i]
                    })
                }(e, t),
                getTransaction: t => ta(e, t),
                getTransactionConfirmations: t => async function(e, t) {
                    let {
                        hash: n,
                        transactionReceipt: r
                    } = t;
                    const [i, o] = await Promise.all([Gr(e, qs, "getBlockNumber")({}), n ? Gr(e, ta, "getBlockNumber")({
                        hash: n
                    }) : void 0]), s = r ? .blockNumber || o ? .blockNumber;
                    return s ? i - s + 1 n : 0 n
                }(e, t),
                getTransactionCount: t => si(e, t),
                getTransactionReceipt: t => ia(e, t),
                multicall: t => async function(e, t) {
                    const {
                        allowFailure: n = !0,
                        batchSize: r,
                        blockNumber: i,
                        blockTag: o,
                        multicallAddress: s,
                        stateOverride: a
                    } = t, l = t.contracts, u = r ? ? ("object" === typeof e.batch ? .multicall && e.batch.multicall.batchSize || 1024);
                    let c = s;
                    if (!c) {
                        if (!e.chain) throw new Error("client chain not configured. multicallAddress is required.");
                        c = (0, Yo.M)({
                            blockNumber: i,
                            chain: e.chain,
                            contract: "multicall3"
                        })
                    }
                    const d = [
                        []
                    ];
                    let h = 0,
                        f = 0;
                    for (let y = 0; y < l.length; y++) {
                        const {
                            abi: e,
                            address: t,
                            args: r,
                            functionName: i
                        } = l[y];
                        try {
                            const n = (0, Gi.p)({
                                abi: e,
                                args: r,
                                functionName: i
                            });
                            f += (n.length - 2) / 2, u > 0 && f > u && d[h].length > 0 && (h++, f = (n.length - 2) / 2, d[h] = []), d[h] = [...d[h], {
                                allowFailure: !0,
                                callData: n,
                                target: t
                            }]
                        } catch (g) {
                            const o = cs(g, {
                                abi: e,
                                address: t,
                                args: r,
                                docsPath: "/docs/contract/multicall",
                                functionName: i
                            });
                            if (!n) throw o;
                            d[h] = [...d[h], {
                                allowFailure: !0,
                                callData: "0x",
                                target: t
                            }]
                        }
                    }
                    const p = await Promise.allSettled(d.map((t => Gr(e, hs, "readContract")({
                            abi: Jo.v2,
                            address: c,
                            args: [t],
                            blockNumber: i,
                            blockTag: o,
                            functionName: "aggregate3",
                            stateOverride: a
                        })))),
                        m = [];
                    for (let y = 0; y < p.length; y++) {
                        const e = p[y];
                        if ("rejected" === e.status) {
                            if (!n) throw e.reason;
                            for (let t = 0; t < d[y].length; t++) m.push({
                                status: "failure",
                                error: e.reason,
                                result: void 0
                            });
                            continue
                        }
                        const t = e.value;
                        for (let r = 0; r < t.length; r++) {
                            const {
                                returnData: e,
                                success: i
                            } = t[r], {
                                callData: o
                            } = d[y][r], {
                                abi: s,
                                address: a,
                                functionName: u,
                                args: c
                            } = l[m.length];
                            try {
                                if ("0x" === o) throw new _r.O;
                                if (!i) throw new ts.$S({
                                    data: e
                                });
                                const t = (0, Zo.e)({
                                    abi: s,
                                    args: c,
                                    data: e,
                                    functionName: u
                                });
                                m.push(n ? {
                                    result: t,
                                    status: "success"
                                } : t)
                            } catch (g) {
                                const e = cs(g, {
                                    abi: s,
                                    address: a,
                                    args: c,
                                    docsPath: "/docs/contract/multicall",
                                    functionName: u
                                });
                                if (!n) throw e;
                                m.push({
                                    error: e,
                                    result: void 0,
                                    status: "failure"
                                })
                            }
                        }
                    }
                    if (m.length !== l.length) throw new Rr.C("multicall results mismatch");
                    return m
                }(e, t),
                prepareTransactionRequest: t => Oi(e, t),
                readContract: t => hs(e, t),
                sendRawTransaction: t => Ti(e, t),
                simulateContract: t => async function(e, t) {
                    const {
                        abi: n,
                        address: r,
                        args: i,
                        dataSuffix: o,
                        functionName: s,
                        ...a
                    } = t, l = a.account ? (0, Tr.J)(a.account) : e.account, u = (0, Gi.p)({
                        abi: n,
                        args: i,
                        functionName: s
                    });
                    try {
                        const {
                            data: c
                        } = await Gr(e, ds.T1, "call")({
                            batch: !1,
                            data: `${u}${o?o.replace("0x",""):""}`,
                            to: r,
                            ...a,
                            account: l
                        });
                        return {
                            result: (0, Zo.e)({
                                abi: n,
                                args: i,
                                functionName: s,
                                data: c || "0x"
                            }),
                            request: {
                                abi: n.filter((e => "name" in e && e.name === t.functionName)),
                                address: r,
                                args: i,
                                dataSuffix: o,
                                functionName: s,
                                ...a,
                                account: l
                            }
                        }
                    } catch (c) {
                        throw cs(c, {
                            abi: n,
                            address: r,
                            args: i,
                            docsPath: "/docs/contract/simulateContract",
                            functionName: s,
                            sender: l ? .address
                        })
                    }
                }(e, t),
                verifyMessage: t => gl(e, t),
                verifyTypedData: t => async function(e, t) {
                    const {
                        address: n,
                        signature: r,
                        message: i,
                        primaryType: o,
                        types: s,
                        domain: a,
                        ...l
                    } = t;
                    return ml(e, {
                        address: n,
                        hash: yl({
                            message: i,
                            primaryType: o,
                            types: s,
                            domain: a
                        }),
                        signature: r,
                        ...l
                    })
                }(e, t),
                uninstallFilter: e => oa(0, e),
                waitForTransactionReceipt: t => async function(e, t) {
                    let {
                        confirmations: n = 1,
                        hash: r,
                        onReplaced: i,
                        pollingInterval: o = e.pollingInterval,
                        retryCount: s = 6,
                        retryDelay: a = e => {
                            let {
                                count: t
                            } = e;
                            return 200 * (1 << t)
                        },
                        timeout: l
                    } = t;
                    const u = (0, Bi.A)(["waitForTransactionReceipt", e.uid, r]);
                    let c, d, h, f = !1;
                    return new Promise(((t, p) => {
                        l && setTimeout((() => p(new Dr.WA({
                            hash: r
                        }))), l);
                        const m = Pl(u, {
                            onReplaced: i,
                            resolve: t,
                            reject: p
                        }, (t => {
                            const i = Gr(e, _l, "watchBlockNumber")({
                                emitMissed: !0,
                                emitOnBegin: !0,
                                poll: !0,
                                pollingInterval: o,
                                async onBlockNumber(o) {
                                    if (f) return;
                                    let l = o;
                                    const u = e => {
                                        i(), e(), m()
                                    };
                                    try {
                                        if (h) {
                                            if (n > 1 && (!h.blockNumber || l - h.blockNumber + 1 n < n)) return;
                                            return void u((() => t.resolve(h)))
                                        }
                                        if (c || (f = !0, await wo((async () => {
                                                c = await Gr(e, ta, "getTransaction")({
                                                    hash: r
                                                }), c.blockNumber && (l = c.blockNumber)
                                            }), {
                                                delay: a,
                                                retryCount: s
                                            }), f = !1), h = await Gr(e, ia, "getTransactionReceipt")({
                                                hash: r
                                            }), n > 1 && (!h.blockNumber || l - h.blockNumber + 1 n < n)) return;
                                        u((() => t.resolve(h)))
                                    } catch (p) {
                                        if (p instanceof Dr.Kz || p instanceof Dr.Kc) {
                                            if (!c) return void(f = !1);
                                            try {
                                                d = c, f = !0;
                                                const r = await wo((() => Gr(e, Xr, "getBlock")({
                                                    blockNumber: l,
                                                    includeTransactions: !0
                                                })), {
                                                    delay: a,
                                                    retryCount: s,
                                                    shouldRetry: e => {
                                                        let {
                                                            error: t
                                                        } = e;
                                                        return t instanceof Wr
                                                    }
                                                });
                                                f = !1;
                                                const i = r.transactions.find((e => {
                                                    let {
                                                        from: t,
                                                        nonce: n
                                                    } = e;
                                                    return t === d.from && n === d.nonce
                                                }));
                                                if (!i) return;
                                                if (h = await Gr(e, ia, "getTransactionReceipt")({
                                                        hash: i.hash
                                                    }), n > 1 && (!h.blockNumber || l - h.blockNumber + 1 n < n)) return;
                                                let o = "replaced";
                                                i.to === d.to && i.value === d.value ? o = "repriced" : i.from === i.to && 0 n === i.value && (o = "cancelled"), u((() => {
                                                    t.onReplaced ? .({
                                                        reason: o,
                                                        replacedTransaction: d,
                                                        transaction: i,
                                                        transactionReceipt: h
                                                    }), t.resolve(h)
                                                }))
                                            } catch (g) {
                                                u((() => t.reject(g)))
                                            }
                                        } else u((() => t.reject(p)))
                                    }
                                }
                            })
                        }))
                    }))
                }(e, t),
                watchBlocks: t => function(e, t) {
                    let {
                        blockTag: n = "latest",
                        emitMissed: r = !1,
                        emitOnBegin: i = !1,
                        onBlock: o,
                        onError: s,
                        includeTransactions: a,
                        poll: l,
                        pollingInterval: u = e.pollingInterval
                    } = t;
                    const c = "undefined" !== typeof l ? l : "webSocket" !== e.transport.type && ("fallback" !== e.transport.type || "webSocket" !== e.transport.transports[0].config.type),
                        d = a ? ? !1;
                    let h;
                    return c ? Pl((0, Bi.A)(["watchBlocks", e.uid, n, r, i, d, u]), {
                        onBlock: o,
                        onError: s
                    }, (t => Sl((async () => {
                        try {
                            const i = await Gr(e, Xr, "getBlock")({
                                blockTag: n,
                                includeTransactions: d
                            });
                            if (i.number && h ? .number) {
                                if (i.number === h.number) return;
                                if (i.number - h.number > 1 && r)
                                    for (let n = h ? .number + 1 n; n < i.number; n++) {
                                        const r = await Gr(e, Xr, "getBlock")({
                                            blockNumber: n,
                                            includeTransactions: d
                                        });
                                        t.onBlock(r, h), h = r
                                    }
                            }(!h ? .number || "pending" === n && !i ? .number || i.number && i.number > h.number) && (t.onBlock(i, h), h = i)
                        } catch (i) {
                            t.onError ? .(i)
                        }
                    }), {
                        emitOnBegin: i,
                        interval: u
                    }))) : (() => {
                        let t = !0,
                            n = () => t = !1;
                        return (async () => {
                            try {
                                const r = (() => {
                                        if ("fallback" === e.transport.type) {
                                            const t = e.transport.transports.find((e => "webSocket" === e.config.type));
                                            return t ? t.value : e.transport
                                        }
                                        return e.transport
                                    })(),
                                    {
                                        unsubscribe: i
                                    } = await r.subscribe({
                                        params: ["newHeads"],
                                        onData(n) {
                                            if (!t) return;
                                            const r = (e.chain ? .formatters ? .block ? .format || Yr)(n.result);
                                            o(r, h), h = r
                                        },
                                        onError(e) {
                                            s ? .(e)
                                        }
                                    });
                                n = i, t || n()
                            } catch (r) {
                                s ? .(r)
                            }
                        })(), () => n()
                    })()
                }(e, t),
                watchBlockNumber: t => _l(e, t),
                watchContractEvent: t => function(e, t) {
                    const {
                        abi: n,
                        address: r,
                        args: i,
                        batch: o = !0,
                        eventName: s,
                        fromBlock: a,
                        onError: l,
                        onLogs: u,
                        poll: c,
                        pollingInterval: d = e.pollingInterval,
                        strict: h
                    } = t;
                    return ("undefined" !== typeof c ? c : "bigint" === typeof a || "webSocket" !== e.transport.type && ("fallback" !== e.transport.type || "webSocket" !== e.transport.transports[0].config.type)) ? (() => {
                        const t = h ? ? !1;
                        return Pl((0, Bi.A)(["watchContractEvent", r, i, o, e.uid, s, d, t, a]), {
                            onLogs: u,
                            onError: l
                        }, (l => {
                            let u, c;
                            void 0 !== a && (u = a - 1 n);
                            let h = !1;
                            const f = Sl((async () => {
                                if (h) try {
                                    let a;
                                    if (c) a = await Gr(e, Xs, "getFilterChanges")({
                                        filter: c
                                    });
                                    else {
                                        const o = await Gr(e, qs, "getBlockNumber")({});
                                        a = u && u !== o ? await Gr(e, Zs, "getContractEvents")({
                                            abi: n,
                                            address: r,
                                            args: i,
                                            eventName: s,
                                            fromBlock: u + 1 n,
                                            toBlock: o,
                                            strict: t
                                        }) : [], u = o
                                    }
                                    if (0 === a.length) return;
                                    if (o) l.onLogs(a);
                                    else
                                        for (const e of a) l.onLogs([e])
                                } catch (d) {
                                    c && d instanceof io && (h = !1), l.onError ? .(d)
                                } else {
                                    try {
                                        c = await Gr(e, Ls, "createContractEventFilter")({
                                            abi: n,
                                            address: r,
                                            args: i,
                                            eventName: s,
                                            strict: t,
                                            fromBlock: a
                                        })
                                    } catch {}
                                    h = !0
                                }
                            }), {
                                emitOnBegin: !0,
                                interval: d
                            });
                            return async () => {
                                c && await Gr(e, oa, "uninstallFilter")({
                                    filter: c
                                }), f()
                            }
                        }))
                    })() : (() => {
                        const t = h ? ? !1,
                            a = (0, Bi.A)(["watchContractEvent", r, i, o, e.uid, s, d, t]);
                        let c = !0,
                            f = () => c = !1;
                        return Pl(a, {
                            onLogs: u,
                            onError: l
                        }, (t => ((async () => {
                            try {
                                const o = (() => {
                                        if ("fallback" === e.transport.type) {
                                            const t = e.transport.transports.find((e => "webSocket" === e.config.type));
                                            return t ? t.value : e.transport
                                        }
                                        return e.transport
                                    })(),
                                    a = s ? Ts({
                                        abi: n,
                                        eventName: s,
                                        args: i
                                    }) : [],
                                    {
                                        unsubscribe: l
                                    } = await o.subscribe({
                                        params: ["logs", {
                                            address: r,
                                            topics: a
                                        }],
                                        onData(e) {
                                            if (!c) return;
                                            const r = e.result;
                                            try {
                                                const {
                                                    eventName: e,
                                                    args: i
                                                } = Qs({
                                                    abi: n,
                                                    data: r.data,
                                                    topics: r.topics,
                                                    strict: h
                                                }), o = Ws(r, {
                                                    args: i,
                                                    eventName: e
                                                });
                                                t.onLogs([o])
                                            } catch (i) {
                                                let e, n;
                                                if (i instanceof _r.fo || i instanceof _r.l3) {
                                                    if (h) return;
                                                    e = i.abiItem.name, n = i.abiItem.inputs ? .some((e => !("name" in e && e.name)))
                                                }
                                                const o = Ws(r, {
                                                    args: n ? [] : {},
                                                    eventName: e
                                                });
                                                t.onLogs([o])
                                            }
                                        },
                                        onError(e) {
                                            t.onError ? .(e)
                                        }
                                    });
                                f = l, c || f()
                            } catch (o) {
                                l ? .(o)
                            }
                        })(), () => f())))
                    })()
                }(e, t),
                watchEvent: t => function(e, t) {
                    let {
                        address: n,
                        args: r,
                        batch: i = !0,
                        event: o,
                        events: s,
                        fromBlock: a,
                        onError: l,
                        onLogs: u,
                        poll: c,
                        pollingInterval: d = e.pollingInterval,
                        strict: h
                    } = t;
                    const f = "undefined" !== typeof c ? c : "bigint" === typeof a || "webSocket" !== e.transport.type && ("fallback" !== e.transport.type || "webSocket" !== e.transport.transports[0].config.type),
                        p = h ? ? !1;
                    return f ? Pl((0, Bi.A)(["watchEvent", n, r, i, e.uid, o, d, a]), {
                        onLogs: u,
                        onError: l
                    }, (t => {
                        let l, u;
                        void 0 !== a && (l = a - 1 n);
                        let c = !1;
                        const h = Sl((async () => {
                            if (c) try {
                                let a;
                                if (u) a = await Gr(e, Xs, "getFilterChanges")({
                                    filter: u
                                });
                                else {
                                    const t = await Gr(e, qs, "getBlockNumber")({});
                                    a = l && l !== t ? await Gr(e, Js, "getLogs")({
                                        address: n,
                                        args: r,
                                        event: o,
                                        events: s,
                                        fromBlock: l + 1 n,
                                        toBlock: t
                                    }) : [], l = t
                                }
                                if (0 === a.length) return;
                                if (i) t.onLogs(a);
                                else
                                    for (const e of a) t.onLogs([e])
                            } catch (d) {
                                u && d instanceof io && (c = !1), t.onError ? .(d)
                            } else {
                                try {
                                    u = await Gr(e, Bs, "createEventFilter")({
                                        address: n,
                                        args: r,
                                        event: o,
                                        events: s,
                                        strict: p,
                                        fromBlock: a
                                    })
                                } catch {}
                                c = !0
                            }
                        }), {
                            emitOnBegin: !0,
                            interval: d
                        });
                        return async () => {
                            u && await Gr(e, oa, "uninstallFilter")({
                                filter: u
                            }), h()
                        }
                    })) : (() => {
                        let t = !0,
                            i = () => t = !1;
                        return (async () => {
                            try {
                                const a = (() => {
                                        if ("fallback" === e.transport.type) {
                                            const t = e.transport.transports.find((e => "webSocket" === e.config.type));
                                            return t ? t.value : e.transport
                                        }
                                        return e.transport
                                    })(),
                                    c = s ? ? (o ? [o] : void 0);
                                let d = [];
                                c && (d = [c.flatMap((e => Ts({
                                    abi: [e],
                                    eventName: e.name,
                                    args: r
                                })))], o && (d = d[0]));
                                const {
                                    unsubscribe: f
                                } = await a.subscribe({
                                    params: ["logs", {
                                        address: n,
                                        topics: d
                                    }],
                                    onData(e) {
                                        if (!t) return;
                                        const n = e.result;
                                        try {
                                            const {
                                                eventName: e,
                                                args: t
                                            } = Qs({
                                                abi: c ? ? [],
                                                data: n.data,
                                                topics: n.topics,
                                                strict: p
                                            }), r = Ws(n, {
                                                args: t,
                                                eventName: e
                                            });
                                            u([r])
                                        } catch (r) {
                                            let e, t;
                                            if (r instanceof _r.fo || r instanceof _r.l3) {
                                                if (h) return;
                                                e = r.abiItem.name, t = r.abiItem.inputs ? .some((e => !("name" in e && e.name)))
                                            }
                                            const i = Ws(n, {
                                                args: t ? [] : {},
                                                eventName: e
                                            });
                                            u([i])
                                        }
                                    },
                                    onError(e) {
                                        l ? .(e)
                                    }
                                });
                                i = f, t || i()
                            } catch (a) {
                                l ? .(a)
                            }
                        })(), () => i()
                    })()
                }(e, t),
                watchPendingTransactions: t => function(e, t) {
                    let {
                        batch: n = !0,
                        onError: r,
                        onTransactions: i,
                        poll: o,
                        pollingInterval: s = e.pollingInterval
                    } = t;
                    return ("undefined" !== typeof o ? o : "webSocket" !== e.transport.type) ? Pl((0, Bi.A)(["watchPendingTransactions", e.uid, n, s]), {
                        onTransactions: i,
                        onError: r
                    }, (t => {
                        let r;
                        const i = Sl((async () => {
                            try {
                                if (!r) try {
                                    return void(r = await Gr(e, Fs, "createPendingTransactionFilter")({}))
                                } catch (o) {
                                    throw i(), o
                                }
                                const s = await Gr(e, Xs, "getFilterChanges")({
                                    filter: r
                                });
                                if (0 === s.length) return;
                                if (n) t.onTransactions(s);
                                else
                                    for (const e of s) t.onTransactions([e])
                            } catch (o) {
                                t.onError ? .(o)
                            }
                        }), {
                            emitOnBegin: !0,
                            interval: s
                        });
                        return async () => {
                            r && await Gr(e, oa, "uninstallFilter")({
                                filter: r
                            }), i()
                        }
                    })) : (() => {
                        let t = !0,
                            n = () => t = !1;
                        return (async () => {
                            try {
                                const {
                                    unsubscribe: o
                                } = await e.transport.subscribe({
                                    params: ["newPendingTransactions"],
                                    onData(e) {
                                        if (!t) return;
                                        const n = e.result;
                                        i([n])
                                    },
                                    onError(e) {
                                        r ? .(e)
                                    }
                                });
                                n = o, t || n()
                            } catch (o) {
                                r ? .(o)
                            }
                        })(), () => n()
                    })()
                }(e, t)
            }
        }

        function Ml(e) {
            const t = function(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                try {
                    t = e.getClient(n)
                } catch {}
                return t
            }(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {});
            return t ? .extend(Nl)
        }

        function Il() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = gt(e);
            return (0, xr.useSyncExternalStoreWithSelector)((e => function(e, t) {
                const {
                    onChange: n
                } = t;
                return e.subscribe((() => Ml(e)), n, {
                    equalityFn: (e, t) => e ? .uid === t ? .uid
                })
            }(t, {
                onChange: e
            })), (() => Ml(t, e)), (() => Ml(t, e)), (e => e), ((e, t) => e ? .uid === t ? .uid))
        }
        let Ol = !1,
            Tl = !1;
        const Rl = {
            debug: 1,
            default: 2,
            info: 2,
            warning: 3,
            error: 4,
            off: 5
        };
        let Ll = Rl.default,
            Bl = null;
        const Fl = function() {
            try {
                const e = [];
                if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t => {
                        try {
                            if ("test" !== "test".normalize(t)) throw new Error("bad normalize")
                        } catch (n) {
                            e.push(t)
                        }
                    })), e.length) throw new Error("missing " + e.join(", "));
                if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
            } catch (e) {
                return e.message
            }
            return null
        }();
        var jl, Dl;
        ! function(e) {
            e.DEBUG = "DEBUG", e.INFO = "INFO", e.WARNING = "WARNING", e.ERROR = "ERROR", e.OFF = "OFF"
        }(jl || (jl = {})),
        function(e) {
            e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.TIMEOUT = "TIMEOUT", e.BUFFER_OVERRUN = "BUFFER_OVERRUN", e.NUMERIC_FAULT = "NUMERIC_FAULT", e.MISSING_NEW = "MISSING_NEW", e.INVALID_ARGUMENT = "INVALID_ARGUMENT", e.MISSING_ARGUMENT = "MISSING_ARGUMENT", e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e.CALL_EXCEPTION = "CALL_EXCEPTION", e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e.NONCE_EXPIRED = "NONCE_EXPIRED", e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e.ACTION_REJECTED = "ACTION_REJECTED"
        }(Dl || (Dl = {}));
        const Ul = "0123456789abcdef";
        class zl {
            constructor(e) {
                Object.defineProperty(this, "version", {
                    enumerable: !0,
                    value: e,
                    writable: !1
                })
            }
            _log(e, t) {
                const n = e.toLowerCase();
                null == Rl[n] && this.throwArgumentError("invalid log level name", "logLevel", e), Ll > Rl[n] || console.log.apply(console, t)
            }
            debug() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                this._log(zl.levels.DEBUG, t)
            }
            info() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                this._log(zl.levels.INFO, t)
            }
            warn() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                this._log(zl.levels.WARNING, t)
            }
            makeError(e, t, n) {
                if (Tl) return this.makeError("censored error", t, {});
                t || (t = zl.errors.UNKNOWN_ERROR), n || (n = {});
                const r = [];
                Object.keys(n).forEach((e => {
                    const t = n[e];
                    try {
                        if (t instanceof Uint8Array) {
                            let n = "";
                            for (let e = 0; e < t.length; e++) n += Ul[t[e] >> 4], n += Ul[15 & t[e]];
                            r.push(e + "=Uint8Array(0x" + n + ")")
                        } else r.push(e + "=" + JSON.stringify(t))
                    } catch (s) {
                        r.push(e + "=" + JSON.stringify(n[e].toString()))
                    }
                })), r.push(`code=${t}`), r.push(`version=${this.version}`);
                const i = e;
                let o = "";
                switch (t) {
                    case Dl.NUMERIC_FAULT:
                        {
                            o = "NUMERIC_FAULT";
                            const t = e;
                            switch (t) {
                                case "overflow":
                                case "underflow":
                                case "division-by-zero":
                                    o += "-" + t;
                                    break;
                                case "negative-power":
                                case "negative-width":
                                    o += "-unsupported";
                                    break;
                                case "unbound-bitwise-result":
                                    o += "-unbound-result"
                            }
                            break
                        }
                    case Dl.CALL_EXCEPTION:
                    case Dl.INSUFFICIENT_FUNDS:
                    case Dl.MISSING_NEW:
                    case Dl.NONCE_EXPIRED:
                    case Dl.REPLACEMENT_UNDERPRICED:
                    case Dl.TRANSACTION_REPLACED:
                    case Dl.UNPREDICTABLE_GAS_LIMIT:
                        o = t
                }
                o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), r.length && (e += " (" + r.join(", ") + ")");
                const s = new Error(e);
                return s.reason = i, s.code = t, Object.keys(n).forEach((function(e) {
                    s[e] = n[e]
                })), s
            }
            throwError(e, t, n) {
                throw this.makeError(e, t, n)
            }
            throwArgumentError(e, t, n) {
                return this.throwError(e, zl.errors.INVALID_ARGUMENT, {
                    argument: t,
                    value: n
                })
            }
            assert(e, t, n, r) {
                e || this.throwError(t, n, r)
            }
            assertArgument(e, t, n, r) {
                e || this.throwArgumentError(t, n, r)
            }
            checkNormalize(e) {
                null == e && (e = "platform missing String.prototype.normalize"), Fl && this.throwError("platform missing String.prototype.normalize", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "String.prototype.normalize",
                    form: Fl
                })
            }
            checkSafeUint53(e, t) {
                "number" === typeof e && (null == t && (t = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(t, zl.errors.NUMERIC_FAULT, {
                    operation: "checkSafeInteger",
                    fault: "out-of-safe-range",
                    value: e
                }), e % 1 && this.throwError(t, zl.errors.NUMERIC_FAULT, {
                    operation: "checkSafeInteger",
                    fault: "non-integer",
                    value: e
                }))
            }
            checkArgumentCount(e, t, n) {
                n = n ? ": " + n : "", e < t && this.throwError("missing argument" + n, zl.errors.MISSING_ARGUMENT, {
                    count: e,
                    expectedCount: t
                }), e > t && this.throwError("too many arguments" + n, zl.errors.UNEXPECTED_ARGUMENT, {
                    count: e,
                    expectedCount: t
                })
            }
            checkNew(e, t) {
                e !== Object && null != e || this.throwError("missing new", zl.errors.MISSING_NEW, {
                    name: t.name
                })
            }
            checkAbstract(e, t) {
                e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", zl.errors.UNSUPPORTED_OPERATION, {
                    name: e.name,
                    operation: "new"
                }) : e !== Object && null != e || this.throwError("missing new", zl.errors.MISSING_NEW, {
                    name: t.name
                })
            }
            static globalLogger() {
                return Bl || (Bl = new zl("logger/5.7.0")), Bl
            }
            static setCensorship(e, t) {
                if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "setCensorship"
                    }), Ol) {
                    if (!e) return;
                    this.globalLogger().throwError("error censorship permanent", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "setCensorship"
                    })
                }
                Tl = !!e, Ol = !!t
            }
            static setLogLevel(e) {
                const t = Rl[e.toLowerCase()];
                null != t ? Ll = t : zl.globalLogger().warn("invalid log level - " + e)
            }
            static from(e) {
                return new zl(e)
            }
        }
        zl.errors = Dl, zl.levels = jl;
        var ql = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const Gl = new zl("properties/5.7.0");

        function Hl(e, t, n) {
            Object.defineProperty(e, t, {
                enumerable: !0,
                value: n,
                writable: !1
            })
        }

        function $l(e, t) {
            for (let n = 0; n < 32; n++) {
                if (e[t]) return e[t];
                if (!e.prototype || "object" !== typeof e.prototype) break;
                e = Object.getPrototypeOf(e.prototype).constructor
            }
            return null
        }

        function Ql(e) {
            return ql(this, void 0, void 0, (function*() {
                const t = Object.keys(e).map((t => {
                    const n = e[t];
                    return Promise.resolve(n).then((e => ({
                        key: t,
                        value: e
                    })))
                }));
                return (yield Promise.all(t)).reduce(((e, t) => (e[t.key] = t.value, e)), {})
            }))
        }

        function Vl(e) {
            const t = {};
            for (const n in e) t[n] = e[n];
            return t
        }
        const Kl = {
            bigint: !0,
            boolean: !0,
            function: !0,
            number: !0,
            string: !0
        };

        function Wl(e) {
            if (void 0 === e || null === e || Kl[typeof e]) return !0;
            if (Array.isArray(e) || "object" === typeof e) {
                if (!Object.isFrozen(e)) return !1;
                const n = Object.keys(e);
                for (let r = 0; r < n.length; r++) {
                    let i = null;
                    try {
                        i = e[n[r]]
                    } catch (t) {
                        continue
                    }
                    if (!Wl(i)) return !1
                }
                return !0
            }
            return Gl.throwArgumentError("Cannot deepCopy " + typeof e, "object", e)
        }

        function Jl(e) {
            if (Wl(e)) return e;
            if (Array.isArray(e)) return Object.freeze(e.map((e => Zl(e))));
            if ("object" === typeof e) {
                const t = {};
                for (const n in e) {
                    const r = e[n];
                    void 0 !== r && Hl(t, n, Zl(r))
                }
                return t
            }
            return Gl.throwArgumentError("Cannot deepCopy " + typeof e, "object", e)
        }

        function Zl(e) {
            return Jl(e)
        }
        class Yl {
            constructor(e) {
                for (const t in e) this[t] = Zl(e[t])
            }
        }
        var Xl = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const eu = new zl("abstract-signer/5.7.0"),
            tu = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
            nu = [zl.errors.INSUFFICIENT_FUNDS, zl.errors.NONCE_EXPIRED, zl.errors.REPLACEMENT_UNDERPRICED];
        class ru {
            constructor() {
                eu.checkAbstract(new.target, ru), Hl(this, "_isSigner", !0)
            }
            getBalance(e) {
                return Xl(this, void 0, void 0, (function*() {
                    return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e)
                }))
            }
            getTransactionCount(e) {
                return Xl(this, void 0, void 0, (function*() {
                    return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e)
                }))
            }
            estimateGas(e) {
                return Xl(this, void 0, void 0, (function*() {
                    this._checkProvider("estimateGas");
                    const t = yield Ql(this.checkTransaction(e));
                    return yield this.provider.estimateGas(t)
                }))
            }
            call(e, t) {
                return Xl(this, void 0, void 0, (function*() {
                    this._checkProvider("call");
                    const n = yield Ql(this.checkTransaction(e));
                    return yield this.provider.call(n, t)
                }))
            }
            sendTransaction(e) {
                return Xl(this, void 0, void 0, (function*() {
                    this._checkProvider("sendTransaction");
                    const t = yield this.populateTransaction(e), n = yield this.signTransaction(t);
                    return yield this.provider.sendTransaction(n)
                }))
            }
            getChainId() {
                return Xl(this, void 0, void 0, (function*() {
                    this._checkProvider("getChainId");
                    return (yield this.provider.getNetwork()).chainId
                }))
            }
            getGasPrice() {
                return Xl(this, void 0, void 0, (function*() {
                    return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
                }))
            }
            getFeeData() {
                return Xl(this, void 0, void 0, (function*() {
                    return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
                }))
            }
            resolveName(e) {
                return Xl(this, void 0, void 0, (function*() {
                    return this._checkProvider("resolveName"), yield this.provider.resolveName(e)
                }))
            }
            checkTransaction(e) {
                for (const n in e) - 1 === tu.indexOf(n) && eu.throwArgumentError("invalid transaction key: " + n, "transaction", e);
                const t = Vl(e);
                return null == t.from ? t.from = this.getAddress() : t.from = Promise.all([Promise.resolve(t.from), this.getAddress()]).then((t => (t[0].toLowerCase() !== t[1].toLowerCase() && eu.throwArgumentError("from address mismatch", "transaction", e), t[0]))), t
            }
            populateTransaction(e) {
                return Xl(this, void 0, void 0, (function*() {
                    const t = yield Ql(this.checkTransaction(e));
                    null != t.to && (t.to = Promise.resolve(t.to).then((e => Xl(this, void 0, void 0, (function*() {
                        if (null == e) return null;
                        const t = yield this.resolveName(e);
                        return null == t && eu.throwArgumentError("provided ENS name resolves to null", "tx.to", e), t
                    })))), t.to.catch((e => {})));
                    const n = null != t.maxFeePerGas || null != t.maxPriorityFeePerGas;
                    if (null == t.gasPrice || 2 !== t.type && !n ? 0 !== t.type && 1 !== t.type || !n || eu.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e) : eu.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e), 2 !== t.type && null != t.type || null == t.maxFeePerGas || null == t.maxPriorityFeePerGas)
                        if (0 === t.type || 1 === t.type) null == t.gasPrice && (t.gasPrice = this.getGasPrice());
                        else {
                            const e = yield this.getFeeData();
                            if (null == t.type)
                                if (null != e.maxFeePerGas && null != e.maxPriorityFeePerGas)
                                    if (t.type = 2, null != t.gasPrice) {
                                        const e = t.gasPrice;
                                        delete t.gasPrice, t.maxFeePerGas = e, t.maxPriorityFeePerGas = e
                                    } else null == t.maxFeePerGas && (t.maxFeePerGas = e.maxFeePerGas), null == t.maxPriorityFeePerGas && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas);
                            else null != e.gasPrice ? (n && eu.throwError("network does not support EIP-1559", zl.errors.UNSUPPORTED_OPERATION, {
                                operation: "populateTransaction"
                            }), null == t.gasPrice && (t.gasPrice = e.gasPrice), t.type = 0) : eu.throwError("failed to get consistent fee data", zl.errors.UNSUPPORTED_OPERATION, {
                                operation: "signer.getFeeData"
                            });
                            else 2 === t.type && (null == t.maxFeePerGas && (t.maxFeePerGas = e.maxFeePerGas), null == t.maxPriorityFeePerGas && (t.maxPriorityFeePerGas = e.maxPriorityFeePerGas))
                        }
                    else t.type = 2;
                    return null == t.nonce && (t.nonce = this.getTransactionCount("pending")), null == t.gasLimit && (t.gasLimit = this.estimateGas(t).catch((e => {
                        if (nu.indexOf(e.code) >= 0) throw e;
                        return eu.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", zl.errors.UNPREDICTABLE_GAS_LIMIT, {
                            error: e,
                            tx: t
                        })
                    }))), null == t.chainId ? t.chainId = this.getChainId() : t.chainId = Promise.all([Promise.resolve(t.chainId), this.getChainId()]).then((t => (0 !== t[1] && t[0] !== t[1] && eu.throwArgumentError("chainId address mismatch", "transaction", e), t[0]))), yield Ql(t)
                }))
            }
            _checkProvider(e) {
                this.provider || eu.throwError("missing provider", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: e || "_checkProvider"
                })
            }
            static isSigner(e) {
                return !(!e || !e._isSigner)
            }
        }
        class iu extends ru {
            constructor(e, t) {
                super(), Hl(this, "address", e), Hl(this, "provider", t || null)
            }
            getAddress() {
                return Promise.resolve(this.address)
            }
            _fail(e, t) {
                return Promise.resolve().then((() => {
                    eu.throwError(e, zl.errors.UNSUPPORTED_OPERATION, {
                        operation: t
                    })
                }))
            }
            signMessage(e) {
                return this._fail("VoidSigner cannot sign messages", "signMessage")
            }
            signTransaction(e) {
                return this._fail("VoidSigner cannot sign transactions", "signTransaction")
            }
            _signTypedData(e, t, n) {
                return this._fail("VoidSigner cannot sign typed data", "signTypedData")
            }
            connect(e) {
                return new iu(this.address, e)
            }
        }
        var ou = n(6373),
            su = n.n(ou);
        const au = new zl("bytes/5.7.0");

        function lu(e) {
            return !!e.toHexString
        }

        function uu(e) {
            return e.slice || (e.slice = function() {
                const t = Array.prototype.slice.call(arguments);
                return uu(new Uint8Array(Array.prototype.slice.apply(e, t)))
            }), e
        }

        function cu(e) {
            return gu(e) && !(e.length % 2) || hu(e)
        }

        function du(e) {
            return "number" === typeof e && e == e && e % 1 === 0
        }

        function hu(e) {
            if (null == e) return !1;
            if (e.constructor === Uint8Array) return !0;
            if ("string" === typeof e) return !1;
            if (!du(e.length) || e.length < 0) return !1;
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                if (!du(n) || n < 0 || n >= 256) return !1
            }
            return !0
        }

        function fu(e, t) {
            if (t || (t = {}), "number" === typeof e) {
                au.checkSafeUint53(e, "invalid arrayify value");
                const t = [];
                for (; e;) t.unshift(255 & e), e = parseInt(String(e / 256));
                return 0 === t.length && t.push(0), uu(new Uint8Array(t))
            }
            if (t.allowMissingPrefix && "string" === typeof e && "0x" !== e.substring(0, 2) && (e = "0x" + e), lu(e) && (e = e.toHexString()), gu(e)) {
                let n = e.substring(2);
                n.length % 2 && ("left" === t.hexPad ? n = "0" + n : "right" === t.hexPad ? n += "0" : au.throwArgumentError("hex data is odd-length", "value", e));
                const r = [];
                for (let e = 0; e < n.length; e += 2) r.push(parseInt(n.substring(e, e + 2), 16));
                return uu(new Uint8Array(r))
            }
            return hu(e) ? uu(new Uint8Array(e)) : au.throwArgumentError("invalid arrayify value", "value", e)
        }

        function pu(e) {
            const t = e.map((e => fu(e))),
                n = t.reduce(((e, t) => e + t.length), 0),
                r = new Uint8Array(n);
            return t.reduce(((e, t) => (r.set(t, e), e + t.length)), 0), uu(r)
        }

        function mu(e) {
            let t = fu(e);
            if (0 === t.length) return t;
            let n = 0;
            for (; n < t.length && 0 === t[n];) n++;
            return n && (t = t.slice(n)), t
        }

        function gu(e, t) {
            return !("string" !== typeof e || !e.match(/^0x[0-9A-Fa-f]*$/)) && (!t || e.length === 2 + 2 * t)
        }
        const yu = "0123456789abcdef";

        function vu(e, t) {
            if (t || (t = {}), "number" === typeof e) {
                au.checkSafeUint53(e, "invalid hexlify value");
                let t = "";
                for (; e;) t = yu[15 & e] + t, e = Math.floor(e / 16);
                return t.length ? (t.length % 2 && (t = "0" + t), "0x" + t) : "0x00"
            }
            if ("bigint" === typeof e) return (e = e.toString(16)).length % 2 ? "0x0" + e : "0x" + e;
            if (t.allowMissingPrefix && "string" === typeof e && "0x" !== e.substring(0, 2) && (e = "0x" + e), lu(e)) return e.toHexString();
            if (gu(e)) return e.length % 2 && ("left" === t.hexPad ? e = "0x0" + e.substring(2) : "right" === t.hexPad ? e += "0" : au.throwArgumentError("hex data is odd-length", "value", e)), e.toLowerCase();
            if (hu(e)) {
                let t = "0x";
                for (let n = 0; n < e.length; n++) {
                    let r = e[n];
                    t += yu[(240 & r) >> 4] + yu[15 & r]
                }
                return t
            }
            return au.throwArgumentError("invalid hexlify value", "value", e)
        }

        function bu(e) {
            if ("string" !== typeof e) e = vu(e);
            else if (!gu(e) || e.length % 2) return null;
            return (e.length - 2) / 2
        }

        function wu(e, t, n) {
            return "string" !== typeof e ? e = vu(e) : (!gu(e) || e.length % 2) && au.throwArgumentError("invalid hexData", "value", e), t = 2 + 2 * t, null != n ? "0x" + e.substring(t, 2 + 2 * n) : "0x" + e.substring(t)
        }

        function Eu(e) {
            let t = "0x";
            return e.forEach((e => {
                t += vu(e).substring(2)
            })), t
        }

        function xu(e) {
            const t = function(e) {
                "string" !== typeof e && (e = vu(e));
                gu(e) || au.throwArgumentError("invalid hex string", "value", e);
                e = e.substring(2);
                let t = 0;
                for (; t < e.length && "0" === e[t];) t++;
                return "0x" + e.substring(t)
            }(vu(e, {
                hexPad: "left"
            }));
            return "0x" === t ? "0x0" : t
        }

        function Au(e, t) {
            for ("string" !== typeof e ? e = vu(e) : gu(e) || au.throwArgumentError("invalid hex string", "value", e), e.length > 2 * t + 2 && au.throwArgumentError("value out of range", "value", arguments[1]); e.length < 2 * t + 2;) e = "0x0" + e.substring(2);
            return e
        }

        function ku(e) {
            const t = {
                r: "0x",
                s: "0x",
                _vs: "0x",
                recoveryParam: 0,
                v: 0,
                yParityAndS: "0x",
                compact: "0x"
            };
            if (cu(e)) {
                let n = fu(e);
                64 === n.length ? (t.v = 27 + (n[32] >> 7), n[32] &= 127, t.r = vu(n.slice(0, 32)), t.s = vu(n.slice(32, 64))) : 65 === n.length ? (t.r = vu(n.slice(0, 32)), t.s = vu(n.slice(32, 64)), t.v = n[64]) : au.throwArgumentError("invalid signature string", "signature", e), t.v < 27 && (0 === t.v || 1 === t.v ? t.v += 27 : au.throwArgumentError("signature invalid v byte", "signature", e)), t.recoveryParam = 1 - t.v % 2, t.recoveryParam && (n[32] |= 128), t._vs = vu(n.slice(32, 64))
            } else {
                if (t.r = e.r, t.s = e.s, t.v = e.v, t.recoveryParam = e.recoveryParam, t._vs = e._vs, null != t._vs) {
                    const n = function(e, t) {
                        (e = fu(e)).length > t && au.throwArgumentError("value out of range", "value", arguments[0]);
                        const n = new Uint8Array(t);
                        return n.set(e, t - e.length), uu(n)
                    }(fu(t._vs), 32);
                    t._vs = vu(n);
                    const r = n[0] >= 128 ? 1 : 0;
                    null == t.recoveryParam ? t.recoveryParam = r : t.recoveryParam !== r && au.throwArgumentError("signature recoveryParam mismatch _vs", "signature", e), n[0] &= 127;
                    const i = vu(n);
                    null == t.s ? t.s = i : t.s !== i && au.throwArgumentError("signature v mismatch _vs", "signature", e)
                }
                if (null == t.recoveryParam) null == t.v ? au.throwArgumentError("signature missing v and recoveryParam", "signature", e) : 0 === t.v || 1 === t.v ? t.recoveryParam = t.v : t.recoveryParam = 1 - t.v % 2;
                else if (null == t.v) t.v = 27 + t.recoveryParam;
                else {
                    const n = 0 === t.v || 1 === t.v ? t.v : 1 - t.v % 2;
                    t.recoveryParam !== n && au.throwArgumentError("signature recoveryParam mismatch v", "signature", e)
                }
                null != t.r && gu(t.r) ? t.r = Au(t.r, 32) : au.throwArgumentError("signature missing or invalid r", "signature", e), null != t.s && gu(t.s) ? t.s = Au(t.s, 32) : au.throwArgumentError("signature missing or invalid s", "signature", e);
                const n = fu(t.s);
                n[0] >= 128 && au.throwArgumentError("signature s out of range", "signature", e), t.recoveryParam && (n[0] |= 128);
                const r = vu(n);
                t._vs && (gu(t._vs) || au.throwArgumentError("signature invalid _vs", "signature", e), t._vs = Au(t._vs, 32)), null == t._vs ? t._vs = r : t._vs !== r && au.throwArgumentError("signature _vs mismatch v and s", "signature", e)
            }
            return t.yParityAndS = t._vs, t.compact = t.r + t.yParityAndS.substring(2), t
        }
        var Cu = su().BN;
        const Pu = new zl("bignumber/5.7.0"),
            Su = {},
            _u = 9007199254740991;
        let Nu = !1;
        class Mu {
            constructor(e, t) {
                e !== Su && Pu.throwError("cannot call constructor directly; use BigNumber.from", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "new (BigNumber)"
                }), this._hex = t, this._isBigNumber = !0, Object.freeze(this)
            }
            fromTwos(e) {
                return Ou(Tu(this).fromTwos(e))
            }
            toTwos(e) {
                return Ou(Tu(this).toTwos(e))
            }
            abs() {
                return "-" === this._hex[0] ? Mu.from(this._hex.substring(1)) : this
            }
            add(e) {
                return Ou(Tu(this).add(Tu(e)))
            }
            sub(e) {
                return Ou(Tu(this).sub(Tu(e)))
            }
            div(e) {
                return Mu.from(e).isZero() && Ru("division-by-zero", "div"), Ou(Tu(this).div(Tu(e)))
            }
            mul(e) {
                return Ou(Tu(this).mul(Tu(e)))
            }
            mod(e) {
                const t = Tu(e);
                return t.isNeg() && Ru("division-by-zero", "mod"), Ou(Tu(this).umod(t))
            }
            pow(e) {
                const t = Tu(e);
                return t.isNeg() && Ru("negative-power", "pow"), Ou(Tu(this).pow(t))
            }
            and(e) {
                const t = Tu(e);
                return (this.isNegative() || t.isNeg()) && Ru("unbound-bitwise-result", "and"), Ou(Tu(this).and(t))
            }
            or(e) {
                const t = Tu(e);
                return (this.isNegative() || t.isNeg()) && Ru("unbound-bitwise-result", "or"), Ou(Tu(this).or(t))
            }
            xor(e) {
                const t = Tu(e);
                return (this.isNegative() || t.isNeg()) && Ru("unbound-bitwise-result", "xor"), Ou(Tu(this).xor(t))
            }
            mask(e) {
                return (this.isNegative() || e < 0) && Ru("negative-width", "mask"), Ou(Tu(this).maskn(e))
            }
            shl(e) {
                return (this.isNegative() || e < 0) && Ru("negative-width", "shl"), Ou(Tu(this).shln(e))
            }
            shr(e) {
                return (this.isNegative() || e < 0) && Ru("negative-width", "shr"), Ou(Tu(this).shrn(e))
            }
            eq(e) {
                return Tu(this).eq(Tu(e))
            }
            lt(e) {
                return Tu(this).lt(Tu(e))
            }
            lte(e) {
                return Tu(this).lte(Tu(e))
            }
            gt(e) {
                return Tu(this).gt(Tu(e))
            }
            gte(e) {
                return Tu(this).gte(Tu(e))
            }
            isNegative() {
                return "-" === this._hex[0]
            }
            isZero() {
                return Tu(this).isZero()
            }
            toNumber() {
                try {
                    return Tu(this).toNumber()
                } catch (e) {
                    Ru("overflow", "toNumber", this.toString())
                }
                return null
            }
            toBigInt() {
                try {
                    return BigInt(this.toString())
                } catch (dg) {}
                return Pu.throwError("this platform does not support BigInt", zl.errors.UNSUPPORTED_OPERATION, {
                    value: this.toString()
                })
            }
            toString() {
                return arguments.length > 0 && (10 === arguments[0] ? Nu || (Nu = !0, Pu.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : 16 === arguments[0] ? Pu.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", zl.errors.UNEXPECTED_ARGUMENT, {}) : Pu.throwError("BigNumber.toString does not accept parameters", zl.errors.UNEXPECTED_ARGUMENT, {})), Tu(this).toString(10)
            }
            toHexString() {
                return this._hex
            }
            toJSON(e) {
                return {
                    type: "BigNumber",
                    hex: this.toHexString()
                }
            }
            static from(e) {
                if (e instanceof Mu) return e;
                if ("string" === typeof e) return e.match(/^-?0x[0-9a-f]+$/i) ? new Mu(Su, Iu(e)) : e.match(/^-?[0-9]+$/) ? new Mu(Su, Iu(new Cu(e))) : Pu.throwArgumentError("invalid BigNumber string", "value", e);
                if ("number" === typeof e) return e % 1 && Ru("underflow", "BigNumber.from", e), (e >= _u || e <= -_u) && Ru("overflow", "BigNumber.from", e), Mu.from(String(e));
                const t = e;
                if ("bigint" === typeof t) return Mu.from(t.toString());
                if (hu(t)) return Mu.from(vu(t));
                if (t)
                    if (t.toHexString) {
                        const e = t.toHexString();
                        if ("string" === typeof e) return Mu.from(e)
                    } else {
                        let e = t._hex;
                        if (null == e && "BigNumber" === t.type && (e = t.hex), "string" === typeof e && (gu(e) || "-" === e[0] && gu(e.substring(1)))) return Mu.from(e)
                    }
                return Pu.throwArgumentError("invalid BigNumber value", "value", e)
            }
            static isBigNumber(e) {
                return !(!e || !e._isBigNumber)
            }
        }

        function Iu(e) {
            if ("string" !== typeof e) return Iu(e.toString(16));
            if ("-" === e[0]) return "-" === (e = e.substring(1))[0] && Pu.throwArgumentError("invalid hex", "value", e), "0x00" === (e = Iu(e)) ? e : "-" + e;
            if ("0x" !== e.substring(0, 2) && (e = "0x" + e), "0x" === e) return "0x00";
            for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && "0x00" === e.substring(0, 4);) e = "0x" + e.substring(4);
            return e
        }

        function Ou(e) {
            return Mu.from(Iu(e))
        }

        function Tu(e) {
            const t = Mu.from(e).toHexString();
            return "-" === t[0] ? new Cu("-" + t.substring(3), 16) : new Cu(t.substring(2), 16)
        }

        function Ru(e, t, n) {
            const r = {
                fault: e,
                operation: t
            };
            return null != n && (r.value = n), Pu.throwError(e, zl.errors.NUMERIC_FAULT, r)
        }
        var Lu = n(2161),
            Bu = n.n(Lu);

        function Fu(e) {
            return "0x" + Bu().keccak_256(fu(e))
        }
        const ju = new zl("rlp/5.7.0");

        function Du(e) {
            const t = [];
            for (; e;) t.unshift(255 & e), e >>= 8;
            return t
        }

        function Uu(e, t, n) {
            let r = 0;
            for (let i = 0; i < n; i++) r = 256 * r + e[t + i];
            return r
        }

        function zu(e) {
            if (Array.isArray(e)) {
                let t = [];
                if (e.forEach((function(e) {
                        t = t.concat(zu(e))
                    })), t.length <= 55) return t.unshift(192 + t.length), t;
                const n = Du(t.length);
                return n.unshift(247 + n.length), n.concat(t)
            }
            cu(e) || ju.throwArgumentError("RLP object must be BytesLike", "object", e);
            const t = Array.prototype.slice.call(fu(e));
            if (1 === t.length && t[0] <= 127) return t;
            if (t.length <= 55) return t.unshift(128 + t.length), t;
            const n = Du(t.length);
            return n.unshift(183 + n.length), n.concat(t)
        }

        function qu(e) {
            return vu(zu(e))
        }

        function Gu(e, t, n, r) {
            const i = [];
            for (; n < t + 1 + r;) {
                const o = Hu(e, n);
                i.push(o.result), (n += o.consumed) > t + 1 + r && ju.throwError("child data too short", zl.errors.BUFFER_OVERRUN, {})
            }
            return {
                consumed: 1 + r,
                result: i
            }
        }

        function Hu(e, t) {
            if (0 === e.length && ju.throwError("data too short", zl.errors.BUFFER_OVERRUN, {}), e[t] >= 248) {
                const n = e[t] - 247;
                t + 1 + n > e.length && ju.throwError("data short segment too short", zl.errors.BUFFER_OVERRUN, {});
                const r = Uu(e, t + 1, n);
                return t + 1 + n + r > e.length && ju.throwError("data long segment too short", zl.errors.BUFFER_OVERRUN, {}), Gu(e, t, t + 1 + n, n + r)
            }
            if (e[t] >= 192) {
                const n = e[t] - 192;
                return t + 1 + n > e.length && ju.throwError("data array too short", zl.errors.BUFFER_OVERRUN, {}), Gu(e, t, t + 1, n)
            }
            if (e[t] >= 184) {
                const n = e[t] - 183;
                t + 1 + n > e.length && ju.throwError("data array too short", zl.errors.BUFFER_OVERRUN, {});
                const r = Uu(e, t + 1, n);
                t + 1 + n + r > e.length && ju.throwError("data array too short", zl.errors.BUFFER_OVERRUN, {});
                return {
                    consumed: 1 + n + r,
                    result: vu(e.slice(t + 1 + n, t + 1 + n + r))
                }
            }
            if (e[t] >= 128) {
                const n = e[t] - 128;
                t + 1 + n > e.length && ju.throwError("data too short", zl.errors.BUFFER_OVERRUN, {});
                return {
                    consumed: 1 + n,
                    result: vu(e.slice(t + 1, t + 1 + n))
                }
            }
            return {
                consumed: 1,
                result: vu(e[t])
            }
        }

        function $u(e) {
            const t = fu(e),
                n = Hu(t, 0);
            return n.consumed !== t.length && ju.throwArgumentError("invalid rlp data", "data", e), n.result
        }
        const Qu = new zl("address/5.7.0");

        function Vu(e) {
            gu(e, 20) || Qu.throwArgumentError("invalid address", "address", e);
            const t = (e = e.toLowerCase()).substring(2).split(""),
                n = new Uint8Array(40);
            for (let i = 0; i < 40; i++) n[i] = t[i].charCodeAt(0);
            const r = fu(Fu(n));
            for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (t[i] = t[i].toUpperCase()), (15 & r[i >> 1]) >= 8 && (t[i + 1] = t[i + 1].toUpperCase());
            return "0x" + t.join("")
        }
        const Ku = {};
        for (let n = 0; n < 10; n++) Ku[String(n)] = String(n);
        for (let n = 0; n < 26; n++) Ku[String.fromCharCode(65 + n)] = String(10 + n);
        const Wu = Math.floor(function(e) {
            return Math.log10 ? Math.log10(e) : Math.log(e) / Math.LN10
        }(9007199254740991));

        function Ju(e) {
            let t = (e = (e = e.toUpperCase()).substring(4) + e.substring(0, 2) + "00").split("").map((e => Ku[e])).join("");
            for (; t.length >= Wu;) {
                let e = t.substring(0, Wu);
                t = parseInt(e, 10) % 97 + t.substring(e.length)
            }
            let n = String(98 - parseInt(t, 10) % 97);
            for (; n.length < 2;) n = "0" + n;
            return n
        }

        function Zu(e) {
            let t = null;
            if ("string" !== typeof e && Qu.throwArgumentError("invalid address", "address", e), e.match(/^(0x)?[0-9a-fA-F]{40}$/)) "0x" !== e.substring(0, 2) && (e = "0x" + e), t = Vu(e), e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== e && Qu.throwArgumentError("bad address checksum", "address", e);
            else if (e.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
                for (e.substring(2, 4) !== Ju(e) && Qu.throwArgumentError("bad icap checksum", "address", e), n = e.substring(4), t = new Cu(n, 36).toString(16); t.length < 40;) t = "0" + t;
                t = Vu("0x" + t)
            } else Qu.throwArgumentError("invalid address", "address", e);
            var n;
            return t
        }

        function Yu(e) {
            let t = null;
            try {
                t = Zu(e.from)
            } catch (n) {
                Qu.throwArgumentError("missing from address", "transaction", e)
            }
            return Zu(wu(Fu(qu([t, mu(fu(Mu.from(e.nonce).toHexString()))])), 12))
        }
        const Xu = "hash/5.7.0",
            ec = new zl("strings/5.7.0");
        var tc, nc;

        function rc(e, t, n, r, i) {
            if (e === nc.BAD_PREFIX || e === nc.UNEXPECTED_CONTINUE) {
                let e = 0;
                for (let r = t + 1; r < n.length && n[r] >> 6 === 2; r++) e++;
                return e
            }
            return e === nc.OVERRUN ? n.length - t - 1 : 0
        }! function(e) {
            e.current = "", e.NFC = "NFC", e.NFD = "NFD", e.NFKC = "NFKC", e.NFKD = "NFKD"
        }(tc || (tc = {})),
        function(e) {
            e.UNEXPECTED_CONTINUE = "unexpected continuation byte", e.BAD_PREFIX = "bad codepoint prefix", e.OVERRUN = "string overrun", e.MISSING_CONTINUE = "missing continuation byte", e.OUT_OF_RANGE = "out of UTF-8 range", e.UTF16_SURROGATE = "UTF-16 surrogate", e.OVERLONG = "overlong representation"
        }(nc || (nc = {}));
        const ic = Object.freeze({
            error: function(e, t, n, r, i) {
                return ec.throwArgumentError(`invalid codepoint at offset ${t}; ${e}`, "bytes", n)
            },
            ignore: rc,
            replace: function(e, t, n, r, i) {
                return e === nc.OVERLONG ? (r.push(i), 0) : (r.push(65533), rc(e, t, n))
            }
        });

        function oc(e, t) {
            null == t && (t = ic.error), e = fu(e);
            const n = [];
            let r = 0;
            for (; r < e.length;) {
                const i = e[r++];
                if (i >> 7 === 0) {
                    n.push(i);
                    continue
                }
                let o = null,
                    s = null;
                if (192 === (224 & i)) o = 1, s = 127;
                else if (224 === (240 & i)) o = 2, s = 2047;
                else {
                    if (240 !== (248 & i)) {
                        r += t(128 === (192 & i) ? nc.UNEXPECTED_CONTINUE : nc.BAD_PREFIX, r - 1, e, n);
                        continue
                    }
                    o = 3, s = 65535
                }
                if (r - 1 + o >= e.length) {
                    r += t(nc.OVERRUN, r - 1, e, n);
                    continue
                }
                let a = i & (1 << 8 - o - 1) - 1;
                for (let l = 0; l < o; l++) {
                    let i = e[r];
                    if (128 != (192 & i)) {
                        r += t(nc.MISSING_CONTINUE, r, e, n), a = null;
                        break
                    }
                    a = a << 6 | 63 & i, r++
                }
                null !== a && (a > 1114111 ? r += t(nc.OUT_OF_RANGE, r - 1 - o, e, n, a) : a >= 55296 && a <= 57343 ? r += t(nc.UTF16_SURROGATE, r - 1 - o, e, n, a) : a <= s ? r += t(nc.OVERLONG, r - 1 - o, e, n, a) : n.push(a))
            }
            return n
        }

        function sc(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : tc.current;
            t != tc.current && (ec.checkNormalize(), e = e.normalize(t));
            let n = [];
            for (let r = 0; r < e.length; r++) {
                const t = e.charCodeAt(r);
                if (t < 128) n.push(t);
                else if (t < 2048) n.push(t >> 6 | 192), n.push(63 & t | 128);
                else if (55296 == (64512 & t)) {
                    r++;
                    const i = e.charCodeAt(r);
                    if (r >= e.length || 56320 !== (64512 & i)) throw new Error("invalid utf-8 string");
                    const o = 65536 + ((1023 & t) << 10) + (1023 & i);
                    n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(63 & o | 128)
                } else n.push(t >> 12 | 224), n.push(t >> 6 & 63 | 128), n.push(63 & t | 128)
            }
            return fu(n)
        }

        function ac(e, t) {
            return oc(e, t).map((e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode(55296 + (e >> 10 & 1023), 56320 + (1023 & e))))).join("")
        }

        function lc(e) {
            return Fu(sc(e))
        }
        var uc = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const cc = new zl(Xu),
            dc = new Uint8Array(32);
        dc.fill(0);
        const hc = Mu.from(-1),
            fc = Mu.from(0),
            pc = Mu.from(1),
            mc = Mu.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        const gc = Au(pc.toHexString(), 32),
            yc = Au(fc.toHexString(), 32),
            vc = {
                name: "string",
                version: "string",
                chainId: "uint256",
                verifyingContract: "address",
                salt: "bytes32"
            },
            bc = ["name", "version", "chainId", "verifyingContract", "salt"];

        function wc(e) {
            return function(t) {
                return "string" !== typeof t && cc.throwArgumentError(`invalid domain value for ${JSON.stringify(e)}`, `domain.${e}`, t), t
            }
        }
        const Ec = {
            name: wc("name"),
            version: wc("version"),
            chainId: function(e) {
                try {
                    return Mu.from(e).toString()
                } catch (t) {}
                return cc.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", e)
            },
            verifyingContract: function(e) {
                try {
                    return Zu(e).toLowerCase()
                } catch (t) {}
                return cc.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", e)
            },
            salt: function(e) {
                try {
                    const t = fu(e);
                    if (32 !== t.length) throw new Error("bad length");
                    return vu(t)
                } catch (t) {}
                return cc.throwArgumentError('invalid domain value "salt"', "domain.salt", e)
            }
        };

        function xc(e) {
            {
                const t = e.match(/^(u?)int(\d*)$/);
                if (t) {
                    const n = "" === t[1],
                        r = parseInt(t[2] || "256");
                    (r % 8 !== 0 || r > 256 || t[2] && t[2] !== String(r)) && cc.throwArgumentError("invalid numeric width", "type", e);
                    const i = mc.mask(n ? r - 1 : r),
                        o = n ? i.add(pc).mul(hc) : fc;
                    return function(t) {
                        const n = Mu.from(t);
                        return (n.lt(o) || n.gt(i)) && cc.throwArgumentError(`value out-of-bounds for ${e}`, "value", t), Au(n.toTwos(256).toHexString(), 32)
                    }
                }
            } {
                const t = e.match(/^bytes(\d+)$/);
                if (t) {
                    const n = parseInt(t[1]);
                    return (0 === n || n > 32 || t[1] !== String(n)) && cc.throwArgumentError("invalid bytes width", "type", e),
                        function(t) {
                            return fu(t).length !== n && cc.throwArgumentError(`invalid length for ${e}`, "value", t),
                                function(e) {
                                    const t = fu(e),
                                        n = t.length % 32;
                                    return n ? Eu([t, dc.slice(n)]) : vu(t)
                                }(t)
                        }
                }
            }
            switch (e) {
                case "address":
                    return function(e) {
                        return Au(Zu(e), 32)
                    };
                case "bool":
                    return function(e) {
                        return e ? gc : yc
                    };
                case "bytes":
                    return function(e) {
                        return Fu(e)
                    };
                case "string":
                    return function(e) {
                        return lc(e)
                    }
            }
            return null
        }

        function Ac(e, t) {
            return `${e}(${t.map((e=>{let{name:t,type:n}=e;return n+" "+t})).join(",")})`
        }
        class kc {
            constructor(e) {
                Hl(this, "types", Object.freeze(Zl(e))), Hl(this, "_encoderCache", {}), Hl(this, "_types", {});
                const t = {},
                    n = {},
                    r = {};
                Object.keys(e).forEach((e => {
                    t[e] = {}, n[e] = [], r[e] = {}
                }));
                for (const o in e) {
                    const r = {};
                    e[o].forEach((i => {
                        r[i.name] && cc.throwArgumentError(`duplicate variable name ${JSON.stringify(i.name)} in ${JSON.stringify(o)}`, "types", e), r[i.name] = !0;
                        const s = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                        s === o && cc.throwArgumentError(`circular type reference to ${JSON.stringify(s)}`, "types", e);
                        xc(s) || (n[s] || cc.throwArgumentError(`unknown type ${JSON.stringify(s)}`, "types", e), n[s].push(o), t[o][s] = !0)
                    }))
                }
                const i = Object.keys(n).filter((e => 0 === n[e].length));
                0 === i.length ? cc.throwArgumentError("missing primary type", "types", e) : i.length > 1 && cc.throwArgumentError(`ambiguous primary types or unused types: ${i.map((e=>JSON.stringify(e))).join(", ")}`, "types", e), Hl(this, "primaryType", i[0]),
                    function i(o, s) {
                        s[o] && cc.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, "types", e), s[o] = !0, Object.keys(t[o]).forEach((e => {
                            n[e] && (i(e, s), Object.keys(s).forEach((t => {
                                r[t][e] = !0
                            })))
                        })), delete s[o]
                    }(this.primaryType, {});
                for (const o in r) {
                    const t = Object.keys(r[o]);
                    t.sort(), this._types[o] = Ac(o, e[o]) + t.map((t => Ac(t, e[t]))).join("")
                }
            }
            getEncoder(e) {
                let t = this._encoderCache[e];
                return t || (t = this._encoderCache[e] = this._getEncoder(e)), t
            }
            _getEncoder(e) {
                {
                    const t = xc(e);
                    if (t) return t
                }
                const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
                if (t) {
                    const e = t[1],
                        n = this.getEncoder(e),
                        r = parseInt(t[3]);
                    return t => {
                        r >= 0 && t.length !== r && cc.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t);
                        let i = t.map(n);
                        return this._types[e] && (i = i.map(Fu)), Fu(Eu(i))
                    }
                }
                const n = this.types[e];
                if (n) {
                    const t = lc(this._types[e]);
                    return e => {
                        const r = n.map((t => {
                            let {
                                name: n,
                                type: r
                            } = t;
                            const i = this.getEncoder(r)(e[n]);
                            return this._types[r] ? Fu(i) : i
                        }));
                        return r.unshift(t), Eu(r)
                    }
                }
                return cc.throwArgumentError(`unknown type: ${e}`, "type", e)
            }
            encodeType(e) {
                const t = this._types[e];
                return t || cc.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), t
            }
            encodeData(e, t) {
                return this.getEncoder(e)(t)
            }
            hashStruct(e, t) {
                return Fu(this.encodeData(e, t))
            }
            encode(e) {
                return this.encodeData(this.primaryType, e)
            }
            hash(e) {
                return this.hashStruct(this.primaryType, e)
            }
            _visit(e, t, n) {
                if (xc(e)) return n(e, t);
                const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
                if (r) {
                    const e = r[1],
                        i = parseInt(r[3]);
                    return i >= 0 && t.length !== i && cc.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t), t.map((t => this._visit(e, t, n)))
                }
                const i = this.types[e];
                return i ? i.reduce(((e, r) => {
                    let {
                        name: i,
                        type: o
                    } = r;
                    return e[i] = this._visit(o, t[i], n), e
                }), {}) : cc.throwArgumentError(`unknown type: ${e}`, "type", e)
            }
            visit(e, t) {
                return this._visit(this.primaryType, e, t)
            }
            static from(e) {
                return new kc(e)
            }
            static getPrimaryType(e) {
                return kc.from(e).primaryType
            }
            static hashStruct(e, t, n) {
                return kc.from(t).hashStruct(e, n)
            }
            static hashDomain(e) {
                const t = [];
                for (const n in e) {
                    const r = vc[n];
                    r || cc.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), t.push({
                        name: n,
                        type: r
                    })
                }
                return t.sort(((e, t) => bc.indexOf(e.name) - bc.indexOf(t.name))), kc.hashStruct("EIP712Domain", {
                    EIP712Domain: t
                }, e)
            }
            static encode(e, t, n) {
                return Eu(["0x1901", kc.hashDomain(e), kc.from(t).hash(n)])
            }
            static hash(e, t, n) {
                return Fu(kc.encode(e, t, n))
            }
            static resolveNames(e, t, n, r) {
                return uc(this, void 0, void 0, (function*() {
                    e = Vl(e);
                    const i = {};
                    e.verifyingContract && !gu(e.verifyingContract, 20) && (i[e.verifyingContract] = "0x");
                    const o = kc.from(t);
                    o.visit(n, ((e, t) => ("address" !== e || gu(t, 20) || (i[t] = "0x"), t)));
                    for (const e in i) i[e] = yield r(e);
                    return e.verifyingContract && i[e.verifyingContract] && (e.verifyingContract = i[e.verifyingContract]), n = o.visit(n, ((e, t) => "address" === e && i[t] ? i[t] : t)), {
                        domain: e,
                        value: n
                    }
                }))
            }
            static getPayload(e, t, n) {
                kc.hashDomain(e);
                const r = {},
                    i = [];
                bc.forEach((t => {
                    const n = e[t];
                    null != n && (r[t] = Ec[t](n), i.push({
                        name: t,
                        type: vc[t]
                    }))
                }));
                const o = kc.from(t),
                    s = Vl(t);
                return s.EIP712Domain ? cc.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", t) : s.EIP712Domain = i, o.encode(n), {
                    types: s,
                    domain: r,
                    primaryType: o.primaryType,
                    message: o.visit(n, ((e, t) => {
                        if (e.match(/^bytes(\d*)/)) return vu(fu(t));
                        if (e.match(/^u?int/)) return Mu.from(t).toString();
                        switch (e) {
                            case "address":
                                return t.toLowerCase();
                            case "bool":
                                return !!t;
                            case "string":
                                return "string" !== typeof t && cc.throwArgumentError("invalid string", "value", t), t
                        }
                        return cc.throwArgumentError("unsupported type", "type", e)
                    }))
                }
            }
        }
        const Cc = Mu.from(-1),
            Pc = Mu.from(0),
            Sc = Mu.from(1),
            _c = Mu.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
        var Nc = n(3697),
            Mc = n.n(Nc);
        "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof n.g ? n.g : "undefined" !== typeof self && self;

        function Ic(e, t, n) {
            return n = {
                path: t,
                exports: {},
                require: function(e, t) {
                    return function() {
                        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
                    }((void 0 === t || null === t) && n.path)
                }
            }, e(n, n.exports), n.exports
        }
        var Oc = Tc;

        function Tc(e, t) {
            if (!e) throw new Error(t || "Assertion failed")
        }
        Tc.equal = function(e, t, n) {
            if (e != t) throw new Error(n || "Assertion failed: " + e + " != " + t)
        };
        var Rc = Ic((function(e, t) {
                var n = t;

                function r(e) {
                    return 1 === e.length ? "0" + e : e
                }

                function i(e) {
                    for (var t = "", n = 0; n < e.length; n++) t += r(e[n].toString(16));
                    return t
                }
                n.toArray = function(e, t) {
                    if (Array.isArray(e)) return e.slice();
                    if (!e) return [];
                    var n = [];
                    if ("string" !== typeof e) {
                        for (var r = 0; r < e.length; r++) n[r] = 0 | e[r];
                        return n
                    }
                    if ("hex" === t) {
                        (e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 !== 0 && (e = "0" + e);
                        for (r = 0; r < e.length; r += 2) n.push(parseInt(e[r] + e[r + 1], 16))
                    } else
                        for (r = 0; r < e.length; r++) {
                            var i = e.charCodeAt(r),
                                o = i >> 8,
                                s = 255 & i;
                            o ? n.push(o, s) : n.push(s)
                        }
                    return n
                }, n.zero2 = r, n.toHex = i, n.encode = function(e, t) {
                    return "hex" === t ? i(e) : e
                }
            })),
            Lc = Ic((function(e, t) {
                var n = t;
                n.assert = Oc, n.toArray = Rc.toArray, n.zero2 = Rc.zero2, n.toHex = Rc.toHex, n.encode = Rc.encode, n.getNAF = function(e, t, n) {
                    var r = new Array(Math.max(e.bitLength(), n) + 1);
                    r.fill(0);
                    for (var i = 1 << t + 1, o = e.clone(), s = 0; s < r.length; s++) {
                        var a, l = o.andln(i - 1);
                        o.isOdd() ? (a = l > (i >> 1) - 1 ? (i >> 1) - l : l, o.isubn(a)) : a = 0, r[s] = a, o.iushrn(1)
                    }
                    return r
                }, n.getJSF = function(e, t) {
                    var n = [
                        [],
                        []
                    ];
                    e = e.clone(), t = t.clone();
                    for (var r, i = 0, o = 0; e.cmpn(-i) > 0 || t.cmpn(-o) > 0;) {
                        var s, a, l = e.andln(3) + i & 3,
                            u = t.andln(3) + o & 3;
                        3 === l && (l = -1), 3 === u && (u = -1), s = 0 === (1 & l) ? 0 : 3 !== (r = e.andln(7) + i & 7) && 5 !== r || 2 !== u ? l : -l, n[0].push(s), a = 0 === (1 & u) ? 0 : 3 !== (r = t.andln(7) + o & 7) && 5 !== r || 2 !== l ? u : -u, n[1].push(a), 2 * i === s + 1 && (i = 1 - i), 2 * o === a + 1 && (o = 1 - o), e.iushrn(1), t.iushrn(1)
                    }
                    return n
                }, n.cachedProperty = function(e, t, n) {
                    var r = "_" + t;
                    e.prototype[t] = function() {
                        return void 0 !== this[r] ? this[r] : this[r] = n.call(this)
                    }
                }, n.parseBytes = function(e) {
                    return "string" === typeof e ? n.toArray(e, "hex") : e
                }, n.intFromLE = function(e) {
                    return new(su())(e, "hex", "le")
                }
            })),
            Bc = Lc.getNAF,
            Fc = Lc.getJSF,
            jc = Lc.assert;

        function Dc(e, t) {
            this.type = e, this.p = new(su())(t.p, 16), this.red = t.prime ? su().red(t.prime) : su().mont(this.p), this.zero = new(su())(0).toRed(this.red), this.one = new(su())(1).toRed(this.red), this.two = new(su())(2).toRed(this.red), this.n = t.n && new(su())(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
            var n = this.n && this.p.div(this.n);
            !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
        }
        var Uc = Dc;

        function zc(e, t) {
            this.curve = e, this.type = t, this.precomputed = null
        }
        Dc.prototype.point = function() {
            throw new Error("Not implemented")
        }, Dc.prototype.validate = function() {
            throw new Error("Not implemented")
        }, Dc.prototype._fixedNafMul = function(e, t) {
            jc(e.precomputed);
            var n = e._getDoubles(),
                r = Bc(t, 1, this._bitLength),
                i = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
            i /= 3;
            var o, s, a = [];
            for (o = 0; o < r.length; o += n.step) {
                s = 0;
                for (var l = o + n.step - 1; l >= o; l--) s = (s << 1) + r[l];
                a.push(s)
            }
            for (var u = this.jpoint(null, null, null), c = this.jpoint(null, null, null), d = i; d > 0; d--) {
                for (o = 0; o < a.length; o++)(s = a[o]) === d ? c = c.mixedAdd(n.points[o]) : s === -d && (c = c.mixedAdd(n.points[o].neg()));
                u = u.add(c)
            }
            return u.toP()
        }, Dc.prototype._wnafMul = function(e, t) {
            var n = 4,
                r = e._getNAFPoints(n);
            n = r.wnd;
            for (var i = r.points, o = Bc(t, n, this._bitLength), s = this.jpoint(null, null, null), a = o.length - 1; a >= 0; a--) {
                for (var l = 0; a >= 0 && 0 === o[a]; a--) l++;
                if (a >= 0 && l++, s = s.dblp(l), a < 0) break;
                var u = o[a];
                jc(0 !== u), s = "affine" === e.type ? u > 0 ? s.mixedAdd(i[u - 1 >> 1]) : s.mixedAdd(i[-u - 1 >> 1].neg()) : u > 0 ? s.add(i[u - 1 >> 1]) : s.add(i[-u - 1 >> 1].neg())
            }
            return "affine" === e.type ? s.toP() : s
        }, Dc.prototype._wnafMulAdd = function(e, t, n, r, i) {
            var o, s, a, l = this._wnafT1,
                u = this._wnafT2,
                c = this._wnafT3,
                d = 0;
            for (o = 0; o < r; o++) {
                var h = (a = t[o])._getNAFPoints(e);
                l[o] = h.wnd, u[o] = h.points
            }
            for (o = r - 1; o >= 1; o -= 2) {
                var f = o - 1,
                    p = o;
                if (1 === l[f] && 1 === l[p]) {
                    var m = [t[f], null, null, t[p]];
                    0 === t[f].y.cmp(t[p].y) ? (m[1] = t[f].add(t[p]), m[2] = t[f].toJ().mixedAdd(t[p].neg())) : 0 === t[f].y.cmp(t[p].y.redNeg()) ? (m[1] = t[f].toJ().mixedAdd(t[p]), m[2] = t[f].add(t[p].neg())) : (m[1] = t[f].toJ().mixedAdd(t[p]), m[2] = t[f].toJ().mixedAdd(t[p].neg()));
                    var g = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
                        y = Fc(n[f], n[p]);
                    for (d = Math.max(y[0].length, d), c[f] = new Array(d), c[p] = new Array(d), s = 0; s < d; s++) {
                        var v = 0 | y[0][s],
                            b = 0 | y[1][s];
                        c[f][s] = g[3 * (v + 1) + (b + 1)], c[p][s] = 0, u[f] = m
                    }
                } else c[f] = Bc(n[f], l[f], this._bitLength), c[p] = Bc(n[p], l[p], this._bitLength), d = Math.max(c[f].length, d), d = Math.max(c[p].length, d)
            }
            var w = this.jpoint(null, null, null),
                E = this._wnafT4;
            for (o = d; o >= 0; o--) {
                for (var x = 0; o >= 0;) {
                    var A = !0;
                    for (s = 0; s < r; s++) E[s] = 0 | c[s][o], 0 !== E[s] && (A = !1);
                    if (!A) break;
                    x++, o--
                }
                if (o >= 0 && x++, w = w.dblp(x), o < 0) break;
                for (s = 0; s < r; s++) {
                    var k = E[s];
                    0 !== k && (k > 0 ? a = u[s][k - 1 >> 1] : k < 0 && (a = u[s][-k - 1 >> 1].neg()), w = "affine" === a.type ? w.mixedAdd(a) : w.add(a))
                }
            }
            for (o = 0; o < r; o++) u[o] = null;
            return i ? w : w.toP()
        }, Dc.BasePoint = zc, zc.prototype.eq = function() {
            throw new Error("Not implemented")
        }, zc.prototype.validate = function() {
            return this.curve.validate(this)
        }, Dc.prototype.decodePoint = function(e, t) {
            e = Lc.toArray(e, t);
            var n = this.p.byteLength();
            if ((4 === e[0] || 6 === e[0] || 7 === e[0]) && e.length - 1 === 2 * n) return 6 === e[0] ? jc(e[e.length - 1] % 2 === 0) : 7 === e[0] && jc(e[e.length - 1] % 2 === 1), this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
            if ((2 === e[0] || 3 === e[0]) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), 3 === e[0]);
            throw new Error("Unknown point format")
        }, zc.prototype.encodeCompressed = function(e) {
            return this.encode(e, !0)
        }, zc.prototype._encode = function(e) {
            var t = this.curve.p.byteLength(),
                n = this.getX().toArray("be", t);
            return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", t))
        }, zc.prototype.encode = function(e, t) {
            return Lc.encode(this._encode(t), e)
        }, zc.prototype.precompute = function(e) {
            if (this.precomputed) return this;
            var t = {
                doubles: null,
                naf: null,
                beta: null
            };
            return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this
        }, zc.prototype._hasDoubles = function(e) {
            if (!this.precomputed) return !1;
            var t = this.precomputed.doubles;
            return !!t && t.points.length >= Math.ceil((e.bitLength() + 1) / t.step)
        }, zc.prototype._getDoubles = function(e, t) {
            if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
            for (var n = [this], r = this, i = 0; i < t; i += e) {
                for (var o = 0; o < e; o++) r = r.dbl();
                n.push(r)
            }
            return {
                step: e,
                points: n
            }
        }, zc.prototype._getNAFPoints = function(e) {
            if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
            for (var t = [this], n = (1 << e) - 1, r = 1 === n ? null : this.dbl(), i = 1; i < n; i++) t[i] = t[i - 1].add(r);
            return {
                wnd: e,
                points: t
            }
        }, zc.prototype._getBeta = function() {
            return null
        }, zc.prototype.dblp = function(e) {
            for (var t = this, n = 0; n < e; n++) t = t.dbl();
            return t
        };
        var qc = Ic((function(e) {
                "function" === typeof Object.create ? e.exports = function(e, t) {
                    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }))
                } : e.exports = function(e, t) {
                    if (t) {
                        e.super_ = t;
                        var n = function() {};
                        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
                    }
                }
            })),
            Gc = Lc.assert;

        function Hc(e) {
            Uc.call(this, "short", e), this.a = new(su())(e.a, 16).toRed(this.red), this.b = new(su())(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
        }
        qc(Hc, Uc);
        var $c = Hc;

        function Qc(e, t, n, r) {
            Uc.BasePoint.call(this, e, "affine"), null === t && null === n ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new(su())(t, 16), this.y = new(su())(n, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
        }

        function Vc(e, t, n, r) {
            Uc.BasePoint.call(this, e, "jacobian"), null === t && null === n && null === r ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new(su())(0)) : (this.x = new(su())(t, 16), this.y = new(su())(n, 16), this.z = new(su())(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
        }
        Hc.prototype._getEndomorphism = function(e) {
            if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
                var t, n;
                if (e.beta) t = new(su())(e.beta, 16).toRed(this.red);
                else {
                    var r = this._getEndoRoots(this.p);
                    t = (t = r[0].cmp(r[1]) < 0 ? r[0] : r[1]).toRed(this.red)
                }
                if (e.lambda) n = new(su())(e.lambda, 16);
                else {
                    var i = this._getEndoRoots(this.n);
                    0 === this.g.mul(i[0]).x.cmp(this.g.x.redMul(t)) ? n = i[0] : (n = i[1], Gc(0 === this.g.mul(n).x.cmp(this.g.x.redMul(t))))
                }
                return {
                    beta: t,
                    lambda: n,
                    basis: e.basis ? e.basis.map((function(e) {
                        return {
                            a: new(su())(e.a, 16),
                            b: new(su())(e.b, 16)
                        }
                    })) : this._getEndoBasis(n)
                }
            }
        }, Hc.prototype._getEndoRoots = function(e) {
            var t = e === this.p ? this.red : su().mont(e),
                n = new(su())(2).toRed(t).redInvm(),
                r = n.redNeg(),
                i = new(su())(3).toRed(t).redNeg().redSqrt().redMul(n);
            return [r.redAdd(i).fromRed(), r.redSub(i).fromRed()]
        }, Hc.prototype._getEndoBasis = function(e) {
            for (var t, n, r, i, o, s, a, l, u, c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), d = e, h = this.n.clone(), f = new(su())(1), p = new(su())(0), m = new(su())(0), g = new(su())(1), y = 0; 0 !== d.cmpn(0);) {
                var v = h.div(d);
                l = h.sub(v.mul(d)), u = m.sub(v.mul(f));
                var b = g.sub(v.mul(p));
                if (!r && l.cmp(c) < 0) t = a.neg(), n = f, r = l.neg(), i = u;
                else if (r && 2 === ++y) break;
                a = l, h = d, d = l, m = f, f = u, g = p, p = b
            }
            o = l.neg(), s = u;
            var w = r.sqr().add(i.sqr());
            return o.sqr().add(s.sqr()).cmp(w) >= 0 && (o = t, s = n), r.negative && (r = r.neg(), i = i.neg()), o.negative && (o = o.neg(), s = s.neg()), [{
                a: r,
                b: i
            }, {
                a: o,
                b: s
            }]
        }, Hc.prototype._endoSplit = function(e) {
            var t = this.endo.basis,
                n = t[0],
                r = t[1],
                i = r.b.mul(e).divRound(this.n),
                o = n.b.neg().mul(e).divRound(this.n),
                s = i.mul(n.a),
                a = o.mul(r.a),
                l = i.mul(n.b),
                u = o.mul(r.b);
            return {
                k1: e.sub(s).sub(a),
                k2: l.add(u).neg()
            }
        }, Hc.prototype.pointFromX = function(e, t) {
            (e = new(su())(e, 16)).red || (e = e.toRed(this.red));
            var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
                r = n.redSqrt();
            if (0 !== r.redSqr().redSub(n).cmp(this.zero)) throw new Error("invalid point");
            var i = r.fromRed().isOdd();
            return (t && !i || !t && i) && (r = r.redNeg()), this.point(e, r)
        }, Hc.prototype.validate = function(e) {
            if (e.inf) return !0;
            var t = e.x,
                n = e.y,
                r = this.a.redMul(t),
                i = t.redSqr().redMul(t).redIAdd(r).redIAdd(this.b);
            return 0 === n.redSqr().redISub(i).cmpn(0)
        }, Hc.prototype._endoWnafMulAdd = function(e, t, n) {
            for (var r = this._endoWnafT1, i = this._endoWnafT2, o = 0; o < e.length; o++) {
                var s = this._endoSplit(t[o]),
                    a = e[o],
                    l = a._getBeta();
                s.k1.negative && (s.k1.ineg(), a = a.neg(!0)), s.k2.negative && (s.k2.ineg(), l = l.neg(!0)), r[2 * o] = a, r[2 * o + 1] = l, i[2 * o] = s.k1, i[2 * o + 1] = s.k2
            }
            for (var u = this._wnafMulAdd(1, r, i, 2 * o, n), c = 0; c < 2 * o; c++) r[c] = null, i[c] = null;
            return u
        }, qc(Qc, Uc.BasePoint), Hc.prototype.point = function(e, t, n) {
            return new Qc(this, e, t, n)
        }, Hc.prototype.pointFromJSON = function(e, t) {
            return Qc.fromJSON(this, e, t)
        }, Qc.prototype._getBeta = function() {
            if (this.curve.endo) {
                var e = this.precomputed;
                if (e && e.beta) return e.beta;
                var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                if (e) {
                    var n = this.curve,
                        r = function(e) {
                            return n.point(e.x.redMul(n.endo.beta), e.y)
                        };
                    e.beta = t, t.precomputed = {
                        beta: null,
                        naf: e.naf && {
                            wnd: e.naf.wnd,
                            points: e.naf.points.map(r)
                        },
                        doubles: e.doubles && {
                            step: e.doubles.step,
                            points: e.doubles.points.map(r)
                        }
                    }
                }
                return t
            }
        }, Qc.prototype.toJSON = function() {
            return this.precomputed ? [this.x, this.y, this.precomputed && {
                doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                },
                naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                }
            }] : [this.x, this.y]
        }, Qc.fromJSON = function(e, t, n) {
            "string" === typeof t && (t = JSON.parse(t));
            var r = e.point(t[0], t[1], n);
            if (!t[2]) return r;

            function i(t) {
                return e.point(t[0], t[1], n)
            }
            var o = t[2];
            return r.precomputed = {
                beta: null,
                doubles: o.doubles && {
                    step: o.doubles.step,
                    points: [r].concat(o.doubles.points.map(i))
                },
                naf: o.naf && {
                    wnd: o.naf.wnd,
                    points: [r].concat(o.naf.points.map(i))
                }
            }, r
        }, Qc.prototype.inspect = function() {
            return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
        }, Qc.prototype.isInfinity = function() {
            return this.inf
        }, Qc.prototype.add = function(e) {
            if (this.inf) return e;
            if (e.inf) return this;
            if (this.eq(e)) return this.dbl();
            if (this.neg().eq(e)) return this.curve.point(null, null);
            if (0 === this.x.cmp(e.x)) return this.curve.point(null, null);
            var t = this.y.redSub(e.y);
            0 !== t.cmpn(0) && (t = t.redMul(this.x.redSub(e.x).redInvm()));
            var n = t.redSqr().redISub(this.x).redISub(e.x),
                r = t.redMul(this.x.redSub(n)).redISub(this.y);
            return this.curve.point(n, r)
        }, Qc.prototype.dbl = function() {
            if (this.inf) return this;
            var e = this.y.redAdd(this.y);
            if (0 === e.cmpn(0)) return this.curve.point(null, null);
            var t = this.curve.a,
                n = this.x.redSqr(),
                r = e.redInvm(),
                i = n.redAdd(n).redIAdd(n).redIAdd(t).redMul(r),
                o = i.redSqr().redISub(this.x.redAdd(this.x)),
                s = i.redMul(this.x.redSub(o)).redISub(this.y);
            return this.curve.point(o, s)
        }, Qc.prototype.getX = function() {
            return this.x.fromRed()
        }, Qc.prototype.getY = function() {
            return this.y.fromRed()
        }, Qc.prototype.mul = function(e) {
            return e = new(su())(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
        }, Qc.prototype.mulAdd = function(e, t, n) {
            var r = [this, t],
                i = [e, n];
            return this.curve.endo ? this.curve._endoWnafMulAdd(r, i) : this.curve._wnafMulAdd(1, r, i, 2)
        }, Qc.prototype.jmulAdd = function(e, t, n) {
            var r = [this, t],
                i = [e, n];
            return this.curve.endo ? this.curve._endoWnafMulAdd(r, i, !0) : this.curve._wnafMulAdd(1, r, i, 2, !0)
        }, Qc.prototype.eq = function(e) {
            return this === e || this.inf === e.inf && (this.inf || 0 === this.x.cmp(e.x) && 0 === this.y.cmp(e.y))
        }, Qc.prototype.neg = function(e) {
            if (this.inf) return this;
            var t = this.curve.point(this.x, this.y.redNeg());
            if (e && this.precomputed) {
                var n = this.precomputed,
                    r = function(e) {
                        return e.neg()
                    };
                t.precomputed = {
                    naf: n.naf && {
                        wnd: n.naf.wnd,
                        points: n.naf.points.map(r)
                    },
                    doubles: n.doubles && {
                        step: n.doubles.step,
                        points: n.doubles.points.map(r)
                    }
                }
            }
            return t
        }, Qc.prototype.toJ = function() {
            return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one)
        }, qc(Vc, Uc.BasePoint), Hc.prototype.jpoint = function(e, t, n) {
            return new Vc(this, e, t, n)
        }, Vc.prototype.toP = function() {
            if (this.isInfinity()) return this.curve.point(null, null);
            var e = this.z.redInvm(),
                t = e.redSqr(),
                n = this.x.redMul(t),
                r = this.y.redMul(t).redMul(e);
            return this.curve.point(n, r)
        }, Vc.prototype.neg = function() {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
        }, Vc.prototype.add = function(e) {
            if (this.isInfinity()) return e;
            if (e.isInfinity()) return this;
            var t = e.z.redSqr(),
                n = this.z.redSqr(),
                r = this.x.redMul(t),
                i = e.x.redMul(n),
                o = this.y.redMul(t.redMul(e.z)),
                s = e.y.redMul(n.redMul(this.z)),
                a = r.redSub(i),
                l = o.redSub(s);
            if (0 === a.cmpn(0)) return 0 !== l.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
            var u = a.redSqr(),
                c = u.redMul(a),
                d = r.redMul(u),
                h = l.redSqr().redIAdd(c).redISub(d).redISub(d),
                f = l.redMul(d.redISub(h)).redISub(o.redMul(c)),
                p = this.z.redMul(e.z).redMul(a);
            return this.curve.jpoint(h, f, p)
        }, Vc.prototype.mixedAdd = function(e) {
            if (this.isInfinity()) return e.toJ();
            if (e.isInfinity()) return this;
            var t = this.z.redSqr(),
                n = this.x,
                r = e.x.redMul(t),
                i = this.y,
                o = e.y.redMul(t).redMul(this.z),
                s = n.redSub(r),
                a = i.redSub(o);
            if (0 === s.cmpn(0)) return 0 !== a.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
            var l = s.redSqr(),
                u = l.redMul(s),
                c = n.redMul(l),
                d = a.redSqr().redIAdd(u).redISub(c).redISub(c),
                h = a.redMul(c.redISub(d)).redISub(i.redMul(u)),
                f = this.z.redMul(s);
            return this.curve.jpoint(d, h, f)
        }, Vc.prototype.dblp = function(e) {
            if (0 === e) return this;
            if (this.isInfinity()) return this;
            if (!e) return this.dbl();
            var t;
            if (this.curve.zeroA || this.curve.threeA) {
                var n = this;
                for (t = 0; t < e; t++) n = n.dbl();
                return n
            }
            var r = this.curve.a,
                i = this.curve.tinv,
                o = this.x,
                s = this.y,
                a = this.z,
                l = a.redSqr().redSqr(),
                u = s.redAdd(s);
            for (t = 0; t < e; t++) {
                var c = o.redSqr(),
                    d = u.redSqr(),
                    h = d.redSqr(),
                    f = c.redAdd(c).redIAdd(c).redIAdd(r.redMul(l)),
                    p = o.redMul(d),
                    m = f.redSqr().redISub(p.redAdd(p)),
                    g = p.redISub(m),
                    y = f.redMul(g);
                y = y.redIAdd(y).redISub(h);
                var v = u.redMul(a);
                t + 1 < e && (l = l.redMul(h)), o = m, a = v, u = y
            }
            return this.curve.jpoint(o, u.redMul(i), a)
        }, Vc.prototype.dbl = function() {
            return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
        }, Vc.prototype._zeroDbl = function() {
            var e, t, n;
            if (this.zOne) {
                var r = this.x.redSqr(),
                    i = this.y.redSqr(),
                    o = i.redSqr(),
                    s = this.x.redAdd(i).redSqr().redISub(r).redISub(o);
                s = s.redIAdd(s);
                var a = r.redAdd(r).redIAdd(r),
                    l = a.redSqr().redISub(s).redISub(s),
                    u = o.redIAdd(o);
                u = (u = u.redIAdd(u)).redIAdd(u), e = l, t = a.redMul(s.redISub(l)).redISub(u), n = this.y.redAdd(this.y)
            } else {
                var c = this.x.redSqr(),
                    d = this.y.redSqr(),
                    h = d.redSqr(),
                    f = this.x.redAdd(d).redSqr().redISub(c).redISub(h);
                f = f.redIAdd(f);
                var p = c.redAdd(c).redIAdd(c),
                    m = p.redSqr(),
                    g = h.redIAdd(h);
                g = (g = g.redIAdd(g)).redIAdd(g), e = m.redISub(f).redISub(f), t = p.redMul(f.redISub(e)).redISub(g), n = (n = this.y.redMul(this.z)).redIAdd(n)
            }
            return this.curve.jpoint(e, t, n)
        }, Vc.prototype._threeDbl = function() {
            var e, t, n;
            if (this.zOne) {
                var r = this.x.redSqr(),
                    i = this.y.redSqr(),
                    o = i.redSqr(),
                    s = this.x.redAdd(i).redSqr().redISub(r).redISub(o);
                s = s.redIAdd(s);
                var a = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a),
                    l = a.redSqr().redISub(s).redISub(s);
                e = l;
                var u = o.redIAdd(o);
                u = (u = u.redIAdd(u)).redIAdd(u), t = a.redMul(s.redISub(l)).redISub(u), n = this.y.redAdd(this.y)
            } else {
                var c = this.z.redSqr(),
                    d = this.y.redSqr(),
                    h = this.x.redMul(d),
                    f = this.x.redSub(c).redMul(this.x.redAdd(c));
                f = f.redAdd(f).redIAdd(f);
                var p = h.redIAdd(h),
                    m = (p = p.redIAdd(p)).redAdd(p);
                e = f.redSqr().redISub(m), n = this.y.redAdd(this.z).redSqr().redISub(d).redISub(c);
                var g = d.redSqr();
                g = (g = (g = g.redIAdd(g)).redIAdd(g)).redIAdd(g), t = f.redMul(p.redISub(e)).redISub(g)
            }
            return this.curve.jpoint(e, t, n)
        }, Vc.prototype._dbl = function() {
            var e = this.curve.a,
                t = this.x,
                n = this.y,
                r = this.z,
                i = r.redSqr().redSqr(),
                o = t.redSqr(),
                s = n.redSqr(),
                a = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(i)),
                l = t.redAdd(t),
                u = (l = l.redIAdd(l)).redMul(s),
                c = a.redSqr().redISub(u.redAdd(u)),
                d = u.redISub(c),
                h = s.redSqr();
            h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
            var f = a.redMul(d).redISub(h),
                p = n.redAdd(n).redMul(r);
            return this.curve.jpoint(c, f, p)
        }, Vc.prototype.trpl = function() {
            if (!this.curve.zeroA) return this.dbl().add(this);
            var e = this.x.redSqr(),
                t = this.y.redSqr(),
                n = this.z.redSqr(),
                r = t.redSqr(),
                i = e.redAdd(e).redIAdd(e),
                o = i.redSqr(),
                s = this.x.redAdd(t).redSqr().redISub(e).redISub(r),
                a = (s = (s = (s = s.redIAdd(s)).redAdd(s).redIAdd(s)).redISub(o)).redSqr(),
                l = r.redIAdd(r);
            l = (l = (l = l.redIAdd(l)).redIAdd(l)).redIAdd(l);
            var u = i.redIAdd(s).redSqr().redISub(o).redISub(a).redISub(l),
                c = t.redMul(u);
            c = (c = c.redIAdd(c)).redIAdd(c);
            var d = this.x.redMul(a).redISub(c);
            d = (d = d.redIAdd(d)).redIAdd(d);
            var h = this.y.redMul(u.redMul(l.redISub(u)).redISub(s.redMul(a)));
            h = (h = (h = h.redIAdd(h)).redIAdd(h)).redIAdd(h);
            var f = this.z.redAdd(s).redSqr().redISub(n).redISub(a);
            return this.curve.jpoint(d, h, f)
        }, Vc.prototype.mul = function(e, t) {
            return e = new(su())(e, t), this.curve._wnafMul(this, e)
        }, Vc.prototype.eq = function(e) {
            if ("affine" === e.type) return this.eq(e.toJ());
            if (this === e) return !0;
            var t = this.z.redSqr(),
                n = e.z.redSqr();
            if (0 !== this.x.redMul(n).redISub(e.x.redMul(t)).cmpn(0)) return !1;
            var r = t.redMul(this.z),
                i = n.redMul(e.z);
            return 0 === this.y.redMul(i).redISub(e.y.redMul(r)).cmpn(0)
        }, Vc.prototype.eqXToP = function(e) {
            var t = this.z.redSqr(),
                n = e.toRed(this.curve.red).redMul(t);
            if (0 === this.x.cmp(n)) return !0;
            for (var r = e.clone(), i = this.curve.redN.redMul(t);;) {
                if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
                if (n.redIAdd(i), 0 === this.x.cmp(n)) return !0
            }
        }, Vc.prototype.inspect = function() {
            return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
        }, Vc.prototype.isInfinity = function() {
            return 0 === this.z.cmpn(0)
        };
        var Kc = Ic((function(e, t) {
                var n = t;
                n.base = Uc, n.short = $c, n.mont = null, n.edwards = null
            })),
            Wc = Ic((function(e, t) {
                var n, r = t,
                    i = Lc.assert;

                function o(e) {
                    "short" === e.type ? this.curve = new Kc.short(e) : "edwards" === e.type ? this.curve = new Kc.edwards(e) : this.curve = new Kc.mont(e), this.g = this.curve.g, this.n = this.curve.n, this.hash = e.hash, i(this.g.validate(), "Invalid curve"), i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
                }

                function s(e, t) {
                    Object.defineProperty(r, e, {
                        configurable: !0,
                        enumerable: !0,
                        get: function() {
                            var n = new o(t);
                            return Object.defineProperty(r, e, {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            }), n
                        }
                    })
                }
                r.PresetCurve = o, s("p192", {
                    type: "short",
                    prime: "p192",
                    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
                    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
                    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
                    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
                    hash: Mc().sha256,
                    gRed: !1,
                    g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
                }), s("p224", {
                    type: "short",
                    prime: "p224",
                    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
                    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
                    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
                    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
                    hash: Mc().sha256,
                    gRed: !1,
                    g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
                }), s("p256", {
                    type: "short",
                    prime: null,
                    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
                    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
                    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
                    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
                    hash: Mc().sha256,
                    gRed: !1,
                    g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
                }), s("p384", {
                    type: "short",
                    prime: null,
                    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
                    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
                    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
                    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
                    hash: Mc().sha384,
                    gRed: !1,
                    g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
                }), s("p521", {
                    type: "short",
                    prime: null,
                    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
                    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
                    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
                    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
                    hash: Mc().sha512,
                    gRed: !1,
                    g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
                }), s("curve25519", {
                    type: "mont",
                    prime: "p25519",
                    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                    a: "76d06",
                    b: "1",
                    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                    hash: Mc().sha256,
                    gRed: !1,
                    g: ["9"]
                }), s("ed25519", {
                    type: "edwards",
                    prime: "p25519",
                    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
                    a: "-1",
                    c: "1",
                    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
                    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
                    hash: Mc().sha256,
                    gRed: !1,
                    g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
                });
                try {
                    n = null.crash()
                } catch (dg) {
                    n = void 0
                }
                s("secp256k1", {
                    type: "short",
                    prime: "k256",
                    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
                    a: "0",
                    b: "7",
                    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
                    h: "1",
                    hash: Mc().sha256,
                    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
                    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
                    basis: [{
                        a: "3086d221a7d46bcde86c90e49284eb15",
                        b: "-e4437ed6010e88286f547fa90abfe4c3"
                    }, {
                        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                        b: "3086d221a7d46bcde86c90e49284eb15"
                    }],
                    gRed: !1,
                    g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n]
                })
            }));

        function Jc(e) {
            if (!(this instanceof Jc)) return new Jc(e);
            this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
            var t = Rc.toArray(e.entropy, e.entropyEnc || "hex"),
                n = Rc.toArray(e.nonce, e.nonceEnc || "hex"),
                r = Rc.toArray(e.pers, e.persEnc || "hex");
            Oc(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, n, r)
        }
        var Zc = Jc;
        Jc.prototype._init = function(e, t, n) {
            var r = e.concat(t).concat(n);
            this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
            for (var i = 0; i < this.V.length; i++) this.K[i] = 0, this.V[i] = 1;
            this._update(r), this._reseed = 1, this.reseedInterval = 281474976710656
        }, Jc.prototype._hmac = function() {
            return new(Mc().hmac)(this.hash, this.K)
        }, Jc.prototype._update = function(e) {
            var t = this._hmac().update(this.V).update([0]);
            e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
        }, Jc.prototype.reseed = function(e, t, n, r) {
            "string" !== typeof t && (r = n, n = t, t = null), e = Rc.toArray(e, t), n = Rc.toArray(n, r), Oc(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1
        }, Jc.prototype.generate = function(e, t, n, r) {
            if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
            "string" !== typeof t && (r = n, n = t, t = null), n && (n = Rc.toArray(n, r || "hex"), this._update(n));
            for (var i = []; i.length < e;) this.V = this._hmac().update(this.V).digest(), i = i.concat(this.V);
            var o = i.slice(0, e);
            return this._update(n), this._reseed++, Rc.encode(o, t)
        };
        var Yc = Lc.assert;

        function Xc(e, t) {
            this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc)
        }
        var ed = Xc;
        Xc.fromPublic = function(e, t, n) {
            return t instanceof Xc ? t : new Xc(e, {
                pub: t,
                pubEnc: n
            })
        }, Xc.fromPrivate = function(e, t, n) {
            return t instanceof Xc ? t : new Xc(e, {
                priv: t,
                privEnc: n
            })
        }, Xc.prototype.validate = function() {
            var e = this.getPublic();
            return e.isInfinity() ? {
                result: !1,
                reason: "Invalid public key"
            } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
                result: !0,
                reason: null
            } : {
                result: !1,
                reason: "Public key * N != O"
            } : {
                result: !1,
                reason: "Public key is not a point"
            }
        }, Xc.prototype.getPublic = function(e, t) {
            return "string" === typeof e && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub
        }, Xc.prototype.getPrivate = function(e) {
            return "hex" === e ? this.priv.toString(16, 2) : this.priv
        }, Xc.prototype._importPrivate = function(e, t) {
            this.priv = new(su())(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n)
        }, Xc.prototype._importPublic = function(e, t) {
            if (e.x || e.y) return "mont" === this.ec.curve.type ? Yc(e.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || Yc(e.x && e.y, "Need both x and y coordinate"), void(this.pub = this.ec.curve.point(e.x, e.y));
            this.pub = this.ec.curve.decodePoint(e, t)
        }, Xc.prototype.derive = function(e) {
            return e.validate() || Yc(e.validate(), "public point not validated"), e.mul(this.priv).getX()
        }, Xc.prototype.sign = function(e, t, n) {
            return this.ec.sign(e, this, t, n)
        }, Xc.prototype.verify = function(e, t) {
            return this.ec.verify(e, t, this)
        }, Xc.prototype.inspect = function() {
            return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
        };
        var td = Lc.assert;

        function nd(e, t) {
            if (e instanceof nd) return e;
            this._importDER(e, t) || (td(e.r && e.s, "Signature without r or s"), this.r = new(su())(e.r, 16), this.s = new(su())(e.s, 16), void 0 === e.recoveryParam ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam)
        }
        var rd = nd;

        function id() {
            this.place = 0
        }

        function od(e, t) {
            var n = e[t.place++];
            if (!(128 & n)) return n;
            var r = 15 & n;
            if (0 === r || r > 4) return !1;
            for (var i = 0, o = 0, s = t.place; o < r; o++, s++) i <<= 8, i |= e[s], i >>>= 0;
            return !(i <= 127) && (t.place = s, i)
        }

        function sd(e) {
            for (var t = 0, n = e.length - 1; !e[t] && !(128 & e[t + 1]) && t < n;) t++;
            return 0 === t ? e : e.slice(t)
        }

        function ad(e, t) {
            if (t < 128) e.push(t);
            else {
                var n = 1 + (Math.log(t) / Math.LN2 >>> 3);
                for (e.push(128 | n); --n;) e.push(t >>> (n << 3) & 255);
                e.push(t)
            }
        }
        nd.prototype._importDER = function(e, t) {
            e = Lc.toArray(e, t);
            var n = new id;
            if (48 !== e[n.place++]) return !1;
            var r = od(e, n);
            if (!1 === r) return !1;
            if (r + n.place !== e.length) return !1;
            if (2 !== e[n.place++]) return !1;
            var i = od(e, n);
            if (!1 === i) return !1;
            var o = e.slice(n.place, i + n.place);
            if (n.place += i, 2 !== e[n.place++]) return !1;
            var s = od(e, n);
            if (!1 === s) return !1;
            if (e.length !== s + n.place) return !1;
            var a = e.slice(n.place, s + n.place);
            if (0 === o[0]) {
                if (!(128 & o[1])) return !1;
                o = o.slice(1)
            }
            if (0 === a[0]) {
                if (!(128 & a[1])) return !1;
                a = a.slice(1)
            }
            return this.r = new(su())(o), this.s = new(su())(a), this.recoveryParam = null, !0
        }, nd.prototype.toDER = function(e) {
            var t = this.r.toArray(),
                n = this.s.toArray();
            for (128 & t[0] && (t = [0].concat(t)), 128 & n[0] && (n = [0].concat(n)), t = sd(t), n = sd(n); !n[0] && !(128 & n[1]);) n = n.slice(1);
            var r = [2];
            ad(r, t.length), (r = r.concat(t)).push(2), ad(r, n.length);
            var i = r.concat(n),
                o = [48];
            return ad(o, i.length), o = o.concat(i), Lc.encode(o, e)
        };
        var ld = function() {
                throw new Error("unsupported")
            },
            ud = Lc.assert;

        function cd(e) {
            if (!(this instanceof cd)) return new cd(e);
            "string" === typeof e && (ud(Object.prototype.hasOwnProperty.call(Wc, e), "Unknown curve " + e), e = Wc[e]), e instanceof Wc.PresetCurve && (e = {
                curve: e
            }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash
        }
        var dd = cd;
        cd.prototype.keyPair = function(e) {
            return new ed(this, e)
        }, cd.prototype.keyFromPrivate = function(e, t) {
            return ed.fromPrivate(this, e, t)
        }, cd.prototype.keyFromPublic = function(e, t) {
            return ed.fromPublic(this, e, t)
        }, cd.prototype.genKeyPair = function(e) {
            e || (e = {});
            for (var t = new Zc({
                    hash: this.hash,
                    pers: e.pers,
                    persEnc: e.persEnc || "utf8",
                    entropy: e.entropy || ld(this.hash.hmacStrength),
                    entropyEnc: e.entropy && e.entropyEnc || "utf8",
                    nonce: this.n.toArray()
                }), n = this.n.byteLength(), r = this.n.sub(new(su())(2));;) {
                var i = new(su())(t.generate(n));
                if (!(i.cmp(r) > 0)) return i.iaddn(1), this.keyFromPrivate(i)
            }
        }, cd.prototype._truncateToN = function(e, t) {
            var n = 8 * e.byteLength() - this.n.bitLength();
            return n > 0 && (e = e.ushrn(n)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
        }, cd.prototype.sign = function(e, t, n, r) {
            "object" === typeof n && (r = n, n = null), r || (r = {}), t = this.keyFromPrivate(t, n), e = this._truncateToN(new(su())(e, 16));
            for (var i = this.n.byteLength(), o = t.getPrivate().toArray("be", i), s = e.toArray("be", i), a = new Zc({
                    hash: this.hash,
                    entropy: o,
                    nonce: s,
                    pers: r.pers,
                    persEnc: r.persEnc || "utf8"
                }), l = this.n.sub(new(su())(1)), u = 0;; u++) {
                var c = r.k ? r.k(u) : new(su())(a.generate(this.n.byteLength()));
                if (!((c = this._truncateToN(c, !0)).cmpn(1) <= 0 || c.cmp(l) >= 0)) {
                    var d = this.g.mul(c);
                    if (!d.isInfinity()) {
                        var h = d.getX(),
                            f = h.umod(this.n);
                        if (0 !== f.cmpn(0)) {
                            var p = c.invm(this.n).mul(f.mul(t.getPrivate()).iadd(e));
                            if (0 !== (p = p.umod(this.n)).cmpn(0)) {
                                var m = (d.getY().isOdd() ? 1 : 0) | (0 !== h.cmp(f) ? 2 : 0);
                                return r.canonical && p.cmp(this.nh) > 0 && (p = this.n.sub(p), m ^= 1), new rd({
                                    r: f,
                                    s: p,
                                    recoveryParam: m
                                })
                            }
                        }
                    }
                }
            }
        }, cd.prototype.verify = function(e, t, n, r) {
            e = this._truncateToN(new(su())(e, 16)), n = this.keyFromPublic(n, r);
            var i = (t = new rd(t, "hex")).r,
                o = t.s;
            if (i.cmpn(1) < 0 || i.cmp(this.n) >= 0) return !1;
            if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
            var s, a = o.invm(this.n),
                l = a.mul(e).umod(this.n),
                u = a.mul(i).umod(this.n);
            return this.curve._maxwellTrick ? !(s = this.g.jmulAdd(l, n.getPublic(), u)).isInfinity() && s.eqXToP(i) : !(s = this.g.mulAdd(l, n.getPublic(), u)).isInfinity() && 0 === s.getX().umod(this.n).cmp(i)
        }, cd.prototype.recoverPubKey = function(e, t, n, r) {
            ud((3 & n) === n, "The recovery param is more than two bits"), t = new rd(t, r);
            var i = this.n,
                o = new(su())(e),
                s = t.r,
                a = t.s,
                l = 1 & n,
                u = n >> 1;
            if (s.cmp(this.curve.p.umod(this.curve.n)) >= 0 && u) throw new Error("Unable to find sencond key candinate");
            s = u ? this.curve.pointFromX(s.add(this.curve.n), l) : this.curve.pointFromX(s, l);
            var c = t.r.invm(i),
                d = i.sub(o).mul(c).umod(i),
                h = a.mul(c).umod(i);
            return this.g.mulAdd(d, s, h)
        }, cd.prototype.getKeyRecoveryParam = function(e, t, n, r) {
            if (null !== (t = new rd(t, r)).recoveryParam) return t.recoveryParam;
            for (var i = 0; i < 4; i++) {
                var o;
                try {
                    o = this.recoverPubKey(e, t, i)
                } catch (e) {
                    continue
                }
                if (o.eq(n)) return i
            }
            throw new Error("Unable to find valid recovery factor")
        };
        var hd = Ic((function(e, t) {
            var n = t;
            n.version = "6.5.4", n.utils = Lc, n.rand = function() {
                throw new Error("unsupported")
            }, n.curve = Kc, n.curves = Wc, n.ec = dd, n.eddsa = null
        })).ec;
        const fd = new zl("signing-key/5.7.0");
        let pd = null;

        function md() {
            return pd || (pd = new hd("secp256k1")), pd
        }
        class gd {
            constructor(e) {
                Hl(this, "curve", "secp256k1"), Hl(this, "privateKey", vu(e)), 32 !== bu(this.privateKey) && fd.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
                const t = md().keyFromPrivate(fu(this.privateKey));
                Hl(this, "publicKey", "0x" + t.getPublic(!1, "hex")), Hl(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")), Hl(this, "_isSigningKey", !0)
            }
            _addPoint(e) {
                const t = md().keyFromPublic(fu(this.publicKey)),
                    n = md().keyFromPublic(fu(e));
                return "0x" + t.pub.add(n.pub).encodeCompressed("hex")
            }
            signDigest(e) {
                const t = md().keyFromPrivate(fu(this.privateKey)),
                    n = fu(e);
                32 !== n.length && fd.throwArgumentError("bad digest length", "digest", e);
                const r = t.sign(n, {
                    canonical: !0
                });
                return ku({
                    recoveryParam: r.recoveryParam,
                    r: Au("0x" + r.r.toString(16), 32),
                    s: Au("0x" + r.s.toString(16), 32)
                })
            }
            computeSharedSecret(e) {
                const t = md().keyFromPrivate(fu(this.privateKey)),
                    n = md().keyFromPublic(fu(yd(e)));
                return Au("0x" + t.derive(n.getPublic()).toString(16), 32)
            }
            static isSigningKey(e) {
                return !(!e || !e._isSigningKey)
            }
        }

        function yd(e, t) {
            const n = fu(e);
            if (32 === n.length) {
                const e = new gd(n);
                return t ? "0x" + md().keyFromPrivate(n).getPublic(!0, "hex") : e.publicKey
            }
            return 33 === n.length ? t ? vu(n) : "0x" + md().keyFromPublic(n).getPublic(!1, "hex") : 65 === n.length ? t ? "0x" + md().keyFromPublic(n).getPublic(!0, "hex") : vu(n) : fd.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
        }
        const vd = new zl("transactions/5.7.0");
        var bd;

        function wd(e) {
            return "0x" === e ? null : Zu(e)
        }

        function Ed(e) {
            return "0x" === e ? Pc : Mu.from(e)
        }! function(e) {
            e[e.legacy = 0] = "legacy", e[e.eip2930 = 1] = "eip2930", e[e.eip1559 = 2] = "eip1559"
        }(bd || (bd = {}));

        function xd(e, t) {
            return function(e) {
                return Zu(wu(Fu(wu(yd(e), 1)), 12))
            }(function(e, t) {
                const n = ku(t),
                    r = {
                        r: fu(n.r),
                        s: fu(n.s)
                    };
                return "0x" + md().recoverPubKey(fu(e), r, n.recoveryParam).encode("hex", !1)
            }(fu(e), t))
        }

        function Ad(e, t) {
            const n = mu(Mu.from(e).toHexString());
            return n.length > 32 && vd.throwArgumentError("invalid length for " + t, "transaction:" + t, e), n
        }

        function kd(e, t) {
            return {
                address: Zu(e),
                storageKeys: (t || []).map(((t, n) => (32 !== bu(t) && vd.throwArgumentError("invalid access list storageKey", `accessList[${e}:${n}]`, t), t.toLowerCase())))
            }
        }

        function Cd(e) {
            if (Array.isArray(e)) return e.map(((e, t) => Array.isArray(e) ? (e.length > 2 && vd.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${t}]`, e), kd(e[0], e[1])) : kd(e.address, e.storageKeys)));
            const t = Object.keys(e).map((t => {
                const n = e[t].reduce(((e, t) => (e[t] = !0, e)), {});
                return kd(t, Object.keys(n).sort())
            }));
            return t.sort(((e, t) => e.address.localeCompare(t.address))), t
        }

        function Pd(e) {
            return Cd(e).map((e => [e.address, e.storageKeys]))
        }

        function Sd(e, t) {
            if (null != e.gasPrice) {
                const t = Mu.from(e.gasPrice),
                    n = Mu.from(e.maxFeePerGas || 0);
                t.eq(n) || vd.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                    gasPrice: t,
                    maxFeePerGas: n
                })
            }
            const n = [Ad(e.chainId || 0, "chainId"), Ad(e.nonce || 0, "nonce"), Ad(e.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), Ad(e.maxFeePerGas || 0, "maxFeePerGas"), Ad(e.gasLimit || 0, "gasLimit"), null != e.to ? Zu(e.to) : "0x", Ad(e.value || 0, "value"), e.data || "0x", Pd(e.accessList || [])];
            if (t) {
                const e = ku(t);
                n.push(Ad(e.recoveryParam, "recoveryParam")), n.push(mu(e.r)), n.push(mu(e.s))
            }
            return Eu(["0x02", qu(n)])
        }

        function _d(e, t) {
            const n = [Ad(e.chainId || 0, "chainId"), Ad(e.nonce || 0, "nonce"), Ad(e.gasPrice || 0, "gasPrice"), Ad(e.gasLimit || 0, "gasLimit"), null != e.to ? Zu(e.to) : "0x", Ad(e.value || 0, "value"), e.data || "0x", Pd(e.accessList || [])];
            if (t) {
                const e = ku(t);
                n.push(Ad(e.recoveryParam, "recoveryParam")), n.push(mu(e.r)), n.push(mu(e.s))
            }
            return Eu(["0x01", qu(n)])
        }

        function Nd(e, t, n) {
            try {
                const n = Ed(t[0]).toNumber();
                if (0 !== n && 1 !== n) throw new Error("bad recid");
                e.v = n
            } catch (r) {
                vd.throwArgumentError("invalid v for transaction type: 1", "v", t[0])
            }
            e.r = Au(t[1], 32), e.s = Au(t[2], 32);
            try {
                const t = Fu(n(e));
                e.from = xd(t, {
                    r: e.r,
                    s: e.s,
                    recoveryParam: e.v
                })
            } catch (r) {}
        }

        function Md(e) {
            const t = fu(e);
            if (t[0] > 127) return function(e) {
                const t = $u(e);
                9 !== t.length && 6 !== t.length && vd.throwArgumentError("invalid raw transaction", "rawTransaction", e);
                const n = {
                    nonce: Ed(t[0]).toNumber(),
                    gasPrice: Ed(t[1]),
                    gasLimit: Ed(t[2]),
                    to: wd(t[3]),
                    value: Ed(t[4]),
                    data: t[5],
                    chainId: 0
                };
                if (6 === t.length) return n;
                try {
                    n.v = Mu.from(t[6]).toNumber()
                } catch (r) {
                    return n
                }
                if (n.r = Au(t[7], 32), n.s = Au(t[8], 32), Mu.from(n.r).isZero() && Mu.from(n.s).isZero()) n.chainId = n.v, n.v = 0;
                else {
                    n.chainId = Math.floor((n.v - 35) / 2), n.chainId < 0 && (n.chainId = 0);
                    let i = n.v - 27;
                    const o = t.slice(0, 6);
                    0 !== n.chainId && (o.push(vu(n.chainId)), o.push("0x"), o.push("0x"), i -= 2 * n.chainId + 8);
                    const s = Fu(qu(o));
                    try {
                        n.from = xd(s, {
                            r: vu(n.r),
                            s: vu(n.s),
                            recoveryParam: i
                        })
                    } catch (r) {}
                    n.hash = Fu(e)
                }
                return n.type = null, n
            }(t);
            switch (t[0]) {
                case 1:
                    return function(e) {
                        const t = $u(e.slice(1));
                        8 !== t.length && 11 !== t.length && vd.throwArgumentError("invalid component count for transaction type: 1", "payload", vu(e));
                        const n = {
                            type: 1,
                            chainId: Ed(t[0]).toNumber(),
                            nonce: Ed(t[1]).toNumber(),
                            gasPrice: Ed(t[2]),
                            gasLimit: Ed(t[3]),
                            to: wd(t[4]),
                            value: Ed(t[5]),
                            data: t[6],
                            accessList: Cd(t[7])
                        };
                        return 8 === t.length || (n.hash = Fu(e), Nd(n, t.slice(8), _d)), n
                    }(t);
                case 2:
                    return function(e) {
                        const t = $u(e.slice(1));
                        9 !== t.length && 12 !== t.length && vd.throwArgumentError("invalid component count for transaction type: 2", "payload", vu(e));
                        const n = Ed(t[2]),
                            r = Ed(t[3]),
                            i = {
                                type: 2,
                                chainId: Ed(t[0]).toNumber(),
                                nonce: Ed(t[1]).toNumber(),
                                maxPriorityFeePerGas: n,
                                maxFeePerGas: r,
                                gasPrice: null,
                                gasLimit: Ed(t[4]),
                                to: wd(t[5]),
                                value: Ed(t[6]),
                                data: t[7],
                                accessList: Cd(t[8])
                            };
                        return 9 === t.length || (i.hash = Fu(e), Nd(i, t.slice(9), Sd)), i
                    }(t)
            }
            return vd.throwError(`unsupported transaction type: ${t[0]}`, zl.errors.UNSUPPORTED_OPERATION, {
                operation: "parseTransaction",
                transactionType: t[0]
            })
        }

        function Id(e) {
            e = atob(e);
            const t = [];
            for (let n = 0; n < e.length; n++) t.push(e.charCodeAt(n));
            return fu(t)
        }

        function Od(e) {
            e = fu(e);
            let t = "";
            for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
            return btoa(t)
        }
        var Td = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };

        function Rd(e, t) {
            return Td(this, void 0, void 0, (function*() {
                null == t && (t = {});
                const n = {
                    method: t.method || "GET",
                    headers: t.headers || {},
                    body: t.body || void 0
                };
                if (!0 !== t.skipFetchSetup && (n.mode = "cors", n.cache = "no-cache", n.credentials = "same-origin", n.redirect = "follow", n.referrer = "client"), null != t.fetchOptions) {
                    const e = t.fetchOptions;
                    e.mode && (n.mode = e.mode), e.cache && (n.cache = e.cache), e.credentials && (n.credentials = e.credentials), e.redirect && (n.redirect = e.redirect), e.referrer && (n.referrer = e.referrer)
                }
                const r = yield fetch(e, n), i = yield r.arrayBuffer(), o = {};
                return r.headers.forEach ? r.headers.forEach(((e, t) => {
                    o[t.toLowerCase()] = e
                })) : r.headers.keys().forEach((e => {
                    o[e.toLowerCase()] = r.headers.get(e)
                })), {
                    headers: o,
                    statusCode: r.status,
                    statusMessage: r.statusText,
                    body: fu(new Uint8Array(i))
                }
            }))
        }
        var Ld = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const Bd = new zl("web/5.7.1");

        function Fd(e) {
            return new Promise((t => {
                setTimeout(t, e)
            }))
        }

        function jd(e, t) {
            if (null == e) return null;
            if ("string" === typeof e) return e;
            if (cu(e)) {
                if (t && ("text" === t.split("/")[0] || "application/json" === t.split(";")[0].trim())) try {
                    return ac(e)
                } catch (n) {}
                return vu(e)
            }
            return e
        }

        function Dd(e, t, n) {
            let r = null;
            if (null != t) {
                r = sc(t);
                const n = "string" === typeof e ? {
                    url: e
                } : Vl(e);
                if (n.headers) {
                    const e = 0 !== Object.keys(n.headers).filter((e => "content-type" === e.toLowerCase())).length;
                    e || (n.headers = Vl(n.headers), n.headers["content-type"] = "application/json")
                } else n.headers = {
                    "content-type": "application/json"
                };
                e = n
            }
            return function(e, t, n) {
                const r = "object" === typeof e && null != e.throttleLimit ? e.throttleLimit : 12;
                Bd.assertArgument(r > 0 && r % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", r);
                const i = "object" === typeof e ? e.throttleCallback : null,
                    o = "object" === typeof e && "number" === typeof e.throttleSlotInterval ? e.throttleSlotInterval : 100;
                Bd.assertArgument(o > 0 && o % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", o);
                const s = "object" === typeof e && !!e.errorPassThrough,
                    a = {};
                let l = null;
                const u = {
                    method: "GET"
                };
                let c = !1,
                    d = 12e4;
                if ("string" === typeof e) l = e;
                else if ("object" === typeof e) {
                    if (null != e && null != e.url || Bd.throwArgumentError("missing URL", "connection.url", e), l = e.url, "number" === typeof e.timeout && e.timeout > 0 && (d = e.timeout), e.headers)
                        for (const t in e.headers) a[t.toLowerCase()] = {
                            key: t,
                            value: String(e.headers[t])
                        }, ["if-none-match", "if-modified-since"].indexOf(t.toLowerCase()) >= 0 && (c = !0);
                    if (u.allowGzip = !!e.allowGzip, null != e.user && null != e.password) {
                        "https:" !== l.substring(0, 6) && !0 !== e.allowInsecureAuthentication && Bd.throwError("basic authentication requires a secure https url", zl.errors.INVALID_ARGUMENT, {
                            argument: "url",
                            url: l,
                            user: e.user,
                            password: "[REDACTED]"
                        });
                        const t = e.user + ":" + e.password;
                        a.authorization = {
                            key: "Authorization",
                            value: "Basic " + Od(sc(t))
                        }
                    }
                    null != e.skipFetchSetup && (u.skipFetchSetup = !!e.skipFetchSetup), null != e.fetchOptions && (u.fetchOptions = Vl(e.fetchOptions))
                }
                const h = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
                    f = l ? l.match(h) : null;
                if (f) try {
                    const e = {
                        statusCode: 200,
                        statusMessage: "OK",
                        headers: {
                            "content-type": f[1] || "text/plain"
                        },
                        body: f[2] ? Id(f[3]) : (p = f[3], sc(p.replace(/%([0-9a-f][0-9a-f])/gi, ((e, t) => String.fromCharCode(parseInt(t, 16))))))
                    };
                    let t = e.body;
                    return n && (t = n(e.body, e)), Promise.resolve(t)
                } catch (v) {
                    Bd.throwError("processing response error", zl.errors.SERVER_ERROR, {
                        body: jd(f[1], f[2]),
                        error: v,
                        requestBody: null,
                        requestMethod: "GET",
                        url: l
                    })
                }
                var p;
                t && (u.method = "POST", u.body = t, null == a["content-type"] && (a["content-type"] = {
                    key: "Content-Type",
                    value: "application/octet-stream"
                }), null == a["content-length"] && (a["content-length"] = {
                    key: "Content-Length",
                    value: String(t.length)
                }));
                const m = {};
                Object.keys(a).forEach((e => {
                    const t = a[e];
                    m[t.key] = t.value
                })), u.headers = m;
                const g = function() {
                        let e = null;
                        return {
                            promise: new Promise((function(t, n) {
                                d && (e = setTimeout((() => {
                                    null != e && (e = null, n(Bd.makeError("timeout", zl.errors.TIMEOUT, {
                                        requestBody: jd(u.body, m["content-type"]),
                                        requestMethod: u.method,
                                        timeout: d,
                                        url: l
                                    })))
                                }), d))
                            })),
                            cancel: function() {
                                null != e && (clearTimeout(e), e = null)
                            }
                        }
                    }(),
                    y = function() {
                        return Ld(this, void 0, void 0, (function*() {
                            for (let e = 0; e < r; e++) {
                                let t = null;
                                try {
                                    if (t = yield Rd(l, u), e < r)
                                        if (301 === t.statusCode || 302 === t.statusCode) {
                                            const e = t.headers.location || "";
                                            if ("GET" === u.method && e.match(/^https:/)) {
                                                l = t.headers.location;
                                                continue
                                            }
                                        } else if (429 === t.statusCode) {
                                        let n = !0;
                                        if (i && (n = yield i(e, l)), n) {
                                            let n = 0;
                                            const r = t.headers["retry-after"];
                                            n = "string" === typeof r && r.match(/^[1-9][0-9]*$/) ? 1e3 * parseInt(r) : o * parseInt(String(Math.random() * Math.pow(2, e))), yield Fd(n);
                                            continue
                                        }
                                    }
                                } catch (v) {
                                    t = v.response, null == t && (g.cancel(), Bd.throwError("missing response", zl.errors.SERVER_ERROR, {
                                        requestBody: jd(u.body, m["content-type"]),
                                        requestMethod: u.method,
                                        serverError: v,
                                        url: l
                                    }))
                                }
                                let a = t.body;
                                if (c && 304 === t.statusCode ? a = null : !s && (t.statusCode < 200 || t.statusCode >= 300) && (g.cancel(), Bd.throwError("bad response", zl.errors.SERVER_ERROR, {
                                        status: t.statusCode,
                                        headers: t.headers,
                                        body: jd(a, t.headers ? t.headers["content-type"] : null),
                                        requestBody: jd(u.body, m["content-type"]),
                                        requestMethod: u.method,
                                        url: l
                                    })), n) try {
                                    const e = yield n(a, t);
                                    return g.cancel(), e
                                } catch (v) {
                                    if (v.throttleRetry && e < r) {
                                        let t = !0;
                                        if (i && (t = yield i(e, l)), t) {
                                            const t = o * parseInt(String(Math.random() * Math.pow(2, e)));
                                            yield Fd(t);
                                            continue
                                        }
                                    }
                                    g.cancel(), Bd.throwError("processing response error", zl.errors.SERVER_ERROR, {
                                        body: jd(a, t.headers ? t.headers["content-type"] : null),
                                        error: v,
                                        requestBody: jd(u.body, m["content-type"]),
                                        requestMethod: u.method,
                                        url: l
                                    })
                                }
                                return g.cancel(), a
                            }
                            return Bd.throwError("failed response", zl.errors.SERVER_ERROR, {
                                requestBody: jd(u.body, m["content-type"]),
                                requestMethod: u.method,
                                url: l
                            })
                        }))
                    }();
                return Promise.race([g.promise, y])
            }(e, r, ((e, t) => {
                let r = null;
                if (null != e) try {
                    r = JSON.parse(ac(e))
                } catch (i) {
                    Bd.throwError("invalid JSON", zl.errors.SERVER_ERROR, {
                        body: e,
                        error: i
                    })
                }
                return n && (r = n(r, t)), r
            }))
        }

        function Ud(e, t) {
            return t || (t = {}), null == (t = Vl(t)).floor && (t.floor = 0), null == t.ceiling && (t.ceiling = 1e4), null == t.interval && (t.interval = 250), new Promise((function(n, r) {
                let i = null,
                    o = !1;
                const s = () => !o && (o = !0, i && clearTimeout(i), !0);
                t.timeout && (i = setTimeout((() => {
                    s() && r(new Error("timeout"))
                }), t.timeout));
                const a = t.retryLimit;
                let l = 0;
                ! function i() {
                    return e().then((function(e) {
                        if (void 0 !== e) s() && n(e);
                        else if (t.oncePoll) t.oncePoll.once("poll", i);
                        else if (t.onceBlock) t.onceBlock.once("block", i);
                        else if (!o) {
                            if (l++, l > a) return void(s() && r(new Error("retry limit reached")));
                            let e = t.interval * parseInt(String(Math.random() * Math.pow(2, l)));
                            e < t.floor && (e = t.floor), e > t.ceiling && (e = t.ceiling), setTimeout(i, e)
                        }
                        return null
                    }), (function(e) {
                        s() && r(e)
                    }))
                }()
            }))
        }
        const zd = "providers/5.7.2";
        var qd = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const Gd = new zl("abstract-provider/5.7.0");
        class Hd extends Yl {
            static isForkEvent(e) {
                return !(!e || !e._isForkEvent)
            }
        }
        class $d {
            constructor() {
                Gd.checkAbstract(new.target, $d), Hl(this, "_isProvider", !0)
            }
            getFeeData() {
                return qd(this, void 0, void 0, (function*() {
                    const {
                        block: e,
                        gasPrice: t
                    } = yield Ql({
                        block: this.getBlock("latest"),
                        gasPrice: this.getGasPrice().catch((e => null))
                    });
                    let n = null,
                        r = null,
                        i = null;
                    return e && e.baseFeePerGas && (n = e.baseFeePerGas, i = Mu.from("1500000000"), r = e.baseFeePerGas.mul(2).add(i)), {
                        lastBaseFeePerGas: n,
                        maxFeePerGas: r,
                        maxPriorityFeePerGas: i,
                        gasPrice: t
                    }
                }))
            }
            addListener(e, t) {
                return this.on(e, t)
            }
            removeListener(e, t) {
                return this.off(e, t)
            }
            static isProvider(e) {
                return !(!e || !e._isProvider)
            }
        }
        class Qd {
            constructor(e) {
                Hl(this, "alphabet", e), Hl(this, "base", e.length), Hl(this, "_alphabetMap", {}), Hl(this, "_leader", e.charAt(0));
                for (let t = 0; t < e.length; t++) this._alphabetMap[e.charAt(t)] = t
            }
            encode(e) {
                let t = fu(e);
                if (0 === t.length) return "";
                let n = [0];
                for (let i = 0; i < t.length; ++i) {
                    let e = t[i];
                    for (let t = 0; t < n.length; ++t) e += n[t] << 8, n[t] = e % this.base, e = e / this.base | 0;
                    for (; e > 0;) n.push(e % this.base), e = e / this.base | 0
                }
                let r = "";
                for (let i = 0; 0 === t[i] && i < t.length - 1; ++i) r += this._leader;
                for (let i = n.length - 1; i >= 0; --i) r += this.alphabet[n[i]];
                return r
            }
            decode(e) {
                if ("string" !== typeof e) throw new TypeError("Expected String");
                let t = [];
                if (0 === e.length) return new Uint8Array(t);
                t.push(0);
                for (let n = 0; n < e.length; n++) {
                    let r = this._alphabetMap[e[n]];
                    if (void 0 === r) throw new Error("Non-base" + this.base + " character");
                    let i = r;
                    for (let e = 0; e < t.length; ++e) i += t[e] * this.base, t[e] = 255 & i, i >>= 8;
                    for (; i > 0;) t.push(255 & i), i >>= 8
                }
                for (let n = 0; e[n] === this._leader && n < e.length - 1; ++n) t.push(0);
                return fu(new Uint8Array(t.reverse()))
            }
        }
        new Qd("abcdefghijklmnopqrstuvwxyz234567");
        const Vd = new Qd("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

        function Kd(e, t) {
            null == t && (t = 1);
            const n = [],
                r = n.forEach,
                i = function(e, t) {
                    r.call(e, (function(e) {
                        t > 0 && Array.isArray(e) ? i(e, t - 1) : n.push(e)
                    }))
                };
            return i(e, t), n
        }

        function Wd(e) {
            return function(e) {
                let t = 0;
                return () => e[t++]
            }(function(e) {
                let t = 0;

                function n() {
                    return e[t++] << 8 | e[t++]
                }
                let r = n(),
                    i = 1,
                    o = [0, 1];
                for (let w = 1; w < r; w++) o.push(i += n());
                let s = n(),
                    a = t;
                t += s;
                let l = 0,
                    u = 0;

                function c() {
                    return 0 == l && (u = u << 8 | e[t++], l = 8), u >> --l & 1
                }
                const d = Math.pow(2, 31),
                    h = d >>> 1,
                    f = h >> 1,
                    p = d - 1;
                let m = 0;
                for (let w = 0; w < 31; w++) m = m << 1 | c();
                let g = [],
                    y = 0,
                    v = d;
                for (;;) {
                    let e = Math.floor(((m - y + 1) * i - 1) / v),
                        t = 0,
                        n = r;
                    for (; n - t > 1;) {
                        let r = t + n >>> 1;
                        e < o[r] ? n = r : t = r
                    }
                    if (0 == t) break;
                    g.push(t);
                    let s = y + Math.floor(v * o[t] / i),
                        a = y + Math.floor(v * o[t + 1] / i) - 1;
                    for (; 0 == ((s ^ a) & h);) m = m << 1 & p | c(), s = s << 1 & p, a = a << 1 & p | 1;
                    for (; s & ~a & f;) m = m & h | m << 1 & p >>> 1 | c(), s = s << 1 ^ h, a = (a ^ h) << 1 | h | 1;
                    y = s, v = 1 + a - s
                }
                let b = r - 4;
                return g.map((t => {
                    switch (t - b) {
                        case 3:
                            return b + 65792 + (e[a++] << 16 | e[a++] << 8 | e[a++]);
                        case 2:
                            return b + 256 + (e[a++] << 8 | e[a++]);
                        case 1:
                            return b + e[a++];
                        default:
                            return t - 1
                    }
                }))
            }(e))
        }

        function Jd(e) {
            return 1 & e ? ~e >> 1 : e >> 1
        }

        function Zd(e, t) {
            let n = Array(e);
            for (let r = 0, i = -1; r < e; r++) n[r] = i += 1 + t();
            return n
        }

        function Yd(e, t) {
            let n = Array(e);
            for (let r = 0, i = 0; r < e; r++) n[r] = i += Jd(t());
            return n
        }

        function Xd(e, t) {
            let n = Zd(e(), e),
                r = e(),
                i = Zd(r, e),
                o = function(e, t) {
                    let n = Array(e);
                    for (let r = 0; r < e; r++) n[r] = 1 + t();
                    return n
                }(r, e);
            for (let s = 0; s < r; s++)
                for (let e = 0; e < o[s]; e++) n.push(i[s] + e);
            return t ? n.map((e => t[e])) : n
        }

        function eh(e, t, n) {
            let r = Array(e).fill(void 0).map((() => []));
            for (let i = 0; i < t; i++) Yd(e, n).forEach(((e, t) => r[t].push(e)));
            return r
        }

        function th(e, t) {
            let n = 1 + t(),
                r = t(),
                i = function(e) {
                    let t = [];
                    for (;;) {
                        let n = e();
                        if (0 == n) break;
                        t.push(n)
                    }
                    return t
                }(t);
            return Kd(eh(i.length, 1 + e, t).map(((e, t) => {
                const o = e[0],
                    s = e.slice(1);
                return Array(i[t]).fill(void 0).map(((e, t) => {
                    let i = t * r;
                    return [o + t * n, s.map((e => e + i))]
                }))
            })))
        }

        function nh(e, t) {
            return eh(1 + t(), 1 + e, t).map((e => [e[0], e.slice(1)]))
        }
        const rh = Wd(Id("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA==")),
            ih = new Set(Xd(rh)),
            oh = new Set(Xd(rh)),
            sh = function(e) {
                let t = [];
                for (;;) {
                    let n = e();
                    if (0 == n) break;
                    t.push(th(n, e))
                }
                for (;;) {
                    let n = e() - 1;
                    if (n < 0) break;
                    t.push(nh(n, e))
                }
                return function(e) {
                    const t = {};
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n];
                        t[r[0]] = r[1]
                    }
                    return t
                }(Kd(t))
            }(rh),
            ah = function(e) {
                let t = Xd(e).sort(((e, t) => e - t));
                return function n() {
                    let r = [];
                    for (;;) {
                        let i = Xd(e, t);
                        if (0 == i.length) break;
                        r.push({
                            set: new Set(i),
                            node: n()
                        })
                    }
                    r.sort(((e, t) => t.set.size - e.set.size));
                    let i = e(),
                        o = i % 3;
                    i = i / 3 | 0;
                    let s = !!(1 & i);
                    return i >>= 1, {
                        branches: r,
                        valid: o,
                        fe0f: s,
                        save: 1 == i,
                        check: 2 == i
                    }
                }()
            }(rh),
            lh = 45,
            uh = 95;

        function ch(e) {
            return function(e) {
                return oc(sc(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : tc.current))
            }(e)
        }

        function dh(e) {
            return e.filter((e => 65039 != e))
        }

        function hh(e) {
            for (let n of e.split(".")) {
                let e = ch(n);
                try {
                    for (let t = e.lastIndexOf(uh) - 1; t >= 0; t--)
                        if (e[t] !== uh) throw new Error("underscore only allowed at start");
                    if (e.length >= 4 && e.every((e => e < 128)) && e[2] === lh && e[3] === lh) throw new Error("invalid label extension")
                } catch (t) {
                    throw new Error(`Invalid label "${n}": ${t.message}`)
                }
            }
            return e
        }

        function fh(e) {
            return hh(function(e, t) {
                let n = ch(e).reverse(),
                    r = [];
                for (; n.length;) {
                    let e = ph(n);
                    if (e) {
                        r.push(...t(e));
                        continue
                    }
                    let i = n.pop();
                    if (ih.has(i)) {
                        r.push(i);
                        continue
                    }
                    if (oh.has(i)) continue;
                    let o = sh[i];
                    if (!o) throw new Error(`Disallowed codepoint: 0x${i.toString(16).toUpperCase()}`);
                    r.push(...o)
                }
                return hh((i = String.fromCodePoint(...r), i.normalize("NFC")));
                var i
            }(e, dh))
        }

        function ph(e, t) {
            var n;
            let r, i, o = ah,
                s = [],
                a = e.length;
            for (t && (t.length = 0); a;) {
                let l = e[--a];
                if (o = null === (n = o.branches.find((e => e.set.has(l)))) || void 0 === n ? void 0 : n.node, !o) break;
                if (o.save) i = l;
                else if (o.check && l === i) break;
                s.push(l), o.fe0f && (s.push(65039), a > 0 && 65039 == e[a - 1] && a--), o.valid && (r = s.slice(), 2 == o.valid && r.splice(1, 1), t && t.push(...e.slice(a).reverse()), e.length = a)
            }
            return r
        }
        const mh = new zl(Xu),
            gh = new Uint8Array(32);

        function yh(e) {
            if (0 === e.length) throw new Error("invalid ENS name; empty component");
            return e
        }

        function vh(e) {
            const t = sc(fh(e)),
                n = [];
            if (0 === e.length) return n;
            let r = 0;
            for (let i = 0; i < t.length; i++) {
                46 === t[i] && (n.push(yh(t.slice(r, i))), r = i + 1)
            }
            if (r >= t.length) throw new Error("invalid ENS name; empty component");
            return n.push(yh(t.slice(r))), n
        }

        function bh(e) {
            "string" !== typeof e && mh.throwArgumentError("invalid ENS name; not a string", "name", e);
            let t = gh;
            const n = vh(e);
            for (; n.length;) t = Fu(pu([t, Fu(n.pop())]));
            return vu(t)
        }
        gh.fill(0);
        const wh = new zl("networks/5.7.1");

        function Eh(e) {
            const t = function(t, n) {
                null == n && (n = {});
                const r = [];
                if (t.InfuraProvider && "-" !== n.infura) try {
                    r.push(new t.InfuraProvider(e, n.infura))
                } catch (i) {}
                if (t.EtherscanProvider && "-" !== n.etherscan) try {
                    r.push(new t.EtherscanProvider(e, n.etherscan))
                } catch (i) {}
                if (t.AlchemyProvider && "-" !== n.alchemy) try {
                    r.push(new t.AlchemyProvider(e, n.alchemy))
                } catch (i) {}
                if (t.PocketProvider && "-" !== n.pocket) {
                    const o = ["goerli", "ropsten", "rinkeby", "sepolia"];
                    try {
                        const i = new t.PocketProvider(e, n.pocket);
                        i.network && -1 === o.indexOf(i.network.name) && r.push(i)
                    } catch (i) {}
                }
                if (t.CloudflareProvider && "-" !== n.cloudflare) try {
                    r.push(new t.CloudflareProvider(e))
                } catch (i) {}
                if (t.AnkrProvider && "-" !== n.ankr) try {
                    const i = ["ropsten"],
                        o = new t.AnkrProvider(e, n.ankr);
                    o.network && -1 === i.indexOf(o.network.name) && r.push(o)
                } catch (i) {}
                if (0 === r.length) return null;
                if (t.FallbackProvider) {
                    let i = 1;
                    return null != n.quorum ? i = n.quorum : "homestead" === e && (i = 2), new t.FallbackProvider(r, i)
                }
                return r[0]
            };
            return t.renetwork = function(e) {
                return Eh(e)
            }, t
        }

        function xh(e, t) {
            const n = function(n, r) {
                return n.JsonRpcProvider ? new n.JsonRpcProvider(e, t) : null
            };
            return n.renetwork = function(t) {
                return xh(e, t)
            }, n
        }
        const Ah = {
                chainId: 1,
                ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                name: "homestead",
                _defaultProvider: Eh("homestead")
            },
            kh = {
                chainId: 3,
                ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                name: "ropsten",
                _defaultProvider: Eh("ropsten")
            },
            Ch = {
                chainId: 63,
                name: "classicMordor",
                _defaultProvider: xh("https://www.ethercluster.com/mordor", "classicMordor")
            },
            Ph = {
                unspecified: {
                    chainId: 0,
                    name: "unspecified"
                },
                homestead: Ah,
                mainnet: Ah,
                morden: {
                    chainId: 2,
                    name: "morden"
                },
                ropsten: kh,
                testnet: kh,
                rinkeby: {
                    chainId: 4,
                    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                    name: "rinkeby",
                    _defaultProvider: Eh("rinkeby")
                },
                kovan: {
                    chainId: 42,
                    name: "kovan",
                    _defaultProvider: Eh("kovan")
                },
                goerli: {
                    chainId: 5,
                    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                    name: "goerli",
                    _defaultProvider: Eh("goerli")
                },
                kintsugi: {
                    chainId: 1337702,
                    name: "kintsugi"
                },
                sepolia: {
                    chainId: 11155111,
                    name: "sepolia",
                    _defaultProvider: Eh("sepolia")
                },
                classic: {
                    chainId: 61,
                    name: "classic",
                    _defaultProvider: xh("https://www.ethercluster.com/etc", "classic")
                },
                classicMorden: {
                    chainId: 62,
                    name: "classicMorden"
                },
                classicMordor: Ch,
                classicTestnet: Ch,
                classicKotti: {
                    chainId: 6,
                    name: "classicKotti",
                    _defaultProvider: xh("https://www.ethercluster.com/kotti", "classicKotti")
                },
                xdai: {
                    chainId: 100,
                    name: "xdai"
                },
                matic: {
                    chainId: 137,
                    name: "matic",
                    _defaultProvider: Eh("matic")
                },
                maticmum: {
                    chainId: 80001,
                    name: "maticmum"
                },
                optimism: {
                    chainId: 10,
                    name: "optimism",
                    _defaultProvider: Eh("optimism")
                },
                "optimism-kovan": {
                    chainId: 69,
                    name: "optimism-kovan"
                },
                "optimism-goerli": {
                    chainId: 420,
                    name: "optimism-goerli"
                },
                arbitrum: {
                    chainId: 42161,
                    name: "arbitrum"
                },
                "arbitrum-rinkeby": {
                    chainId: 421611,
                    name: "arbitrum-rinkeby"
                },
                "arbitrum-goerli": {
                    chainId: 421613,
                    name: "arbitrum-goerli"
                },
                bnb: {
                    chainId: 56,
                    name: "bnb"
                },
                bnbt: {
                    chainId: 97,
                    name: "bnbt"
                }
            };
        new zl("sha2/5.7.0");

        function Sh(e) {
            return "0x" + Mc().sha256().update(fu(e)).digest("hex")
        }
        var _h = n(2943),
            Nh = n.n(_h);
        const Mh = new zl(zd);
        class Ih {
            constructor() {
                this.formats = this.getDefaultFormats()
            }
            getDefaultFormats() {
                const e = {},
                    t = this.address.bind(this),
                    n = this.bigNumber.bind(this),
                    r = this.blockTag.bind(this),
                    i = this.data.bind(this),
                    o = this.hash.bind(this),
                    s = this.hex.bind(this),
                    a = this.number.bind(this),
                    l = this.type.bind(this);
                return e.transaction = {
                    hash: o,
                    type: l,
                    accessList: Ih.allowNull(this.accessList.bind(this), null),
                    blockHash: Ih.allowNull(o, null),
                    blockNumber: Ih.allowNull(a, null),
                    transactionIndex: Ih.allowNull(a, null),
                    confirmations: Ih.allowNull(a, null),
                    from: t,
                    gasPrice: Ih.allowNull(n),
                    maxPriorityFeePerGas: Ih.allowNull(n),
                    maxFeePerGas: Ih.allowNull(n),
                    gasLimit: n,
                    to: Ih.allowNull(t, null),
                    value: n,
                    nonce: a,
                    data: i,
                    r: Ih.allowNull(this.uint256),
                    s: Ih.allowNull(this.uint256),
                    v: Ih.allowNull(a),
                    creates: Ih.allowNull(t, null),
                    raw: Ih.allowNull(i)
                }, e.transactionRequest = {
                    from: Ih.allowNull(t),
                    nonce: Ih.allowNull(a),
                    gasLimit: Ih.allowNull(n),
                    gasPrice: Ih.allowNull(n),
                    maxPriorityFeePerGas: Ih.allowNull(n),
                    maxFeePerGas: Ih.allowNull(n),
                    to: Ih.allowNull(t),
                    value: Ih.allowNull(n),
                    data: Ih.allowNull((e => this.data(e, !0))),
                    type: Ih.allowNull(a),
                    accessList: Ih.allowNull(this.accessList.bind(this), null)
                }, e.receiptLog = {
                    transactionIndex: a,
                    blockNumber: a,
                    transactionHash: o,
                    address: t,
                    topics: Ih.arrayOf(o),
                    data: i,
                    logIndex: a,
                    blockHash: o
                }, e.receipt = {
                    to: Ih.allowNull(this.address, null),
                    from: Ih.allowNull(this.address, null),
                    contractAddress: Ih.allowNull(t, null),
                    transactionIndex: a,
                    root: Ih.allowNull(s),
                    gasUsed: n,
                    logsBloom: Ih.allowNull(i),
                    blockHash: o,
                    transactionHash: o,
                    logs: Ih.arrayOf(this.receiptLog.bind(this)),
                    blockNumber: a,
                    confirmations: Ih.allowNull(a, null),
                    cumulativeGasUsed: n,
                    effectiveGasPrice: Ih.allowNull(n),
                    status: Ih.allowNull(a),
                    type: l
                }, e.block = {
                    hash: Ih.allowNull(o),
                    parentHash: o,
                    number: a,
                    timestamp: a,
                    nonce: Ih.allowNull(s),
                    difficulty: this.difficulty.bind(this),
                    gasLimit: n,
                    gasUsed: n,
                    miner: Ih.allowNull(t),
                    extraData: i,
                    transactions: Ih.allowNull(Ih.arrayOf(o)),
                    baseFeePerGas: Ih.allowNull(n)
                }, e.blockWithTransactions = Vl(e.block), e.blockWithTransactions.transactions = Ih.allowNull(Ih.arrayOf(this.transactionResponse.bind(this))), e.filter = {
                    fromBlock: Ih.allowNull(r, void 0),
                    toBlock: Ih.allowNull(r, void 0),
                    blockHash: Ih.allowNull(o, void 0),
                    address: Ih.allowNull(t, void 0),
                    topics: Ih.allowNull(this.topics.bind(this), void 0)
                }, e.filterLog = {
                    blockNumber: Ih.allowNull(a),
                    blockHash: Ih.allowNull(o),
                    transactionIndex: a,
                    removed: Ih.allowNull(this.boolean.bind(this)),
                    address: t,
                    data: Ih.allowFalsish(i, "0x"),
                    topics: Ih.arrayOf(o),
                    transactionHash: o,
                    logIndex: a
                }, e
            }
            accessList(e) {
                return Cd(e || [])
            }
            number(e) {
                return "0x" === e ? 0 : Mu.from(e).toNumber()
            }
            type(e) {
                return "0x" === e || null == e ? 0 : Mu.from(e).toNumber()
            }
            bigNumber(e) {
                return Mu.from(e)
            }
            boolean(e) {
                if ("boolean" === typeof e) return e;
                if ("string" === typeof e) {
                    if ("true" === (e = e.toLowerCase())) return !0;
                    if ("false" === e) return !1
                }
                throw new Error("invalid boolean - " + e)
            }
            hex(e, t) {
                return "string" === typeof e && (t || "0x" === e.substring(0, 2) || (e = "0x" + e), gu(e)) ? e.toLowerCase() : Mh.throwArgumentError("invalid hash", "value", e)
            }
            data(e, t) {
                const n = this.hex(e, t);
                if (n.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e);
                return n
            }
            address(e) {
                return Zu(e)
            }
            callAddress(e) {
                if (!gu(e, 32)) return null;
                const t = Zu(wu(e, 12));
                return "0x0000000000000000000000000000000000000000" === t ? null : t
            }
            contractAddress(e) {
                return Yu(e)
            }
            blockTag(e) {
                if (null == e) return "latest";
                if ("earliest" === e) return "0x0";
                switch (e) {
                    case "earliest":
                        return "0x0";
                    case "latest":
                    case "pending":
                    case "safe":
                    case "finalized":
                        return e
                }
                if ("number" === typeof e || gu(e)) return xu(e);
                throw new Error("invalid blockTag")
            }
            hash(e, t) {
                const n = this.hex(e, t);
                return 32 !== bu(n) ? Mh.throwArgumentError("invalid hash", "value", e) : n
            }
            difficulty(e) {
                if (null == e) return null;
                const t = Mu.from(e);
                try {
                    return t.toNumber()
                } catch (n) {}
                return null
            }
            uint256(e) {
                if (!gu(e)) throw new Error("invalid uint256");
                return Au(e, 32)
            }
            _block(e, t) {
                null != e.author && null == e.miner && (e.miner = e.author);
                const n = null != e._difficulty ? e._difficulty : e.difficulty,
                    r = Ih.check(t, e);
                return r._difficulty = null == n ? null : Mu.from(n), r
            }
            block(e) {
                return this._block(e, this.formats.block)
            }
            blockWithTransactions(e) {
                return this._block(e, this.formats.blockWithTransactions)
            }
            transactionRequest(e) {
                return Ih.check(this.formats.transactionRequest, e)
            }
            transactionResponse(e) {
                null != e.gas && null == e.gasLimit && (e.gasLimit = e.gas), e.to && Mu.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"), null != e.input && null == e.data && (e.data = e.input), null == e.to && null == e.creates && (e.creates = this.contractAddress(e)), 1 !== e.type && 2 !== e.type || null != e.accessList || (e.accessList = []);
                const t = Ih.check(this.formats.transaction, e);
                if (null != e.chainId) {
                    let n = e.chainId;
                    gu(n) && (n = Mu.from(n).toNumber()), t.chainId = n
                } else {
                    let n = e.networkId;
                    null == n && null == t.v && (n = e.chainId), gu(n) && (n = Mu.from(n).toNumber()), "number" !== typeof n && null != t.v && (n = (t.v - 35) / 2, n < 0 && (n = 0), n = parseInt(n)), "number" !== typeof n && (n = 0), t.chainId = n
                }
                return t.blockHash && "x" === t.blockHash.replace(/0/g, "") && (t.blockHash = null), t
            }
            transaction(e) {
                return Md(e)
            }
            receiptLog(e) {
                return Ih.check(this.formats.receiptLog, e)
            }
            receipt(e) {
                const t = Ih.check(this.formats.receipt, e);
                if (null != t.root)
                    if (t.root.length <= 4) {
                        const e = Mu.from(t.root).toNumber();
                        0 === e || 1 === e ? (null != t.status && t.status !== e && Mh.throwArgumentError("alt-root-status/status mismatch", "value", {
                            root: t.root,
                            status: t.status
                        }), t.status = e, delete t.root) : Mh.throwArgumentError("invalid alt-root-status", "value.root", t.root)
                    } else 66 !== t.root.length && Mh.throwArgumentError("invalid root hash", "value.root", t.root);
                return null != t.status && (t.byzantium = !0), t
            }
            topics(e) {
                return Array.isArray(e) ? e.map((e => this.topics(e))) : null != e ? this.hash(e, !0) : null
            }
            filter(e) {
                return Ih.check(this.formats.filter, e)
            }
            filterLog(e) {
                return Ih.check(this.formats.filterLog, e)
            }
            static check(e, t) {
                const n = {};
                for (const i in e) try {
                    const r = e[i](t[i]);
                    void 0 !== r && (n[i] = r)
                } catch (r) {
                    throw r.checkKey = i, r.checkValue = t[i], r
                }
                return n
            }
            static allowNull(e, t) {
                return function(n) {
                    return null == n ? t : e(n)
                }
            }
            static allowFalsish(e, t) {
                return function(n) {
                    return n ? e(n) : t
                }
            }
            static arrayOf(e) {
                return function(t) {
                    if (!Array.isArray(t)) throw new Error("not an array");
                    const n = [];
                    return t.forEach((function(t) {
                        n.push(e(t))
                    })), n
                }
            }
        }
        var Oh = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const Th = new zl(zd);

        function Rh(e) {
            return null == e ? "null" : (32 !== bu(e) && Th.throwArgumentError("invalid topic", "topic", e), e.toLowerCase())
        }

        function Lh(e) {
            for (e = e.slice(); e.length > 0 && null == e[e.length - 1];) e.pop();
            return e.map((e => {
                if (Array.isArray(e)) {
                    const t = {};
                    e.forEach((e => {
                        t[Rh(e)] = !0
                    }));
                    const n = Object.keys(t);
                    return n.sort(), n.join("|")
                }
                return Rh(e)
            })).join("&")
        }

        function Bh(e) {
            if ("string" === typeof e) {
                if (32 === bu(e = e.toLowerCase())) return "tx:" + e;
                if (-1 === e.indexOf(":")) return e
            } else {
                if (Array.isArray(e)) return "filter:*:" + Lh(e);
                if (Hd.isForkEvent(e)) throw Th.warn("not implemented"), new Error("not implemented");
                if (e && "object" === typeof e) return "filter:" + (e.address || "*") + ":" + Lh(e.topics || [])
            }
            throw new Error("invalid event - " + e)
        }

        function Fh() {
            return (new Date).getTime()
        }

        function jh(e) {
            return new Promise((t => {
                setTimeout(t, e)
            }))
        }
        const Dh = ["block", "network", "pending", "poll"];
        class Uh {
            constructor(e, t, n) {
                Hl(this, "tag", e), Hl(this, "listener", t), Hl(this, "once", n), this._lastBlockNumber = -2, this._inflight = !1
            }
            get event() {
                switch (this.type) {
                    case "tx":
                        return this.hash;
                    case "filter":
                        return this.filter
                }
                return this.tag
            }
            get type() {
                return this.tag.split(":")[0]
            }
            get hash() {
                const e = this.tag.split(":");
                return "tx" !== e[0] ? null : e[1]
            }
            get filter() {
                const e = this.tag.split(":");
                if ("filter" !== e[0]) return null;
                const t = e[1],
                    n = function(e) {
                        return "" === e ? [] : e.split(/&/g).map((e => {
                            if ("" === e) return [];
                            const t = e.split("|").map((e => "null" === e ? null : e));
                            return 1 === t.length ? t[0] : t
                        }))
                    }(e[2]),
                    r = {};
                return n.length > 0 && (r.topics = n), t && "*" !== t && (r.address = t), r
            }
            pollable() {
                return this.tag.indexOf(":") >= 0 || Dh.indexOf(this.tag) >= 0
            }
        }
        const zh = {
            0: {
                symbol: "btc",
                p2pkh: 0,
                p2sh: 5,
                prefix: "bc"
            },
            2: {
                symbol: "ltc",
                p2pkh: 48,
                p2sh: 50,
                prefix: "ltc"
            },
            3: {
                symbol: "doge",
                p2pkh: 30,
                p2sh: 22
            },
            60: {
                symbol: "eth",
                ilk: "eth"
            },
            61: {
                symbol: "etc",
                ilk: "eth"
            },
            700: {
                symbol: "xdai",
                ilk: "eth"
            }
        };

        function qh(e) {
            return Au(Mu.from(e).toHexString(), 32)
        }

        function Gh(e) {
            return Vd.encode(pu([e, wu(Sh(Sh(e)), 0, 4)]))
        }
        const Hh = new RegExp("^(ipfs)://(.*)$", "i"),
            $h = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), Hh, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];

        function Qh(e, t) {
            try {
                return ac(Vh(e, t))
            } catch (n) {}
            return null
        }

        function Vh(e, t) {
            if ("0x" === e) return null;
            const n = Mu.from(wu(e, t, t + 32)).toNumber(),
                r = Mu.from(wu(e, n, n + 32)).toNumber();
            return wu(e, n + 32, n + 32 + r)
        }

        function Kh(e) {
            return e.match(/^ipfs:\/\/ipfs\//i) ? e = e.substring(12) : e.match(/^ipfs:\/\//i) ? e = e.substring(7) : Th.throwArgumentError("unsupported IPFS format", "link", e), `https://gateway.ipfs.io/ipfs/${e}`
        }

        function Wh(e) {
            const t = fu(e);
            if (t.length > 32) throw new Error("internal; should not happen");
            const n = new Uint8Array(32);
            return n.set(t, 32 - t.length), n
        }

        function Jh(e) {
            if (e.length % 32 === 0) return e;
            const t = new Uint8Array(32 * Math.ceil(e.length / 32));
            return t.set(e), t
        }

        function Zh(e) {
            const t = [];
            let n = 0;
            for (let r = 0; r < e.length; r++) t.push(null), n += 32;
            for (let r = 0; r < e.length; r++) {
                const i = fu(e[r]);
                t[r] = Wh(n), t.push(Wh(i.length)), t.push(Jh(i)), n += 32 + 32 * Math.ceil(i.length / 32)
            }
            return Eu(t)
        }
        class Yh {
            constructor(e, t, n, r) {
                Hl(this, "provider", e), Hl(this, "name", n), Hl(this, "address", e.formatter.address(t)), Hl(this, "_resolvedAddress", r)
            }
            supportsWildcard() {
                return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
                    to: this.address,
                    data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
                }).then((e => Mu.from(e).eq(1))).catch((e => {
                    if (e.code === zl.errors.CALL_EXCEPTION) return !1;
                    throw this._supportsEip2544 = null, e
                }))), this._supportsEip2544
            }
            _fetch(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    const n = {
                        to: this.address,
                        ccipReadEnabled: !0,
                        data: Eu([e, bh(this.name), t || "0x"])
                    };
                    let r = !1;
                    var i;
                    (yield this.supportsWildcard()) && (r = !0, n.data = Eu(["0x9061b923", Zh([(i = this.name, vu(pu(vh(i).map((e => {
                        if (e.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
                        const t = new Uint8Array(e.length + 1);
                        return t.set(e, 1), t[0] = t.length - 1, t
                    })))) + "00"), n.data])]));
                    try {
                        let e = yield this.provider.call(n);
                        return fu(e).length % 32 === 4 && Th.throwError("resolver threw error", zl.errors.CALL_EXCEPTION, {
                            transaction: n,
                            data: e
                        }), r && (e = Vh(e, 0)), e
                    } catch (o) {
                        if (o.code === zl.errors.CALL_EXCEPTION) return null;
                        throw o
                    }
                }))
            }
            _fetchBytes(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    const n = yield this._fetch(e, t);
                    return null != n ? Vh(n, 0) : null
                }))
            }
            _getAddress(e, t) {
                const n = zh[String(e)];
                if (null == n && Th.throwError(`unsupported coin type: ${e}`, zl.errors.UNSUPPORTED_OPERATION, {
                        operation: `getAddress(${e})`
                    }), "eth" === n.ilk) return this.provider.formatter.address(t);
                const r = fu(t);
                if (null != n.p2pkh) {
                    const e = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
                    if (e) {
                        const t = parseInt(e[1], 16);
                        if (e[2].length === 2 * t && t >= 1 && t <= 75) return Gh(pu([
                            [n.p2pkh], "0x" + e[2]
                        ]))
                    }
                }
                if (null != n.p2sh) {
                    const e = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
                    if (e) {
                        const t = parseInt(e[1], 16);
                        if (e[2].length === 2 * t && t >= 1 && t <= 75) return Gh(pu([
                            [n.p2sh], "0x" + e[2]
                        ]))
                    }
                }
                if (null != n.prefix) {
                    const e = r[1];
                    let t = r[0];
                    if (0 === t ? 20 !== e && 32 !== e && (t = -1) : t = -1, t >= 0 && r.length === 2 + e && e >= 1 && e <= 75) {
                        const e = Nh().toWords(r.slice(2));
                        return e.unshift(t), Nh().encode(n.prefix, e)
                    }
                }
                return null
            }
            getAddress(e) {
                return Oh(this, void 0, void 0, (function*() {
                    if (null == e && (e = 60), 60 === e) try {
                        const e = yield this._fetch("0x3b3b57de");
                        return "0x" === e || "0x0000000000000000000000000000000000000000000000000000000000000000" === e ? null : this.provider.formatter.callAddress(e)
                    } catch (r) {
                        if (r.code === zl.errors.CALL_EXCEPTION) return null;
                        throw r
                    }
                    const t = yield this._fetchBytes("0xf1cb7e06", qh(e));
                    if (null == t || "0x" === t) return null;
                    const n = this._getAddress(e, t);
                    return null == n && Th.throwError("invalid or unsupported coin data", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: `getAddress(${e})`,
                        coinType: e,
                        data: t
                    }), n
                }))
            }
            getAvatar() {
                return Oh(this, void 0, void 0, (function*() {
                    const e = [{
                        type: "name",
                        content: this.name
                    }];
                    try {
                        const t = yield this.getText("avatar");
                        if (null == t) return null;
                        for (let n = 0; n < $h.length; n++) {
                            const r = t.match($h[n]);
                            if (null == r) continue;
                            const i = r[1].toLowerCase();
                            switch (i) {
                                case "https":
                                    return e.push({
                                        type: "url",
                                        content: t
                                    }), {
                                        linkage: e,
                                        url: t
                                    };
                                case "data":
                                    return e.push({
                                        type: "data",
                                        content: t
                                    }), {
                                        linkage: e,
                                        url: t
                                    };
                                case "ipfs":
                                    return e.push({
                                        type: "ipfs",
                                        content: t
                                    }), {
                                        linkage: e,
                                        url: Kh(t)
                                    };
                                case "erc721":
                                case "erc1155":
                                    {
                                        const n = "erc721" === i ? "0xc87b56dd" : "0x0e89341c";e.push({
                                            type: i,
                                            content: t
                                        });
                                        const o = this._resolvedAddress || (yield this.getAddress()),
                                            s = (r[2] || "").split("/");
                                        if (2 !== s.length) return null;
                                        const a = yield this.provider.formatter.address(s[0]), l = Au(Mu.from(s[1]).toHexString(), 32);
                                        if ("erc721" === i) {
                                            const t = this.provider.formatter.callAddress(yield this.provider.call({
                                                to: a,
                                                data: Eu(["0x6352211e", l])
                                            }));
                                            if (o !== t) return null;
                                            e.push({
                                                type: "owner",
                                                content: t
                                            })
                                        } else if ("erc1155" === i) {
                                            const t = Mu.from(yield this.provider.call({
                                                to: a,
                                                data: Eu(["0x00fdd58e", Au(o, 32), l])
                                            }));
                                            if (t.isZero()) return null;
                                            e.push({
                                                type: "balance",
                                                content: t.toString()
                                            })
                                        }
                                        const u = {
                                            to: this.provider.formatter.address(s[0]),
                                            data: Eu([n, l])
                                        };
                                        let c = Qh(yield this.provider.call(u), 0);
                                        if (null == c) return null;e.push({
                                            type: "metadata-url-base",
                                            content: c
                                        }),
                                        "erc1155" === i && (c = c.replace("{id}", l.substring(2)), e.push({
                                            type: "metadata-url-expanded",
                                            content: c
                                        })),
                                        c.match(/^ipfs:/i) && (c = Kh(c)),
                                        e.push({
                                            type: "metadata-url",
                                            content: c
                                        });
                                        const d = yield Dd(c);
                                        if (!d) return null;e.push({
                                            type: "metadata",
                                            content: JSON.stringify(d)
                                        });
                                        let h = d.image;
                                        if ("string" !== typeof h) return null;
                                        if (h.match(/^(https:\/\/|data:)/i));
                                        else {
                                            if (null == h.match(Hh)) return null;
                                            e.push({
                                                type: "url-ipfs",
                                                content: h
                                            }), h = Kh(h)
                                        }
                                        return e.push({
                                            type: "url",
                                            content: h
                                        }),
                                        {
                                            linkage: e,
                                            url: h
                                        }
                                    }
                            }
                        }
                    } catch (t) {}
                    return null
                }))
            }
            getContentHash() {
                return Oh(this, void 0, void 0, (function*() {
                    const e = yield this._fetchBytes("0xbc1c58d1");
                    if (null == e || "0x" === e) return null;
                    const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                    if (t) {
                        const e = parseInt(t[3], 16);
                        if (t[4].length === 2 * e) return "ipfs://" + Vd.encode("0x" + t[1])
                    }
                    const n = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
                    if (n) {
                        const e = parseInt(n[3], 16);
                        if (n[4].length === 2 * e) return "ipns://" + Vd.encode("0x" + n[1])
                    }
                    const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
                    if (r && 64 === r[1].length) return "bzz://" + r[1];
                    const i = e.match(/^0x90b2c605([0-9a-f]*)$/);
                    if (i && 68 === i[1].length) {
                        const e = {
                            "=": "",
                            "+": "-",
                            "/": "_"
                        };
                        return "sia://" + Od("0x" + i[1]).replace(/[=+\/]/g, (t => e[t]))
                    }
                    return Th.throwError("invalid or unsupported content hash data", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "getContentHash()",
                        data: e
                    })
                }))
            }
            getText(e) {
                return Oh(this, void 0, void 0, (function*() {
                    let t = sc(e);
                    t = pu([qh(64), qh(t.length), t]), t.length % 32 !== 0 && (t = pu([t, Au("0x", 32 - e.length % 32)]));
                    const n = yield this._fetchBytes("0x59d1d43c", vu(t));
                    return null == n || "0x" === n ? null : ac(n)
                }))
            }
        }
        let Xh = null,
            ef = 1;
        class tf extends $d {
            constructor(e) {
                if (super(), this._events = [], this._emitted = {
                        block: -2
                    }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), Hl(this, "anyNetwork", "any" === e), this.anyNetwork && (e = this.detectNetwork()), e instanceof Promise) this._networkPromise = e, e.catch((e => {})), this._ready().catch((e => {}));
                else {
                    const t = $l(new.target, "getNetwork")(e);
                    t ? (Hl(this, "_network", t), this.emit("network", t, null)) : Th.throwArgumentError("invalid network", "network", e)
                }
                this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0
            }
            _ready() {
                return Oh(this, void 0, void 0, (function*() {
                    if (null == this._network) {
                        let t = null;
                        if (this._networkPromise) try {
                            t = yield this._networkPromise
                        } catch (e) {}
                        null == t && (t = yield this.detectNetwork()), t || Th.throwError("no network detected", zl.errors.UNKNOWN_ERROR, {}), null == this._network && (this.anyNetwork ? this._network = t : Hl(this, "_network", t), this.emit("network", t, null))
                    }
                    return this._network
                }))
            }
            get ready() {
                return Ud((() => this._ready().then((e => e), (e => {
                    if (e.code !== zl.errors.NETWORK_ERROR || "noNetwork" !== e.event) throw e
                }))))
            }
            static getFormatter() {
                return null == Xh && (Xh = new Ih), Xh
            }
            static getNetwork(e) {
                return function(e) {
                    if (null == e) return null;
                    if ("number" === typeof e) {
                        for (const t in Ph) {
                            const n = Ph[t];
                            if (n.chainId === e) return {
                                name: n.name,
                                chainId: n.chainId,
                                ensAddress: n.ensAddress || null,
                                _defaultProvider: n._defaultProvider || null
                            }
                        }
                        return {
                            chainId: e,
                            name: "unknown"
                        }
                    }
                    if ("string" === typeof e) {
                        const t = Ph[e];
                        return null == t ? null : {
                            name: t.name,
                            chainId: t.chainId,
                            ensAddress: t.ensAddress,
                            _defaultProvider: t._defaultProvider || null
                        }
                    }
                    const t = Ph[e.name];
                    if (!t) return "number" !== typeof e.chainId && wh.throwArgumentError("invalid network chainId", "network", e), e;
                    0 !== e.chainId && e.chainId !== t.chainId && wh.throwArgumentError("network chainId mismatch", "network", e);
                    let n = e._defaultProvider || null;
                    var r;
                    return null == n && t._defaultProvider && (n = (r = t._defaultProvider) && "function" === typeof r.renetwork ? t._defaultProvider.renetwork(e) : t._defaultProvider), {
                        name: e.name,
                        chainId: t.chainId,
                        ensAddress: e.ensAddress || t.ensAddress || null,
                        _defaultProvider: n
                    }
                }(null == e ? "homestead" : e)
            }
            ccipReadFetch(e, t, n) {
                return Oh(this, void 0, void 0, (function*() {
                    if (this.disableCcipRead || 0 === n.length) return null;
                    const r = e.to.toLowerCase(),
                        i = t.toLowerCase(),
                        o = [];
                    for (let e = 0; e < n.length; e++) {
                        const t = n[e],
                            s = t.replace("{sender}", r).replace("{data}", i),
                            a = t.indexOf("{data}") >= 0 ? null : JSON.stringify({
                                data: i,
                                sender: r
                            }),
                            l = yield Dd({
                                url: s,
                                errorPassThrough: !0
                            }, a, ((e, t) => (e.status = t.statusCode, e)));
                        if (l.data) return l.data;
                        const u = l.message || "unknown error";
                        if (l.status >= 400 && l.status < 500) return Th.throwError(`response not found during CCIP fetch: ${u}`, zl.errors.SERVER_ERROR, {
                            url: t,
                            errorMessage: u
                        });
                        o.push(u)
                    }
                    return Th.throwError(`error encountered during CCIP fetch: ${o.map((e=>JSON.stringify(e))).join(", ")}`, zl.errors.SERVER_ERROR, {
                        urls: n,
                        errorMessages: o
                    })
                }))
            }
            _getInternalBlockNumber(e) {
                return Oh(this, void 0, void 0, (function*() {
                    if (yield this._ready(), e > 0)
                        for (; this._internalBlockNumber;) {
                            const t = this._internalBlockNumber;
                            try {
                                const n = yield t;
                                if (Fh() - n.respTime <= e) return n.blockNumber;
                                break
                            } catch (r) {
                                if (this._internalBlockNumber === t) break
                            }
                        }
                    const t = Fh(),
                        n = Ql({
                            blockNumber: this.perform("getBlockNumber", {}),
                            networkError: this.getNetwork().then((e => null), (e => e))
                        }).then((e => {
                            let {
                                blockNumber: r,
                                networkError: i
                            } = e;
                            if (i) throw this._internalBlockNumber === n && (this._internalBlockNumber = null), i;
                            const o = Fh();
                            return r = Mu.from(r).toNumber(), r < this._maxInternalBlockNumber && (r = this._maxInternalBlockNumber), this._maxInternalBlockNumber = r, this._setFastBlockNumber(r), {
                                blockNumber: r,
                                reqTime: t,
                                respTime: o
                            }
                        }));
                    return this._internalBlockNumber = n, n.catch((e => {
                        this._internalBlockNumber === n && (this._internalBlockNumber = null)
                    })), (yield n).blockNumber
                }))
            }
            poll() {
                return Oh(this, void 0, void 0, (function*() {
                    const e = ef++,
                        t = [];
                    let n = null;
                    try {
                        n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
                    } catch (r) {
                        return void this.emit("error", r)
                    }
                    if (this._setFastBlockNumber(n), this.emit("poll", e, n), n !== this._lastBlockNumber) {
                        if (-2 === this._emitted.block && (this._emitted.block = n - 1), Math.abs(this._emitted.block - n) > 1e3) Th.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${n})`), this.emit("error", Th.makeError("network block skew detected", zl.errors.NETWORK_ERROR, {
                            blockNumber: n,
                            event: "blockSkew",
                            previousBlockNumber: this._emitted.block
                        })), this.emit("block", n);
                        else
                            for (let e = this._emitted.block + 1; e <= n; e++) this.emit("block", e);
                        this._emitted.block !== n && (this._emitted.block = n, Object.keys(this._emitted).forEach((e => {
                            if ("block" === e) return;
                            const t = this._emitted[e];
                            "pending" !== t && n - t > 12 && delete this._emitted[e]
                        }))), -2 === this._lastBlockNumber && (this._lastBlockNumber = n - 1), this._events.forEach((e => {
                            switch (e.type) {
                                case "tx":
                                    {
                                        const n = e.hash;
                                        let r = this.getTransactionReceipt(n).then((e => e && null != e.blockNumber ? (this._emitted["t:" + n] = e.blockNumber, this.emit(n, e), null) : null)).catch((e => {
                                            this.emit("error", e)
                                        }));t.push(r);
                                        break
                                    }
                                case "filter":
                                    if (!e._inflight) {
                                        e._inflight = !0, -2 === e._lastBlockNumber && (e._lastBlockNumber = n - 1);
                                        const r = e.filter;
                                        r.fromBlock = e._lastBlockNumber + 1, r.toBlock = n;
                                        const i = r.toBlock - this._maxFilterBlockRange;
                                        i > r.fromBlock && (r.fromBlock = i), r.fromBlock < 0 && (r.fromBlock = 0);
                                        const o = this.getLogs(r).then((t => {
                                            e._inflight = !1, 0 !== t.length && t.forEach((t => {
                                                t.blockNumber > e._lastBlockNumber && (e._lastBlockNumber = t.blockNumber), this._emitted["b:" + t.blockHash] = t.blockNumber, this._emitted["t:" + t.transactionHash] = t.blockNumber, this.emit(r, t)
                                            }))
                                        })).catch((t => {
                                            this.emit("error", t), e._inflight = !1
                                        }));
                                        t.push(o)
                                    }
                            }
                        })), this._lastBlockNumber = n, Promise.all(t).then((() => {
                            this.emit("didPoll", e)
                        })).catch((e => {
                            this.emit("error", e)
                        }))
                    } else this.emit("didPoll", e)
                }))
            }
            resetEventsBlock(e) {
                this._lastBlockNumber = e - 1, this.polling && this.poll()
            }
            get network() {
                return this._network
            }
            detectNetwork() {
                return Oh(this, void 0, void 0, (function*() {
                    return Th.throwError("provider does not support network detection", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "provider.detectNetwork"
                    })
                }))
            }
            getNetwork() {
                return Oh(this, void 0, void 0, (function*() {
                    const e = yield this._ready(), t = yield this.detectNetwork();
                    if (e.chainId !== t.chainId) {
                        if (this.anyNetwork) return this._network = t, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", t, e), yield jh(0), this._network;
                        const n = Th.makeError("underlying network changed", zl.errors.NETWORK_ERROR, {
                            event: "changed",
                            network: e,
                            detectedNetwork: t
                        });
                        throw this.emit("error", n), n
                    }
                    return e
                }))
            }
            get blockNumber() {
                return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((e => {
                    this._setFastBlockNumber(e)
                }), (e => {})), null != this._fastBlockNumber ? this._fastBlockNumber : -1
            }
            get polling() {
                return null != this._poller
            }
            set polling(e) {
                e && !this._poller ? (this._poller = setInterval((() => {
                    this.poll()
                }), this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout((() => {
                    this.poll(), this._bootstrapPoll = setTimeout((() => {
                        this._poller || this.poll(), this._bootstrapPoll = null
                    }), this.pollingInterval)
                }), 0))) : !e && this._poller && (clearInterval(this._poller), this._poller = null)
            }
            get pollingInterval() {
                return this._pollingInterval
            }
            set pollingInterval(e) {
                if ("number" !== typeof e || e <= 0 || parseInt(String(e)) != e) throw new Error("invalid polling interval");
                this._pollingInterval = e, this._poller && (clearInterval(this._poller), this._poller = setInterval((() => {
                    this.poll()
                }), this._pollingInterval))
            }
            _getFastBlockNumber() {
                const e = Fh();
                return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e, this._fastBlockNumberPromise = this.getBlockNumber().then((e => ((null == this._fastBlockNumber || e > this._fastBlockNumber) && (this._fastBlockNumber = e), this._fastBlockNumber)))), this._fastBlockNumberPromise
            }
            _setFastBlockNumber(e) {
                null != this._fastBlockNumber && e < this._fastBlockNumber || (this._fastQueryDate = Fh(), (null == this._fastBlockNumber || e > this._fastBlockNumber) && (this._fastBlockNumber = e, this._fastBlockNumberPromise = Promise.resolve(e)))
            }
            waitForTransaction(e, t, n) {
                return Oh(this, void 0, void 0, (function*() {
                    return this._waitForTransaction(e, null == t ? 1 : t, n || 0, null)
                }))
            }
            _waitForTransaction(e, t, n, r) {
                return Oh(this, void 0, void 0, (function*() {
                    const i = yield this.getTransactionReceipt(e);
                    return (i ? i.confirmations : 0) >= t ? i : new Promise(((i, o) => {
                        const s = [];
                        let a = !1;
                        const l = function() {
                                return !!a || (a = !0, s.forEach((e => {
                                    e()
                                })), !1)
                            },
                            u = e => {
                                e.confirmations < t || l() || i(e)
                            };
                        if (this.on(e, u), s.push((() => {
                                this.removeListener(e, u)
                            })), r) {
                            let n = r.startBlock,
                                i = null;
                            const u = s => Oh(this, void 0, void 0, (function*() {
                                a || (yield jh(1e3), this.getTransactionCount(r.from).then((c => Oh(this, void 0, void 0, (function*() {
                                    if (!a) {
                                        if (c <= r.nonce) n = s;
                                        else {
                                            {
                                                const t = yield this.getTransaction(e);
                                                if (t && null != t.blockNumber) return
                                            }
                                            for (null == i && (i = n - 3, i < r.startBlock && (i = r.startBlock)); i <= s;) {
                                                if (a) return;
                                                const n = yield this.getBlockWithTransactions(i);
                                                for (let i = 0; i < n.transactions.length; i++) {
                                                    const s = n.transactions[i];
                                                    if (s.hash === e) return;
                                                    if (s.from === r.from && s.nonce === r.nonce) {
                                                        if (a) return;
                                                        const n = yield this.waitForTransaction(s.hash, t);
                                                        if (l()) return;
                                                        let i = "replaced";
                                                        return s.data === r.data && s.to === r.to && s.value.eq(r.value) ? i = "repriced" : "0x" === s.data && s.from === s.to && s.value.isZero() && (i = "cancelled"), void o(Th.makeError("transaction was replaced", zl.errors.TRANSACTION_REPLACED, {
                                                            cancelled: "replaced" === i || "cancelled" === i,
                                                            reason: i,
                                                            replacement: this._wrapTransaction(s),
                                                            hash: e,
                                                            receipt: n
                                                        }))
                                                    }
                                                }
                                                i++
                                            }
                                        }
                                        a || this.once("block", u)
                                    }
                                }))), (e => {
                                    a || this.once("block", u)
                                })))
                            }));
                            if (a) return;
                            this.once("block", u), s.push((() => {
                                this.removeListener("block", u)
                            }))
                        }
                        if ("number" === typeof n && n > 0) {
                            const e = setTimeout((() => {
                                l() || o(Th.makeError("timeout exceeded", zl.errors.TIMEOUT, {
                                    timeout: n
                                }))
                            }), n);
                            e.unref && e.unref(), s.push((() => {
                                clearTimeout(e)
                            }))
                        }
                    }))
                }))
            }
            getBlockNumber() {
                return Oh(this, void 0, void 0, (function*() {
                    return this._getInternalBlockNumber(0)
                }))
            }
            getGasPrice() {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const e = yield this.perform("getGasPrice", {});
                    try {
                        return Mu.from(e)
                    } catch (t) {
                        return Th.throwError("bad result from backend", zl.errors.SERVER_ERROR, {
                            method: "getGasPrice",
                            result: e,
                            error: t
                        })
                    }
                }))
            }
            getBalance(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const n = yield Ql({
                        address: this._getAddress(e),
                        blockTag: this._getBlockTag(t)
                    }), r = yield this.perform("getBalance", n);
                    try {
                        return Mu.from(r)
                    } catch (i) {
                        return Th.throwError("bad result from backend", zl.errors.SERVER_ERROR, {
                            method: "getBalance",
                            params: n,
                            result: r,
                            error: i
                        })
                    }
                }))
            }
            getTransactionCount(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const n = yield Ql({
                        address: this._getAddress(e),
                        blockTag: this._getBlockTag(t)
                    }), r = yield this.perform("getTransactionCount", n);
                    try {
                        return Mu.from(r).toNumber()
                    } catch (i) {
                        return Th.throwError("bad result from backend", zl.errors.SERVER_ERROR, {
                            method: "getTransactionCount",
                            params: n,
                            result: r,
                            error: i
                        })
                    }
                }))
            }
            getCode(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const n = yield Ql({
                        address: this._getAddress(e),
                        blockTag: this._getBlockTag(t)
                    }), r = yield this.perform("getCode", n);
                    try {
                        return vu(r)
                    } catch (i) {
                        return Th.throwError("bad result from backend", zl.errors.SERVER_ERROR, {
                            method: "getCode",
                            params: n,
                            result: r,
                            error: i
                        })
                    }
                }))
            }
            getStorageAt(e, t, n) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const r = yield Ql({
                        address: this._getAddress(e),
                        blockTag: this._getBlockTag(n),
                        position: Promise.resolve(t).then((e => xu(e)))
                    }), i = yield this.perform("getStorageAt", r);
                    try {
                        return vu(i)
                    } catch (o) {
                        return Th.throwError("bad result from backend", zl.errors.SERVER_ERROR, {
                            method: "getStorageAt",
                            params: r,
                            result: i,
                            error: o
                        })
                    }
                }))
            }
            _wrapTransaction(e, t, n) {
                if (null != t && 32 !== bu(t)) throw new Error("invalid response - sendTransaction");
                const r = e;
                return null != t && e.hash !== t && Th.throwError("Transaction hash mismatch from Provider.sendTransaction.", zl.errors.UNKNOWN_ERROR, {
                    expectedHash: e.hash,
                    returnedHash: t
                }), r.wait = (t, r) => Oh(this, void 0, void 0, (function*() {
                    let i;
                    null == t && (t = 1), null == r && (r = 0), 0 !== t && null != n && (i = {
                        data: e.data,
                        from: e.from,
                        nonce: e.nonce,
                        to: e.to,
                        value: e.value,
                        startBlock: n
                    });
                    const o = yield this._waitForTransaction(e.hash, t, r, i);
                    return null == o && 0 === t ? null : (this._emitted["t:" + e.hash] = o.blockNumber, 0 === o.status && Th.throwError("transaction failed", zl.errors.CALL_EXCEPTION, {
                        transactionHash: e.hash,
                        transaction: e,
                        receipt: o
                    }), o)
                })), r
            }
            sendTransaction(e) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const t = yield Promise.resolve(e).then((e => vu(e))), n = this.formatter.transaction(e);
                    null == n.confirmations && (n.confirmations = 0);
                    const r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    try {
                        const e = yield this.perform("sendTransaction", {
                            signedTransaction: t
                        });
                        return this._wrapTransaction(n, e, r)
                    } catch (i) {
                        throw i.transaction = n, i.transactionHash = n.hash, i
                    }
                }))
            }
            _getTransactionRequest(e) {
                return Oh(this, void 0, void 0, (function*() {
                    const t = yield e, n = {};
                    return ["from", "to"].forEach((e => {
                        null != t[e] && (n[e] = Promise.resolve(t[e]).then((e => e ? this._getAddress(e) : null)))
                    })), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((e => {
                        null != t[e] && (n[e] = Promise.resolve(t[e]).then((e => e ? Mu.from(e) : null)))
                    })), ["type"].forEach((e => {
                        null != t[e] && (n[e] = Promise.resolve(t[e]).then((e => null != e ? e : null)))
                    })), t.accessList && (n.accessList = this.formatter.accessList(t.accessList)), ["data"].forEach((e => {
                        null != t[e] && (n[e] = Promise.resolve(t[e]).then((e => e ? vu(e) : null)))
                    })), this.formatter.transactionRequest(yield Ql(n))
                }))
            }
            _getFilter(e) {
                return Oh(this, void 0, void 0, (function*() {
                    e = yield e;
                    const t = {};
                    return null != e.address && (t.address = this._getAddress(e.address)), ["blockHash", "topics"].forEach((n => {
                        null != e[n] && (t[n] = e[n])
                    })), ["fromBlock", "toBlock"].forEach((n => {
                        null != e[n] && (t[n] = this._getBlockTag(e[n]))
                    })), this.formatter.filter(yield Ql(t))
                }))
            }
            _call(e, t, n) {
                return Oh(this, void 0, void 0, (function*() {
                    n >= 10 && Th.throwError("CCIP read exceeded maximum redirections", zl.errors.SERVER_ERROR, {
                        redirects: n,
                        transaction: e
                    });
                    const r = e.to,
                        i = yield this.perform("call", {
                            transaction: e,
                            blockTag: t
                        });
                    if (n >= 0 && "latest" === t && null != r && "0x556f1830" === i.substring(0, 10) && bu(i) % 32 === 4) try {
                        const o = wu(i, 4),
                            s = wu(o, 0, 32);
                        Mu.from(s).eq(r) || Th.throwError("CCIP Read sender did not match", zl.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: e,
                            data: i
                        });
                        const a = [],
                            l = Mu.from(wu(o, 32, 64)).toNumber(),
                            u = Mu.from(wu(o, l, l + 32)).toNumber(),
                            c = wu(o, l + 32);
                        for (let t = 0; t < u; t++) {
                            const n = Qh(c, 32 * t);
                            null == n && Th.throwError("CCIP Read contained corrupt URL string", zl.errors.CALL_EXCEPTION, {
                                name: "OffchainLookup",
                                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                                transaction: e,
                                data: i
                            }), a.push(n)
                        }
                        const d = Vh(o, 64);
                        Mu.from(wu(o, 100, 128)).isZero() || Th.throwError("CCIP Read callback selector included junk", zl.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: e,
                            data: i
                        });
                        const h = wu(o, 96, 100),
                            f = Vh(o, 128),
                            p = yield this.ccipReadFetch(e, d, a);
                        null == p && Th.throwError("CCIP Read disabled or provided no URLs", zl.errors.CALL_EXCEPTION, {
                            name: "OffchainLookup",
                            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                            transaction: e,
                            data: i
                        });
                        const m = {
                            to: r,
                            data: Eu([h, Zh([p, f])])
                        };
                        return this._call(m, t, n + 1)
                    } catch (o) {
                        if (o.code === zl.errors.SERVER_ERROR) throw o
                    }
                    try {
                        return vu(i)
                    } catch (o) {
                        return Th.throwError("bad result from backend", zl.errors.SERVER_ERROR, {
                            method: "call",
                            params: {
                                transaction: e,
                                blockTag: t
                            },
                            result: i,
                            error: o
                        })
                    }
                }))
            }
            call(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const n = yield Ql({
                        transaction: this._getTransactionRequest(e),
                        blockTag: this._getBlockTag(t),
                        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
                    });
                    return this._call(n.transaction, n.blockTag, n.ccipReadEnabled ? 0 : -1)
                }))
            }
            estimateGas(e) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const t = yield Ql({
                        transaction: this._getTransactionRequest(e)
                    }), n = yield this.perform("estimateGas", t);
                    try {
                        return Mu.from(n)
                    } catch (r) {
                        return Th.throwError("bad result from backend", zl.errors.SERVER_ERROR, {
                            method: "estimateGas",
                            params: t,
                            result: n,
                            error: r
                        })
                    }
                }))
            }
            _getAddress(e) {
                return Oh(this, void 0, void 0, (function*() {
                    "string" !== typeof(e = yield e) && Th.throwArgumentError("invalid address or ENS name", "name", e);
                    const t = yield this.resolveName(e);
                    return null == t && Th.throwError("ENS name not configured", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: `resolveName(${JSON.stringify(e)})`
                    }), t
                }))
            }
            _getBlock(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork(), e = yield e;
                    let n = -128;
                    const r = {
                        includeTransactions: !!t
                    };
                    if (gu(e, 32)) r.blockHash = e;
                    else try {
                        r.blockTag = yield this._getBlockTag(e), gu(r.blockTag) && (n = parseInt(r.blockTag.substring(2), 16))
                    } catch (i) {
                        Th.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e)
                    }
                    return Ud((() => Oh(this, void 0, void 0, (function*() {
                        const e = yield this.perform("getBlock", r);
                        if (null == e) return null != r.blockHash && null == this._emitted["b:" + r.blockHash] || null != r.blockTag && n > this._emitted.block ? null : void 0;
                        if (t) {
                            let t = null;
                            for (let r = 0; r < e.transactions.length; r++) {
                                const n = e.transactions[r];
                                if (null == n.blockNumber) n.confirmations = 0;
                                else if (null == n.confirmations) {
                                    null == t && (t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                                    let e = t - n.blockNumber + 1;
                                    e <= 0 && (e = 1), n.confirmations = e
                                }
                            }
                            const n = this.formatter.blockWithTransactions(e);
                            return n.transactions = n.transactions.map((e => this._wrapTransaction(e))), n
                        }
                        return this.formatter.block(e)
                    }))), {
                        oncePoll: this
                    })
                }))
            }
            getBlock(e) {
                return this._getBlock(e, !1)
            }
            getBlockWithTransactions(e) {
                return this._getBlock(e, !0)
            }
            getTransaction(e) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork(), e = yield e;
                    const t = {
                        transactionHash: this.formatter.hash(e, !0)
                    };
                    return Ud((() => Oh(this, void 0, void 0, (function*() {
                        const n = yield this.perform("getTransaction", t);
                        if (null == n) return null == this._emitted["t:" + e] ? null : void 0;
                        const r = this.formatter.transactionResponse(n);
                        if (null == r.blockNumber) r.confirmations = 0;
                        else if (null == r.confirmations) {
                            let e = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1;
                            e <= 0 && (e = 1), r.confirmations = e
                        }
                        return this._wrapTransaction(r)
                    }))), {
                        oncePoll: this
                    })
                }))
            }
            getTransactionReceipt(e) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork(), e = yield e;
                    const t = {
                        transactionHash: this.formatter.hash(e, !0)
                    };
                    return Ud((() => Oh(this, void 0, void 0, (function*() {
                        const n = yield this.perform("getTransactionReceipt", t);
                        if (null == n) return null == this._emitted["t:" + e] ? null : void 0;
                        if (null == n.blockHash) return;
                        const r = this.formatter.receipt(n);
                        if (null == r.blockNumber) r.confirmations = 0;
                        else if (null == r.confirmations) {
                            let e = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1;
                            e <= 0 && (e = 1), r.confirmations = e
                        }
                        return r
                    }))), {
                        oncePoll: this
                    })
                }))
            }
            getLogs(e) {
                return Oh(this, void 0, void 0, (function*() {
                    yield this.getNetwork();
                    const t = yield Ql({
                        filter: this._getFilter(e)
                    }), n = yield this.perform("getLogs", t);
                    return n.forEach((e => {
                        null == e.removed && (e.removed = !1)
                    })), Ih.arrayOf(this.formatter.filterLog.bind(this.formatter))(n)
                }))
            }
            getEtherPrice() {
                return Oh(this, void 0, void 0, (function*() {
                    return yield this.getNetwork(), this.perform("getEtherPrice", {})
                }))
            }
            _getBlockTag(e) {
                return Oh(this, void 0, void 0, (function*() {
                    if ("number" === typeof(e = yield e) && e < 0) {
                        e % 1 && Th.throwArgumentError("invalid BlockTag", "blockTag", e);
                        let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                        return t += e, t < 0 && (t = 0), this.formatter.blockTag(t)
                    }
                    return this.formatter.blockTag(e)
                }))
            }
            getResolver(e) {
                return Oh(this, void 0, void 0, (function*() {
                    let t = e;
                    for (;;) {
                        if ("" === t || "." === t) return null;
                        if ("eth" !== e && "eth" === t) return null;
                        const n = yield this._getResolver(t, "getResolver");
                        if (null != n) {
                            const r = new Yh(this, n, e);
                            return t === e || (yield r.supportsWildcard()) ? r : null
                        }
                        t = t.split(".").slice(1).join(".")
                    }
                }))
            }
            _getResolver(e, t) {
                return Oh(this, void 0, void 0, (function*() {
                    null == t && (t = "ENS");
                    const n = yield this.getNetwork();
                    n.ensAddress || Th.throwError("network does not support ENS", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: t,
                        network: n.name
                    });
                    try {
                        const t = yield this.call({
                            to: n.ensAddress,
                            data: "0x0178b8bf" + bh(e).substring(2)
                        });
                        return this.formatter.callAddress(t)
                    } catch (r) {}
                    return null
                }))
            }
            resolveName(e) {
                return Oh(this, void 0, void 0, (function*() {
                    e = yield e;
                    try {
                        return Promise.resolve(this.formatter.address(e))
                    } catch (n) {
                        if (gu(e)) throw n
                    }
                    "string" !== typeof e && Th.throwArgumentError("invalid ENS name", "name", e);
                    const t = yield this.getResolver(e);
                    return t ? yield t.getAddress(): null
                }))
            }
            lookupAddress(e) {
                return Oh(this, void 0, void 0, (function*() {
                    e = yield e;
                    const t = (e = this.formatter.address(e)).substring(2).toLowerCase() + ".addr.reverse",
                        n = yield this._getResolver(t, "lookupAddress");
                    if (null == n) return null;
                    const r = Qh(yield this.call({
                        to: n,
                        data: "0x691f3431" + bh(t).substring(2)
                    }), 0);
                    return (yield this.resolveName(r)) != e ? null : r
                }))
            }
            getAvatar(e) {
                return Oh(this, void 0, void 0, (function*() {
                    let t = null;
                    if (gu(e)) {
                        const n = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse",
                            i = yield this._getResolver(n, "getAvatar");
                        if (!i) return null;
                        t = new Yh(this, i, n);
                        try {
                            const e = yield t.getAvatar();
                            if (e) return e.url
                        } catch (r) {
                            if (r.code !== zl.errors.CALL_EXCEPTION) throw r
                        }
                        try {
                            const e = Qh(yield this.call({
                                to: i,
                                data: "0x691f3431" + bh(n).substring(2)
                            }), 0);
                            t = yield this.getResolver(e)
                        } catch (r) {
                            if (r.code !== zl.errors.CALL_EXCEPTION) throw r;
                            return null
                        }
                    } else if (t = yield this.getResolver(e), !t) return null;
                    const n = yield t.getAvatar();
                    return null == n ? null : n.url
                }))
            }
            perform(e, t) {
                return Th.throwError(e + " not implemented", zl.errors.NOT_IMPLEMENTED, {
                    operation: e
                })
            }
            _startEvent(e) {
                this.polling = this._events.filter((e => e.pollable())).length > 0
            }
            _stopEvent(e) {
                this.polling = this._events.filter((e => e.pollable())).length > 0
            }
            _addEventListener(e, t, n) {
                const r = new Uh(Bh(e), t, n);
                return this._events.push(r), this._startEvent(r), this
            }
            on(e, t) {
                return this._addEventListener(e, t, !1)
            }
            once(e, t) {
                return this._addEventListener(e, t, !0)
            }
            emit(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                let i = !1,
                    o = [],
                    s = Bh(e);
                return this._events = this._events.filter((e => e.tag !== s || (setTimeout((() => {
                    e.listener.apply(this, n)
                }), 0), i = !0, !e.once || (o.push(e), !1)))), o.forEach((e => {
                    this._stopEvent(e)
                })), i
            }
            listenerCount(e) {
                if (!e) return this._events.length;
                let t = Bh(e);
                return this._events.filter((e => e.tag === t)).length
            }
            listeners(e) {
                if (null == e) return this._events.map((e => e.listener));
                let t = Bh(e);
                return this._events.filter((e => e.tag === t)).map((e => e.listener))
            }
            off(e, t) {
                if (null == t) return this.removeAllListeners(e);
                const n = [];
                let r = !1,
                    i = Bh(e);
                return this._events = this._events.filter((e => e.tag !== i || e.listener != t || (!!r || (r = !0, n.push(e), !1)))), n.forEach((e => {
                    this._stopEvent(e)
                })), this
            }
            removeAllListeners(e) {
                let t = [];
                if (null == e) t = this._events, this._events = [];
                else {
                    const n = Bh(e);
                    this._events = this._events.filter((e => e.tag !== n || (t.push(e), !1)))
                }
                return t.forEach((e => {
                    this._stopEvent(e)
                })), this
            }
        }
        var nf = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const rf = new zl(zd),
            of = ["call", "estimateGas"];

        function sf(e, t) {
            if (null == e) return null;
            if ("string" === typeof e.message && e.message.match("reverted")) {
                const n = gu(e.data) ? e.data : null;
                if (!t || n) return {
                    message: e.message,
                    data: n
                }
            }
            if ("object" === typeof e) {
                for (const n in e) {
                    const r = sf(e[n], t);
                    if (r) return r
                }
                return null
            }
            if ("string" === typeof e) try {
                return sf(JSON.parse(e), t)
            } catch (n) {}
            return null
        }

        function af(e, t, n) {
            const r = n.transaction || n.signedTransaction;
            if ("call" === e) {
                const e = sf(t, !0);
                if (e) return e.data;
                rf.throwError("missing revert data in call exception; Transaction reverted without a reason string", zl.errors.CALL_EXCEPTION, {
                    data: "0x",
                    transaction: r,
                    error: t
                })
            }
            if ("estimateGas" === e) {
                let n = sf(t.body, !1);
                null == n && (n = sf(t, !1)), n && rf.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", zl.errors.UNPREDICTABLE_GAS_LIMIT, {
                    reason: n.message,
                    method: e,
                    transaction: r,
                    error: t
                })
            }
            let i = t.message;
            throw t.code === zl.errors.SERVER_ERROR && t.error && "string" === typeof t.error.message ? i = t.error.message : "string" === typeof t.body ? i = t.body : "string" === typeof t.responseText && (i = t.responseText), i = (i || "").toLowerCase(), i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && rf.throwError("insufficient funds for intrinsic transaction cost", zl.errors.INSUFFICIENT_FUNDS, {
                error: t,
                method: e,
                transaction: r
            }), i.match(/nonce (is )?too low/i) && rf.throwError("nonce has already been used", zl.errors.NONCE_EXPIRED, {
                error: t,
                method: e,
                transaction: r
            }), i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && rf.throwError("replacement fee too low", zl.errors.REPLACEMENT_UNDERPRICED, {
                error: t,
                method: e,
                transaction: r
            }), i.match(/only replay-protected/i) && rf.throwError("legacy pre-eip-155 transactions not supported", zl.errors.UNSUPPORTED_OPERATION, {
                error: t,
                method: e,
                transaction: r
            }), of .indexOf(e) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && rf.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", zl.errors.UNPREDICTABLE_GAS_LIMIT, {
                error: t,
                method: e,
                transaction: r
            }), t
        }

        function lf(e) {
            return new Promise((function(t) {
                setTimeout(t, e)
            }))
        }

        function uf(e) {
            if (e.error) {
                const t = new Error(e.error.message);
                throw t.code = e.error.code, t.data = e.error.data, t
            }
            return e.result
        }

        function cf(e) {
            return e ? e.toLowerCase() : e
        }
        const df = {};
        class hf extends ru {
            constructor(e, t, n) {
                if (super(), e !== df) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
                Hl(this, "provider", t), null == n && (n = 0), "string" === typeof n ? (Hl(this, "_address", this.provider.formatter.address(n)), Hl(this, "_index", null)) : "number" === typeof n ? (Hl(this, "_index", n), Hl(this, "_address", null)) : rf.throwArgumentError("invalid address or index", "addressOrIndex", n)
            }
            connect(e) {
                return rf.throwError("cannot alter JSON-RPC Signer connection", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "connect"
                })
            }
            connectUnchecked() {
                return new ff(df, this.provider, this._address || this._index)
            }
            getAddress() {
                return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((e => (e.length <= this._index && rf.throwError("unknown account #" + this._index, zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "getAddress"
                }), this.provider.formatter.address(e[this._index]))))
            }
            sendUncheckedTransaction(e) {
                e = Vl(e);
                const t = this.getAddress().then((e => (e && (e = e.toLowerCase()), e)));
                if (null == e.gasLimit) {
                    const n = Vl(e);
                    n.from = t, e.gasLimit = this.provider.estimateGas(n)
                }
                return null != e.to && (e.to = Promise.resolve(e.to).then((e => nf(this, void 0, void 0, (function*() {
                    if (null == e) return null;
                    const t = yield this.provider.resolveName(e);
                    return null == t && rf.throwArgumentError("provided ENS name resolves to null", "tx.to", e), t
                }))))), Ql({
                    tx: Ql(e),
                    sender: t
                }).then((t => {
                    let {
                        tx: n,
                        sender: r
                    } = t;
                    null != n.from ? n.from.toLowerCase() !== r && rf.throwArgumentError("from address mismatch", "transaction", e) : n.from = r;
                    const i = this.provider.constructor.hexlifyTransaction(n, {
                        from: !0
                    });
                    return this.provider.send("eth_sendTransaction", [i]).then((e => e), (e => ("string" === typeof e.message && e.message.match(/user denied/i) && rf.throwError("user rejected transaction", zl.errors.ACTION_REJECTED, {
                        action: "sendTransaction",
                        transaction: n
                    }), af("sendTransaction", e, i))))
                }))
            }
            signTransaction(e) {
                return rf.throwError("signing transactions is unsupported", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "signTransaction"
                })
            }
            sendTransaction(e) {
                return nf(this, void 0, void 0, (function*() {
                    const t = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), n = yield this.sendUncheckedTransaction(e);
                    try {
                        return yield Ud((() => nf(this, void 0, void 0, (function*() {
                            const e = yield this.provider.getTransaction(n);
                            if (null !== e) return this.provider._wrapTransaction(e, n, t)
                        }))), {
                            oncePoll: this.provider
                        })
                    } catch (r) {
                        throw r.transactionHash = n, r
                    }
                }))
            }
            signMessage(e) {
                return nf(this, void 0, void 0, (function*() {
                    const t = "string" === typeof e ? sc(e) : e,
                        n = yield this.getAddress();
                    try {
                        return yield this.provider.send("personal_sign", [vu(t), n.toLowerCase()])
                    } catch (r) {
                        throw "string" === typeof r.message && r.message.match(/user denied/i) && rf.throwError("user rejected signing", zl.errors.ACTION_REJECTED, {
                            action: "signMessage",
                            from: n,
                            messageData: e
                        }), r
                    }
                }))
            }
            _legacySignMessage(e) {
                return nf(this, void 0, void 0, (function*() {
                    const t = "string" === typeof e ? sc(e) : e,
                        n = yield this.getAddress();
                    try {
                        return yield this.provider.send("eth_sign", [n.toLowerCase(), vu(t)])
                    } catch (r) {
                        throw "string" === typeof r.message && r.message.match(/user denied/i) && rf.throwError("user rejected signing", zl.errors.ACTION_REJECTED, {
                            action: "_legacySignMessage",
                            from: n,
                            messageData: e
                        }), r
                    }
                }))
            }
            _signTypedData(e, t, n) {
                return nf(this, void 0, void 0, (function*() {
                    const r = yield kc.resolveNames(e, t, n, (e => this.provider.resolveName(e))), i = yield this.getAddress();
                    try {
                        return yield this.provider.send("eth_signTypedData_v4", [i.toLowerCase(), JSON.stringify(kc.getPayload(r.domain, t, r.value))])
                    } catch (o) {
                        throw "string" === typeof o.message && o.message.match(/user denied/i) && rf.throwError("user rejected signing", zl.errors.ACTION_REJECTED, {
                            action: "_signTypedData",
                            from: i,
                            messageData: {
                                domain: r.domain,
                                types: t,
                                value: r.value
                            }
                        }), o
                    }
                }))
            }
            unlock(e) {
                return nf(this, void 0, void 0, (function*() {
                    const t = this.provider,
                        n = yield this.getAddress();
                    return t.send("personal_unlockAccount", [n.toLowerCase(), e, null])
                }))
            }
        }
        class ff extends hf {
            sendTransaction(e) {
                return this.sendUncheckedTransaction(e).then((e => ({
                    hash: e,
                    nonce: null,
                    gasLimit: null,
                    gasPrice: null,
                    data: null,
                    value: null,
                    chainId: null,
                    confirmations: 0,
                    from: null,
                    wait: t => this.provider.waitForTransaction(e, t)
                })))
            }
        }
        const pf = {
            chainId: !0,
            data: !0,
            gasLimit: !0,
            gasPrice: !0,
            nonce: !0,
            to: !0,
            value: !0,
            type: !0,
            accessList: !0,
            maxFeePerGas: !0,
            maxPriorityFeePerGas: !0
        };
        const mf = "abi/5.7.0",
            gf = new zl(mf);
        class yf {
            constructor(e, t, n, r) {
                this.name = e, this.type = t, this.localName = n, this.dynamic = r
            }
            _throwError(e, t) {
                gf.throwArgumentError(e, this.localName, t)
            }
        }
        class vf {
            constructor(e) {
                Hl(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e)
            }
            get data() {
                return Eu(this._data)
            }
            get length() {
                return this._dataLength
            }
            _writeData(e) {
                return this._data.push(e), this._dataLength += e.length, e.length
            }
            appendWriter(e) {
                return this._writeData(pu(e._data))
            }
            writeBytes(e) {
                let t = fu(e);
                const n = t.length % this.wordSize;
                return n && (t = pu([t, this._padding.slice(n)])), this._writeData(t)
            }
            _getValue(e) {
                let t = fu(Mu.from(e));
                return t.length > this.wordSize && gf.throwError("value out-of-bounds", zl.errors.BUFFER_OVERRUN, {
                    length: this.wordSize,
                    offset: t.length
                }), t.length % this.wordSize && (t = pu([this._padding.slice(t.length % this.wordSize), t])), t
            }
            writeValue(e) {
                return this._writeData(this._getValue(e))
            }
            writeUpdatableValue() {
                const e = this._data.length;
                return this._data.push(this._padding), this._dataLength += this.wordSize, t => {
                    this._data[e] = this._getValue(t)
                }
            }
        }
        class bf {
            constructor(e, t, n, r) {
                Hl(this, "_data", fu(e)), Hl(this, "wordSize", t || 32), Hl(this, "_coerceFunc", n), Hl(this, "allowLoose", r), this._offset = 0
            }
            get data() {
                return vu(this._data)
            }
            get consumed() {
                return this._offset
            }
            static coerce(e, t) {
                let n = e.match("^u?int([0-9]+)$");
                return n && parseInt(n[1]) <= 48 && (t = t.toNumber()), t
            }
            coerce(e, t) {
                return this._coerceFunc ? this._coerceFunc(e, t) : bf.coerce(e, t)
            }
            _peekBytes(e, t, n) {
                let r = Math.ceil(t / this.wordSize) * this.wordSize;
                return this._offset + r > this._data.length && (this.allowLoose && n && this._offset + t <= this._data.length ? r = t : gf.throwError("data out-of-bounds", zl.errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + r
                })), this._data.slice(this._offset, this._offset + r)
            }
            subReader(e) {
                return new bf(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose)
            }
            readBytes(e, t) {
                let n = this._peekBytes(0, e, !!t);
                return this._offset += n.length, n.slice(0, e)
            }
            readValue() {
                return Mu.from(this.readBytes(this.wordSize))
            }
        }
        class wf extends yf {
            constructor(e) {
                super("address", "address", e, !1)
            }
            defaultValue() {
                return "0x0000000000000000000000000000000000000000"
            }
            encode(e, t) {
                try {
                    t = Zu(t)
                } catch (n) {
                    this._throwError(n.message, t)
                }
                return e.writeValue(t)
            }
            decode(e) {
                return Zu(Au(e.readValue().toHexString(), 20))
            }
        }
        class Ef extends yf {
            constructor(e) {
                super(e.name, e.type, void 0, e.dynamic), this.coder = e
            }
            defaultValue() {
                return this.coder.defaultValue()
            }
            encode(e, t) {
                return this.coder.encode(e, t)
            }
            decode(e) {
                return this.coder.decode(e)
            }
        }
        const xf = new zl(mf);

        function Af(e, t, n) {
            let r = null;
            if (Array.isArray(n)) r = n;
            else if (n && "object" === typeof n) {
                let e = {};
                r = t.map((t => {
                    const r = t.localName;
                    return r || xf.throwError("cannot encode object for signature with missing names", zl.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: t,
                        value: n
                    }), e[r] && xf.throwError("cannot encode object for signature with duplicate names", zl.errors.INVALID_ARGUMENT, {
                        argument: "values",
                        coder: t,
                        value: n
                    }), e[r] = !0, n[r]
                }))
            } else xf.throwArgumentError("invalid tuple value", "tuple", n);
            t.length !== r.length && xf.throwArgumentError("types/value length mismatch", "tuple", n);
            let i = new vf(e.wordSize),
                o = new vf(e.wordSize),
                s = [];
            t.forEach(((e, t) => {
                let n = r[t];
                if (e.dynamic) {
                    let t = o.length;
                    e.encode(o, n);
                    let r = i.writeUpdatableValue();
                    s.push((e => {
                        r(e + t)
                    }))
                } else e.encode(i, n)
            })), s.forEach((e => {
                e(i.length)
            }));
            let a = e.appendWriter(i);
            return a += e.appendWriter(o), a
        }

        function kf(e, t) {
            let n = [],
                r = e.subReader(0);
            t.forEach((t => {
                let i = null;
                if (t.dynamic) {
                    let n = e.readValue(),
                        s = r.subReader(n.toNumber());
                    try {
                        i = t.decode(s)
                    } catch (o) {
                        if (o.code === zl.errors.BUFFER_OVERRUN) throw o;
                        i = o, i.baseType = t.name, i.name = t.localName, i.type = t.type
                    }
                } else try {
                    i = t.decode(e)
                } catch (o) {
                    if (o.code === zl.errors.BUFFER_OVERRUN) throw o;
                    i = o, i.baseType = t.name, i.name = t.localName, i.type = t.type
                }
                void 0 != i && n.push(i)
            }));
            const i = t.reduce(((e, t) => {
                const n = t.localName;
                return n && (e[n] || (e[n] = 0), e[n]++), e
            }), {});
            t.forEach(((e, t) => {
                let r = e.localName;
                if (!r || 1 !== i[r]) return;
                if ("length" === r && (r = "_length"), null != n[r]) return;
                const o = n[t];
                o instanceof Error ? Object.defineProperty(n, r, {
                    enumerable: !0,
                    get: () => {
                        throw o
                    }
                }) : n[r] = o
            }));
            for (let o = 0; o < n.length; o++) {
                const e = n[o];
                e instanceof Error && Object.defineProperty(n, o, {
                    enumerable: !0,
                    get: () => {
                        throw e
                    }
                })
            }
            return Object.freeze(n)
        }
        class Cf extends yf {
            constructor(e, t, n) {
                super("array", e.type + "[" + (t >= 0 ? t : "") + "]", n, -1 === t || e.dynamic), this.coder = e, this.length = t
            }
            defaultValue() {
                const e = this.coder.defaultValue(),
                    t = [];
                for (let n = 0; n < this.length; n++) t.push(e);
                return t
            }
            encode(e, t) {
                Array.isArray(t) || this._throwError("expected array value", t);
                let n = this.length; - 1 === n && (n = t.length, e.writeValue(t.length)), xf.checkArgumentCount(t.length, n, "coder array" + (this.localName ? " " + this.localName : ""));
                let r = [];
                for (let i = 0; i < t.length; i++) r.push(this.coder);
                return Af(e, r, t)
            }
            decode(e) {
                let t = this.length; - 1 === t && (t = e.readValue().toNumber(), 32 * t > e._data.length && xf.throwError("insufficient data length", zl.errors.BUFFER_OVERRUN, {
                    length: e._data.length,
                    count: t
                }));
                let n = [];
                for (let r = 0; r < t; r++) n.push(new Ef(this.coder));
                return e.coerce(this.name, kf(e, n))
            }
        }
        class Pf extends yf {
            constructor(e) {
                super("bool", "bool", e, !1)
            }
            defaultValue() {
                return !1
            }
            encode(e, t) {
                return e.writeValue(t ? 1 : 0)
            }
            decode(e) {
                return e.coerce(this.type, !e.readValue().isZero())
            }
        }
        class Sf extends yf {
            constructor(e, t) {
                super(e, e, t, !0)
            }
            defaultValue() {
                return "0x"
            }
            encode(e, t) {
                t = fu(t);
                let n = e.writeValue(t.length);
                return n += e.writeBytes(t), n
            }
            decode(e) {
                return e.readBytes(e.readValue().toNumber(), !0)
            }
        }
        class _f extends Sf {
            constructor(e) {
                super("bytes", e)
            }
            decode(e) {
                return e.coerce(this.name, vu(super.decode(e)))
            }
        }
        class Nf extends yf {
            constructor(e, t) {
                let n = "bytes" + String(e);
                super(n, n, t, !1), this.size = e
            }
            defaultValue() {
                return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size)
            }
            encode(e, t) {
                let n = fu(t);
                return n.length !== this.size && this._throwError("incorrect data length", t), e.writeBytes(n)
            }
            decode(e) {
                return e.coerce(this.name, vu(e.readBytes(this.size)))
            }
        }
        class Mf extends yf {
            constructor(e) {
                super("null", "", e, !1)
            }
            defaultValue() {
                return null
            }
            encode(e, t) {
                return null != t && this._throwError("not null", t), e.writeBytes([])
            }
            decode(e) {
                return e.readBytes(0), e.coerce(this.name, null)
            }
        }
        class If extends yf {
            constructor(e, t, n) {
                const r = (t ? "int" : "uint") + 8 * e;
                super(r, r, n, !1), this.size = e, this.signed = t
            }
            defaultValue() {
                return 0
            }
            encode(e, t) {
                let n = Mu.from(t),
                    r = _c.mask(8 * e.wordSize);
                if (this.signed) {
                    let e = r.mask(8 * this.size - 1);
                    (n.gt(e) || n.lt(e.add(Sc).mul(Cc))) && this._throwError("value out-of-bounds", t)
                } else(n.lt(Pc) || n.gt(r.mask(8 * this.size))) && this._throwError("value out-of-bounds", t);
                return n = n.toTwos(8 * this.size).mask(8 * this.size), this.signed && (n = n.fromTwos(8 * this.size).toTwos(8 * e.wordSize)), e.writeValue(n)
            }
            decode(e) {
                let t = e.readValue().mask(8 * this.size);
                return this.signed && (t = t.fromTwos(8 * this.size)), e.coerce(this.name, t)
            }
        }
        class Of extends Sf {
            constructor(e) {
                super("string", e)
            }
            defaultValue() {
                return ""
            }
            encode(e, t) {
                return super.encode(e, sc(t))
            }
            decode(e) {
                return ac(super.decode(e))
            }
        }
        class Tf extends yf {
            constructor(e, t) {
                let n = !1;
                const r = [];
                e.forEach((e => {
                    e.dynamic && (n = !0), r.push(e.type)
                }));
                super("tuple", "tuple(" + r.join(",") + ")", t, n), this.coders = e
            }
            defaultValue() {
                const e = [];
                this.coders.forEach((t => {
                    e.push(t.defaultValue())
                }));
                const t = this.coders.reduce(((e, t) => {
                    const n = t.localName;
                    return n && (e[n] || (e[n] = 0), e[n]++), e
                }), {});
                return this.coders.forEach(((n, r) => {
                    let i = n.localName;
                    i && 1 === t[i] && ("length" === i && (i = "_length"), null == e[i] && (e[i] = e[r]))
                })), Object.freeze(e)
            }
            encode(e, t) {
                return Af(e, this.coders, t)
            }
            decode(e) {
                return e.coerce(this.name, kf(e, this.coders))
            }
        }
        const Rf = new zl(mf),
            Lf = {};
        let Bf = {
                calldata: !0,
                memory: !0,
                storage: !0
            },
            Ff = {
                calldata: !0,
                memory: !0
            };

        function jf(e, t) {
            if ("bytes" === e || "string" === e) {
                if (Bf[t]) return !0
            } else if ("address" === e) {
                if ("payable" === t) return !0
            } else if ((e.indexOf("[") >= 0 || "tuple" === e) && Ff[t]) return !0;
            return (Bf[t] || "payable" === t) && Rf.throwArgumentError("invalid modifier", "name", t), !1
        }

        function Df(e, t) {
            for (let n in t) Hl(e, n, t[n])
        }
        const Uf = Object.freeze({
                sighash: "sighash",
                minimal: "minimal",
                full: "full",
                json: "json"
            }),
            zf = new RegExp(/^(.*)\[([0-9]*)\]$/);
        class qf {
            constructor(e, t) {
                e !== Lf && Rf.throwError("use fromString", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "new ParamType()"
                }), Df(this, t);
                let n = this.type.match(zf);
                Df(this, n ? {
                    arrayLength: parseInt(n[2] || "-1"),
                    arrayChildren: qf.fromObject({
                        type: n[1],
                        components: this.components
                    }),
                    baseType: "array"
                } : {
                    arrayLength: null,
                    arrayChildren: null,
                    baseType: null != this.components ? "tuple" : this.type
                }), this._isParamType = !0, Object.freeze(this)
            }
            format(e) {
                if (e || (e = Uf.sighash), Uf[e] || Rf.throwArgumentError("invalid format type", "format", e), e === Uf.json) {
                    let t = {
                        type: "tuple" === this.baseType ? "tuple" : this.type,
                        name: this.name || void 0
                    };
                    return "boolean" === typeof this.indexed && (t.indexed = this.indexed), this.components && (t.components = this.components.map((t => JSON.parse(t.format(e))))), JSON.stringify(t)
                }
                let t = "";
                return "array" === this.baseType ? (t += this.arrayChildren.format(e), t += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : "tuple" === this.baseType ? (e !== Uf.sighash && (t += this.type), t += "(" + this.components.map((t => t.format(e))).join(e === Uf.full ? ", " : ",") + ")") : t += this.type, e !== Uf.sighash && (!0 === this.indexed && (t += " indexed"), e === Uf.full && this.name && (t += " " + this.name)), t
            }
            static from(e, t) {
                return "string" === typeof e ? qf.fromString(e, t) : qf.fromObject(e)
            }
            static fromObject(e) {
                return qf.isParamType(e) ? e : new qf(Lf, {
                    name: e.name || null,
                    type: Xf(e.type),
                    indexed: null == e.indexed ? null : !!e.indexed,
                    components: e.components ? e.components.map(qf.fromObject) : null
                })
            }
            static fromString(e, t) {
                return function(e) {
                    return qf.fromObject({
                        name: e.name,
                        type: e.type,
                        indexed: e.indexed,
                        components: e.components
                    })
                }(function(e, t) {
                    let n = e;

                    function r(t) {
                        Rf.throwArgumentError(`unexpected character at position ${t}`, "param", e)
                    }

                    function i(e) {
                        let n = {
                            type: "",
                            name: "",
                            parent: e,
                            state: {
                                allowType: !0
                            }
                        };
                        return t && (n.indexed = !1), n
                    }
                    e = e.replace(/\s/g, " ");
                    let o = {
                            type: "",
                            name: "",
                            state: {
                                allowType: !0
                            }
                        },
                        s = o;
                    for (let a = 0; a < e.length; a++) {
                        let n = e[a];
                        switch (n) {
                            case "(":
                                s.state.allowType && "" === s.type ? s.type = "tuple" : s.state.allowParams || r(a), s.state.allowType = !1, s.type = Xf(s.type), s.components = [i(s)], s = s.components[0];
                                break;
                            case ")":
                                delete s.state, "indexed" === s.name && (t || r(a), s.indexed = !0, s.name = ""), jf(s.type, s.name) && (s.name = ""), s.type = Xf(s.type);
                                let e = s;
                                s = s.parent, s || r(a), delete e.parent, s.state.allowParams = !1, s.state.allowName = !0, s.state.allowArray = !0;
                                break;
                            case ",":
                                delete s.state, "indexed" === s.name && (t || r(a), s.indexed = !0, s.name = ""), jf(s.type, s.name) && (s.name = ""), s.type = Xf(s.type);
                                let o = i(s.parent);
                                s.parent.components.push(o), delete s.parent, s = o;
                                break;
                            case " ":
                                s.state.allowType && "" !== s.type && (s.type = Xf(s.type), delete s.state.allowType, s.state.allowName = !0, s.state.allowParams = !0), s.state.allowName && "" !== s.name && ("indexed" === s.name ? (t || r(a), s.indexed && r(a), s.indexed = !0, s.name = "") : jf(s.type, s.name) ? s.name = "" : s.state.allowName = !1);
                                break;
                            case "[":
                                s.state.allowArray || r(a), s.type += n, s.state.allowArray = !1, s.state.allowName = !1, s.state.readArray = !0;
                                break;
                            case "]":
                                s.state.readArray || r(a), s.type += n, s.state.readArray = !1, s.state.allowArray = !0, s.state.allowName = !0;
                                break;
                            default:
                                s.state.allowType ? (s.type += n, s.state.allowParams = !0, s.state.allowArray = !0) : s.state.allowName ? (s.name += n, delete s.state.allowArray) : s.state.readArray ? s.type += n : r(a)
                        }
                    }
                    return s.parent && Rf.throwArgumentError("unexpected eof", "param", e), delete o.state, "indexed" === s.name ? (t || r(n.length - 7), s.indexed && r(n.length - 7), s.indexed = !0, s.name = "") : jf(s.type, s.name) && (s.name = ""), o.type = Xf(o.type), o
                }(e, !!t))
            }
            static isParamType(e) {
                return !(null == e || !e._isParamType)
            }
        }

        function Gf(e, t) {
            return function(e) {
                e = e.trim();
                let t = [],
                    n = "",
                    r = 0;
                for (let i = 0; i < e.length; i++) {
                    let o = e[i];
                    "," === o && 0 === r ? (t.push(n), n = "") : (n += o, "(" === o ? r++ : ")" === o && (r--, -1 === r && Rf.throwArgumentError("unbalanced parenthesis", "value", e)))
                }
                n && t.push(n);
                return t
            }(e).map((e => qf.fromString(e, t)))
        }
        class Hf {
            constructor(e, t) {
                e !== Lf && Rf.throwError("use a static from method", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "new Fragment()"
                }), Df(this, t), this._isFragment = !0, Object.freeze(this)
            }
            static from(e) {
                return Hf.isFragment(e) ? e : "string" === typeof e ? Hf.fromString(e) : Hf.fromObject(e)
            }
            static fromObject(e) {
                if (Hf.isFragment(e)) return e;
                switch (e.type) {
                    case "function":
                        return Jf.fromObject(e);
                    case "event":
                        return $f.fromObject(e);
                    case "constructor":
                        return Wf.fromObject(e);
                    case "error":
                        return Yf.fromObject(e);
                    case "fallback":
                    case "receive":
                        return null
                }
                return Rf.throwArgumentError("invalid fragment object", "value", e)
            }
            static fromString(e) {
                return "event" === (e = (e = (e = e.replace(/\s/g, " ")).replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")).trim()).split(" ")[0] ? $f.fromString(e.substring(5).trim()) : "function" === e.split(" ")[0] ? Jf.fromString(e.substring(8).trim()) : "constructor" === e.split("(")[0].trim() ? Wf.fromString(e.trim()) : "error" === e.split(" ")[0] ? Yf.fromString(e.substring(5).trim()) : Rf.throwArgumentError("unsupported fragment", "value", e)
            }
            static isFragment(e) {
                return !(!e || !e._isFragment)
            }
        }
        class $f extends Hf {
            format(e) {
                if (e || (e = Uf.sighash), Uf[e] || Rf.throwArgumentError("invalid format type", "format", e), e === Uf.json) return JSON.stringify({
                    type: "event",
                    anonymous: this.anonymous,
                    name: this.name,
                    inputs: this.inputs.map((t => JSON.parse(t.format(e))))
                });
                let t = "";
                return e !== Uf.sighash && (t += "event "), t += this.name + "(" + this.inputs.map((t => t.format(e))).join(e === Uf.full ? ", " : ",") + ") ", e !== Uf.sighash && this.anonymous && (t += "anonymous "), t.trim()
            }
            static from(e) {
                return "string" === typeof e ? $f.fromString(e) : $f.fromObject(e)
            }
            static fromObject(e) {
                if ($f.isEventFragment(e)) return e;
                "event" !== e.type && Rf.throwArgumentError("invalid event object", "value", e);
                const t = {
                    name: tp(e.name),
                    anonymous: e.anonymous,
                    inputs: e.inputs ? e.inputs.map(qf.fromObject) : [],
                    type: "event"
                };
                return new $f(Lf, t)
            }
            static fromString(e) {
                let t = e.match(np);
                t || Rf.throwArgumentError("invalid event string", "value", e);
                let n = !1;
                return t[3].split(" ").forEach((e => {
                    switch (e.trim()) {
                        case "anonymous":
                            n = !0;
                            break;
                        case "":
                            break;
                        default:
                            Rf.warn("unknown modifier: " + e)
                    }
                })), $f.fromObject({
                    name: t[1].trim(),
                    anonymous: n,
                    inputs: Gf(t[2], !0),
                    type: "event"
                })
            }
            static isEventFragment(e) {
                return e && e._isFragment && "event" === e.type
            }
        }

        function Qf(e, t) {
            t.gas = null;
            let n = e.split("@");
            return 1 !== n.length ? (n.length > 2 && Rf.throwArgumentError("invalid human-readable ABI signature", "value", e), n[1].match(/^[0-9]+$/) || Rf.throwArgumentError("invalid human-readable ABI signature gas", "value", e), t.gas = Mu.from(n[1]), n[0]) : e
        }

        function Vf(e, t) {
            t.constant = !1, t.payable = !1, t.stateMutability = "nonpayable", e.split(" ").forEach((e => {
                switch (e.trim()) {
                    case "constant":
                        t.constant = !0;
                        break;
                    case "payable":
                        t.payable = !0, t.stateMutability = "payable";
                        break;
                    case "nonpayable":
                        t.payable = !1, t.stateMutability = "nonpayable";
                        break;
                    case "pure":
                        t.constant = !0, t.stateMutability = "pure";
                        break;
                    case "view":
                        t.constant = !0, t.stateMutability = "view";
                        break;
                    case "external":
                    case "public":
                    case "":
                        break;
                    default:
                        console.log("unknown modifier: " + e)
                }
            }))
        }

        function Kf(e) {
            let t = {
                constant: !1,
                payable: !0,
                stateMutability: "payable"
            };
            return null != e.stateMutability ? (t.stateMutability = e.stateMutability, t.constant = "view" === t.stateMutability || "pure" === t.stateMutability, null != e.constant && !!e.constant !== t.constant && Rf.throwArgumentError("cannot have constant function with mutability " + t.stateMutability, "value", e), t.payable = "payable" === t.stateMutability, null != e.payable && !!e.payable !== t.payable && Rf.throwArgumentError("cannot have payable function with mutability " + t.stateMutability, "value", e)) : null != e.payable ? (t.payable = !!e.payable, null != e.constant || t.payable || "constructor" === e.type || Rf.throwArgumentError("unable to determine stateMutability", "value", e), t.constant = !!e.constant, t.constant ? t.stateMutability = "view" : t.stateMutability = t.payable ? "payable" : "nonpayable", t.payable && t.constant && Rf.throwArgumentError("cannot have constant payable function", "value", e)) : null != e.constant ? (t.constant = !!e.constant, t.payable = !t.constant, t.stateMutability = t.constant ? "view" : "payable") : "constructor" !== e.type && Rf.throwArgumentError("unable to determine stateMutability", "value", e), t
        }
        class Wf extends Hf {
            format(e) {
                if (e || (e = Uf.sighash), Uf[e] || Rf.throwArgumentError("invalid format type", "format", e), e === Uf.json) return JSON.stringify({
                    type: "constructor",
                    stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                    payable: this.payable,
                    gas: this.gas ? this.gas.toNumber() : void 0,
                    inputs: this.inputs.map((t => JSON.parse(t.format(e))))
                });
                e === Uf.sighash && Rf.throwError("cannot format a constructor for sighash", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "format(sighash)"
                });
                let t = "constructor(" + this.inputs.map((t => t.format(e))).join(e === Uf.full ? ", " : ",") + ") ";
                return this.stateMutability && "nonpayable" !== this.stateMutability && (t += this.stateMutability + " "), t.trim()
            }
            static from(e) {
                return "string" === typeof e ? Wf.fromString(e) : Wf.fromObject(e)
            }
            static fromObject(e) {
                if (Wf.isConstructorFragment(e)) return e;
                "constructor" !== e.type && Rf.throwArgumentError("invalid constructor object", "value", e);
                let t = Kf(e);
                t.constant && Rf.throwArgumentError("constructor cannot be constant", "value", e);
                const n = {
                    name: null,
                    type: e.type,
                    inputs: e.inputs ? e.inputs.map(qf.fromObject) : [],
                    payable: t.payable,
                    stateMutability: t.stateMutability,
                    gas: e.gas ? Mu.from(e.gas) : null
                };
                return new Wf(Lf, n)
            }
            static fromString(e) {
                let t = {
                        type: "constructor"
                    },
                    n = (e = Qf(e, t)).match(np);
                return n && "constructor" === n[1].trim() || Rf.throwArgumentError("invalid constructor string", "value", e), t.inputs = Gf(n[2].trim(), !1), Vf(n[3].trim(), t), Wf.fromObject(t)
            }
            static isConstructorFragment(e) {
                return e && e._isFragment && "constructor" === e.type
            }
        }
        class Jf extends Wf {
            format(e) {
                if (e || (e = Uf.sighash), Uf[e] || Rf.throwArgumentError("invalid format type", "format", e), e === Uf.json) return JSON.stringify({
                    type: "function",
                    name: this.name,
                    constant: this.constant,
                    stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
                    payable: this.payable,
                    gas: this.gas ? this.gas.toNumber() : void 0,
                    inputs: this.inputs.map((t => JSON.parse(t.format(e)))),
                    outputs: this.outputs.map((t => JSON.parse(t.format(e))))
                });
                let t = "";
                return e !== Uf.sighash && (t += "function "), t += this.name + "(" + this.inputs.map((t => t.format(e))).join(e === Uf.full ? ", " : ",") + ") ", e !== Uf.sighash && (this.stateMutability ? "nonpayable" !== this.stateMutability && (t += this.stateMutability + " ") : this.constant && (t += "view "), this.outputs && this.outputs.length && (t += "returns (" + this.outputs.map((t => t.format(e))).join(", ") + ") "), null != this.gas && (t += "@" + this.gas.toString() + " ")), t.trim()
            }
            static from(e) {
                return "string" === typeof e ? Jf.fromString(e) : Jf.fromObject(e)
            }
            static fromObject(e) {
                if (Jf.isFunctionFragment(e)) return e;
                "function" !== e.type && Rf.throwArgumentError("invalid function object", "value", e);
                let t = Kf(e);
                const n = {
                    type: e.type,
                    name: tp(e.name),
                    constant: t.constant,
                    inputs: e.inputs ? e.inputs.map(qf.fromObject) : [],
                    outputs: e.outputs ? e.outputs.map(qf.fromObject) : [],
                    payable: t.payable,
                    stateMutability: t.stateMutability,
                    gas: e.gas ? Mu.from(e.gas) : null
                };
                return new Jf(Lf, n)
            }
            static fromString(e) {
                let t = {
                        type: "function"
                    },
                    n = (e = Qf(e, t)).split(" returns ");
                n.length > 2 && Rf.throwArgumentError("invalid function string", "value", e);
                let r = n[0].match(np);
                if (r || Rf.throwArgumentError("invalid function signature", "value", e), t.name = r[1].trim(), t.name && tp(t.name), t.inputs = Gf(r[2], !1), Vf(r[3].trim(), t), n.length > 1) {
                    let r = n[1].match(np);
                    "" == r[1].trim() && "" == r[3].trim() || Rf.throwArgumentError("unexpected tokens", "value", e), t.outputs = Gf(r[2], !1)
                } else t.outputs = [];
                return Jf.fromObject(t)
            }
            static isFunctionFragment(e) {
                return e && e._isFragment && "function" === e.type
            }
        }

        function Zf(e) {
            const t = e.format();
            return "Error(string)" !== t && "Panic(uint256)" !== t || Rf.throwArgumentError(`cannot specify user defined ${t} error`, "fragment", e), e
        }
        class Yf extends Hf {
            format(e) {
                if (e || (e = Uf.sighash), Uf[e] || Rf.throwArgumentError("invalid format type", "format", e), e === Uf.json) return JSON.stringify({
                    type: "error",
                    name: this.name,
                    inputs: this.inputs.map((t => JSON.parse(t.format(e))))
                });
                let t = "";
                return e !== Uf.sighash && (t += "error "), t += this.name + "(" + this.inputs.map((t => t.format(e))).join(e === Uf.full ? ", " : ",") + ") ", t.trim()
            }
            static from(e) {
                return "string" === typeof e ? Yf.fromString(e) : Yf.fromObject(e)
            }
            static fromObject(e) {
                if (Yf.isErrorFragment(e)) return e;
                "error" !== e.type && Rf.throwArgumentError("invalid error object", "value", e);
                const t = {
                    type: e.type,
                    name: tp(e.name),
                    inputs: e.inputs ? e.inputs.map(qf.fromObject) : []
                };
                return Zf(new Yf(Lf, t))
            }
            static fromString(e) {
                let t = {
                        type: "error"
                    },
                    n = e.match(np);
                return n || Rf.throwArgumentError("invalid error signature", "value", e), t.name = n[1].trim(), t.name && tp(t.name), t.inputs = Gf(n[2], !1), Zf(Yf.fromObject(t))
            }
            static isErrorFragment(e) {
                return e && e._isFragment && "error" === e.type
            }
        }

        function Xf(e) {
            return e.match(/^uint($|[^1-9])/) ? e = "uint256" + e.substring(4) : e.match(/^int($|[^1-9])/) && (e = "int256" + e.substring(3)), e
        }
        const ep = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

        function tp(e) {
            return e && e.match(ep) || Rf.throwArgumentError(`invalid identifier "${e}"`, "value", e), e
        }
        const np = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
        const rp = new zl(mf),
            ip = new RegExp(/^bytes([0-9]*)$/),
            op = new RegExp(/^(u?int)([0-9]*)$/);
        const sp = new class {
                constructor(e) {
                    Hl(this, "coerceFunc", e || null)
                }
                _getCoder(e) {
                    switch (e.baseType) {
                        case "address":
                            return new wf(e.name);
                        case "bool":
                            return new Pf(e.name);
                        case "string":
                            return new Of(e.name);
                        case "bytes":
                            return new _f(e.name);
                        case "array":
                            return new Cf(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
                        case "tuple":
                            return new Tf((e.components || []).map((e => this._getCoder(e))), e.name);
                        case "":
                            return new Mf(e.name)
                    }
                    let t = e.type.match(op);
                    if (t) {
                        let n = parseInt(t[2] || "256");
                        return (0 === n || n > 256 || n % 8 !== 0) && rp.throwArgumentError("invalid " + t[1] + " bit length", "param", e), new If(n / 8, "int" === t[1], e.name)
                    }
                    if (t = e.type.match(ip), t) {
                        let n = parseInt(t[1]);
                        return (0 === n || n > 32) && rp.throwArgumentError("invalid bytes length", "param", e), new Nf(n, e.name)
                    }
                    return rp.throwArgumentError("invalid type", "type", e.type)
                }
                _getWordSize() {
                    return 32
                }
                _getReader(e, t) {
                    return new bf(e, this._getWordSize(), this.coerceFunc, t)
                }
                _getWriter() {
                    return new vf(this._getWordSize())
                }
                getDefaultValue(e) {
                    const t = e.map((e => this._getCoder(qf.from(e))));
                    return new Tf(t, "_").defaultValue()
                }
                encode(e, t) {
                    e.length !== t.length && rp.throwError("types/values length mismatch", zl.errors.INVALID_ARGUMENT, {
                        count: {
                            types: e.length,
                            values: t.length
                        },
                        value: {
                            types: e,
                            values: t
                        }
                    });
                    const n = e.map((e => this._getCoder(qf.from(e)))),
                        r = new Tf(n, "_"),
                        i = this._getWriter();
                    return r.encode(i, t), i.data
                }
                decode(e, t, n) {
                    const r = e.map((e => this._getCoder(qf.from(e))));
                    return new Tf(r, "_").decode(this._getReader(fu(t), n))
                }
            },
            ap = new zl(mf);
        class lp extends Yl {}
        class up extends Yl {}
        class cp extends Yl {}
        class dp extends Yl {
            static isIndexed(e) {
                return !(!e || !e._isIndexed)
            }
        }
        const hp = {
            "0x08c379a0": {
                signature: "Error(string)",
                name: "Error",
                inputs: ["string"],
                reason: !0
            },
            "0x4e487b71": {
                signature: "Panic(uint256)",
                name: "Panic",
                inputs: ["uint256"]
            }
        };

        function fp(e, t) {
            const n = new Error(`deferred error during ABI decoding triggered accessing ${e}`);
            return n.error = t, n
        }
        class pp {
            constructor(e) {
                let t = [];
                t = "string" === typeof e ? JSON.parse(e) : e, Hl(this, "fragments", t.map((e => Hf.from(e))).filter((e => null != e))), Hl(this, "_abiCoder", $l(new.target, "getAbiCoder")()), Hl(this, "functions", {}), Hl(this, "errors", {}), Hl(this, "events", {}), Hl(this, "structs", {}), this.fragments.forEach((e => {
                    let t = null;
                    switch (e.type) {
                        case "constructor":
                            return this.deploy ? void ap.warn("duplicate definition - constructor") : void Hl(this, "deploy", e);
                        case "function":
                            t = this.functions;
                            break;
                        case "event":
                            t = this.events;
                            break;
                        case "error":
                            t = this.errors;
                            break;
                        default:
                            return
                    }
                    let n = e.format();
                    t[n] ? ap.warn("duplicate definition - " + n) : t[n] = e
                })), this.deploy || Hl(this, "deploy", Wf.from({
                    payable: !1,
                    type: "constructor"
                })), Hl(this, "_isInterface", !0)
            }
            format(e) {
                e || (e = Uf.full), e === Uf.sighash && ap.throwArgumentError("interface does not support formatting sighash", "format", e);
                const t = this.fragments.map((t => t.format(e)));
                return e === Uf.json ? JSON.stringify(t.map((e => JSON.parse(e)))) : t
            }
            static getAbiCoder() {
                return sp
            }
            static getAddress(e) {
                return Zu(e)
            }
            static getSighash(e) {
                return wu(lc(e.format()), 0, 4)
            }
            static getEventTopic(e) {
                return lc(e.format())
            }
            getFunction(e) {
                if (gu(e)) {
                    for (const t in this.functions)
                        if (e === this.getSighash(t)) return this.functions[t];
                    ap.throwArgumentError("no matching function", "sighash", e)
                }
                if (-1 === e.indexOf("(")) {
                    const t = e.trim(),
                        n = Object.keys(this.functions).filter((e => e.split("(")[0] === t));
                    return 0 === n.length ? ap.throwArgumentError("no matching function", "name", t) : n.length > 1 && ap.throwArgumentError("multiple matching functions", "name", t), this.functions[n[0]]
                }
                const t = this.functions[Jf.fromString(e).format()];
                return t || ap.throwArgumentError("no matching function", "signature", e), t
            }
            getEvent(e) {
                if (gu(e)) {
                    const t = e.toLowerCase();
                    for (const e in this.events)
                        if (t === this.getEventTopic(e)) return this.events[e];
                    ap.throwArgumentError("no matching event", "topichash", t)
                }
                if (-1 === e.indexOf("(")) {
                    const t = e.trim(),
                        n = Object.keys(this.events).filter((e => e.split("(")[0] === t));
                    return 0 === n.length ? ap.throwArgumentError("no matching event", "name", t) : n.length > 1 && ap.throwArgumentError("multiple matching events", "name", t), this.events[n[0]]
                }
                const t = this.events[$f.fromString(e).format()];
                return t || ap.throwArgumentError("no matching event", "signature", e), t
            }
            getError(e) {
                if (gu(e)) {
                    const t = $l(this.constructor, "getSighash");
                    for (const n in this.errors) {
                        if (e === t(this.errors[n])) return this.errors[n]
                    }
                    ap.throwArgumentError("no matching error", "sighash", e)
                }
                if (-1 === e.indexOf("(")) {
                    const t = e.trim(),
                        n = Object.keys(this.errors).filter((e => e.split("(")[0] === t));
                    return 0 === n.length ? ap.throwArgumentError("no matching error", "name", t) : n.length > 1 && ap.throwArgumentError("multiple matching errors", "name", t), this.errors[n[0]]
                }
                const t = this.errors[Jf.fromString(e).format()];
                return t || ap.throwArgumentError("no matching error", "signature", e), t
            }
            getSighash(e) {
                if ("string" === typeof e) try {
                    e = this.getFunction(e)
                } catch (t) {
                    try {
                        e = this.getError(e)
                    } catch (Yp) {
                        throw t
                    }
                }
                return $l(this.constructor, "getSighash")(e)
            }
            getEventTopic(e) {
                return "string" === typeof e && (e = this.getEvent(e)), $l(this.constructor, "getEventTopic")(e)
            }
            _decodeParams(e, t) {
                return this._abiCoder.decode(e, t)
            }
            _encodeParams(e, t) {
                return this._abiCoder.encode(e, t)
            }
            encodeDeploy(e) {
                return this._encodeParams(this.deploy.inputs, e || [])
            }
            decodeErrorResult(e, t) {
                "string" === typeof e && (e = this.getError(e));
                const n = fu(t);
                return vu(n.slice(0, 4)) !== this.getSighash(e) && ap.throwArgumentError(`data signature does not match error ${e.name}.`, "data", vu(n)), this._decodeParams(e.inputs, n.slice(4))
            }
            encodeErrorResult(e, t) {
                return "string" === typeof e && (e = this.getError(e)), vu(pu([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
            }
            decodeFunctionData(e, t) {
                "string" === typeof e && (e = this.getFunction(e));
                const n = fu(t);
                return vu(n.slice(0, 4)) !== this.getSighash(e) && ap.throwArgumentError(`data signature does not match function ${e.name}.`, "data", vu(n)), this._decodeParams(e.inputs, n.slice(4))
            }
            encodeFunctionData(e, t) {
                return "string" === typeof e && (e = this.getFunction(e)), vu(pu([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
            }
            decodeFunctionResult(e, t) {
                "string" === typeof e && (e = this.getFunction(e));
                let n = fu(t),
                    r = null,
                    i = "",
                    o = null,
                    s = null,
                    a = null;
                switch (n.length % this._abiCoder._getWordSize()) {
                    case 0:
                        try {
                            return this._abiCoder.decode(e.outputs, n)
                        } catch (l) {}
                        break;
                    case 4:
                        {
                            const e = vu(n.slice(0, 4)),
                                t = hp[e];
                            if (t) o = this._abiCoder.decode(t.inputs, n.slice(4)),
                            s = t.name,
                            a = t.signature,
                            t.reason && (r = o[0]),
                            "Error" === s ? i = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}` : "Panic" === s && (i = `; VM Exception while processing transaction: reverted with panic code ${o[0]}`);
                            else try {
                                const t = this.getError(e);
                                o = this._abiCoder.decode(t.inputs, n.slice(4)), s = t.name, a = t.format()
                            } catch (l) {}
                            break
                        }
                }
                return ap.throwError("call revert exception" + i, zl.errors.CALL_EXCEPTION, {
                    method: e.format(),
                    data: vu(t),
                    errorArgs: o,
                    errorName: s,
                    errorSignature: a,
                    reason: r
                })
            }
            encodeFunctionResult(e, t) {
                return "string" === typeof e && (e = this.getFunction(e)), vu(this._abiCoder.encode(e.outputs, t || []))
            }
            encodeFilterTopics(e, t) {
                "string" === typeof e && (e = this.getEvent(e)), t.length > e.inputs.length && ap.throwError("too many arguments for " + e.format(), zl.errors.UNEXPECTED_ARGUMENT, {
                    argument: "values",
                    value: t
                });
                let n = [];
                e.anonymous || n.push(this.getEventTopic(e));
                const r = (e, t) => "string" === e.type ? lc(t) : "bytes" === e.type ? Fu(vu(t)) : ("bool" === e.type && "boolean" === typeof t && (t = t ? "0x01" : "0x00"), e.type.match(/^u?int/) && (t = Mu.from(t).toHexString()), "address" === e.type && this._abiCoder.encode(["address"], [t]), Au(vu(t), 32));
                for (t.forEach(((t, i) => {
                        let o = e.inputs[i];
                        o.indexed ? null == t ? n.push(null) : "array" === o.baseType || "tuple" === o.baseType ? ap.throwArgumentError("filtering with tuples or arrays not supported", "contract." + o.name, t) : Array.isArray(t) ? n.push(t.map((e => r(o, e)))) : n.push(r(o, t)) : null != t && ap.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + o.name, t)
                    })); n.length && null === n[n.length - 1];) n.pop();
                return n
            }
            encodeEventLog(e, t) {
                "string" === typeof e && (e = this.getEvent(e));
                const n = [],
                    r = [],
                    i = [];
                return e.anonymous || n.push(this.getEventTopic(e)), t.length !== e.inputs.length && ap.throwArgumentError("event arguments/values mismatch", "values", t), e.inputs.forEach(((e, o) => {
                    const s = t[o];
                    if (e.indexed)
                        if ("string" === e.type) n.push(lc(s));
                        else if ("bytes" === e.type) n.push(Fu(s));
                    else {
                        if ("tuple" === e.baseType || "array" === e.baseType) throw new Error("not implemented");
                        n.push(this._abiCoder.encode([e.type], [s]))
                    } else r.push(e), i.push(s)
                })), {
                    data: this._abiCoder.encode(r, i),
                    topics: n
                }
            }
            decodeEventLog(e, t, n) {
                if ("string" === typeof e && (e = this.getEvent(e)), null != n && !e.anonymous) {
                    let t = this.getEventTopic(e);
                    gu(n[0], 32) && n[0].toLowerCase() === t || ap.throwError("fragment/topic mismatch", zl.errors.INVALID_ARGUMENT, {
                        argument: "topics[0]",
                        expected: t,
                        value: n[0]
                    }), n = n.slice(1)
                }
                let r = [],
                    i = [],
                    o = [];
                e.inputs.forEach(((e, t) => {
                    e.indexed ? "string" === e.type || "bytes" === e.type || "tuple" === e.baseType || "array" === e.baseType ? (r.push(qf.fromObject({
                        type: "bytes32",
                        name: e.name
                    })), o.push(!0)) : (r.push(e), o.push(!1)) : (i.push(e), o.push(!1))
                }));
                let s = null != n ? this._abiCoder.decode(r, pu(n)) : null,
                    a = this._abiCoder.decode(i, t, !0),
                    l = [],
                    u = 0,
                    c = 0;
                e.inputs.forEach(((e, t) => {
                    if (e.indexed)
                        if (null == s) l[t] = new dp({
                            _isIndexed: !0,
                            hash: null
                        });
                        else if (o[t]) l[t] = new dp({
                        _isIndexed: !0,
                        hash: s[c++]
                    });
                    else try {
                        l[t] = s[c++]
                    } catch (n) {
                        l[t] = n
                    } else try {
                        l[t] = a[u++]
                    } catch (n) {
                        l[t] = n
                    }
                    if (e.name && null == l[e.name]) {
                        const n = l[t];
                        n instanceof Error ? Object.defineProperty(l, e.name, {
                            enumerable: !0,
                            get: () => {
                                throw fp(`property ${JSON.stringify(e.name)}`, n)
                            }
                        }) : l[e.name] = n
                    }
                }));
                for (let d = 0; d < l.length; d++) {
                    const e = l[d];
                    e instanceof Error && Object.defineProperty(l, d, {
                        enumerable: !0,
                        get: () => {
                            throw fp(`index ${d}`, e)
                        }
                    })
                }
                return Object.freeze(l)
            }
            parseTransaction(e) {
                let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
                return t ? new up({
                    args: this._abiCoder.decode(t.inputs, "0x" + e.data.substring(10)),
                    functionFragment: t,
                    name: t.name,
                    signature: t.format(),
                    sighash: this.getSighash(t),
                    value: Mu.from(e.value || "0")
                }) : null
            }
            parseLog(e) {
                let t = this.getEvent(e.topics[0]);
                return !t || t.anonymous ? null : new lp({
                    eventFragment: t,
                    name: t.name,
                    signature: t.format(),
                    topic: this.getEventTopic(t),
                    args: this.decodeEventLog(t, e.data, e.topics)
                })
            }
            parseError(e) {
                const t = vu(e);
                let n = this.getError(t.substring(0, 10).toLowerCase());
                return n ? new cp({
                    args: this._abiCoder.decode(n.inputs, "0x" + t.substring(10)),
                    errorFragment: n,
                    name: n.name,
                    signature: n.format(),
                    sighash: this.getSighash(n)
                }) : null
            }
            static isInterface(e) {
                return !(!e || !e._isInterface)
            }
        }
        var mp = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function s(e) {
                    try {
                        l(r.next(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function a(e) {
                    try {
                        l(r.throw(e))
                    } catch (dg) {
                        o(dg)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((r = r.apply(e, t || [])).next())
            }))
        };
        const gp = new zl("contracts/5.7.0");

        function yp(e, t) {
            return mp(this, void 0, void 0, (function*() {
                const n = yield t;
                "string" !== typeof n && gp.throwArgumentError("invalid address or ENS name", "name", n);
                try {
                    return Zu(n)
                } catch (i) {}
                e || gp.throwError("a provider or signer is needed to resolve ENS names", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "resolveName"
                });
                const r = yield e.resolveName(n);
                return null == r && gp.throwArgumentError("resolver or addr is not configured for ENS name", "name", n), r
            }))
        }

        function vp(e, t, n) {
            return mp(this, void 0, void 0, (function*() {
                return Array.isArray(n) ? yield Promise.all(n.map(((n, r) => vp(e, Array.isArray(t) ? t[r] : t[n.name], n)))): "address" === n.type ? yield yp(e, t): "tuple" === n.type ? yield vp(e, t, n.components): "array" === n.baseType ? Array.isArray(t) ? yield Promise.all(t.map((t => vp(e, t, n.arrayChildren)))): Promise.reject(gp.makeError("invalid value for array", zl.errors.INVALID_ARGUMENT, {
                    argument: "value",
                    value: t
                })): t
            }))
        }

        function bp(e, t, n) {
            return mp(this, void 0, void 0, (function*() {
                let r = {};
                n.length === t.inputs.length + 1 && "object" === typeof n[n.length - 1] && (r = Vl(n.pop())), gp.checkArgumentCount(n.length, t.inputs.length, "passed to contract"), e.signer ? r.from ? r.from = Ql({
                    override: yp(e.signer, r.from),
                    signer: e.signer.getAddress()
                }).then((e => mp(this, void 0, void 0, (function*() {
                    return Zu(e.signer) !== e.override && gp.throwError("Contract with a Signer cannot override from", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "overrides.from"
                    }), e.override
                })))) : r.from = e.signer.getAddress() : r.from && (r.from = yp(e.provider, r.from));
                const i = yield Ql({
                    args: vp(e.signer || e.provider, n, t.inputs),
                    address: e.resolvedAddress,
                    overrides: Ql(r) || {}
                }), o = e.interface.encodeFunctionData(t, i.args), s = {
                    data: o,
                    to: i.address
                }, a = i.overrides;
                if (null != a.nonce && (s.nonce = Mu.from(a.nonce).toNumber()), null != a.gasLimit && (s.gasLimit = Mu.from(a.gasLimit)), null != a.gasPrice && (s.gasPrice = Mu.from(a.gasPrice)), null != a.maxFeePerGas && (s.maxFeePerGas = Mu.from(a.maxFeePerGas)), null != a.maxPriorityFeePerGas && (s.maxPriorityFeePerGas = Mu.from(a.maxPriorityFeePerGas)), null != a.from && (s.from = a.from), null != a.type && (s.type = a.type), null != a.accessList && (s.accessList = Cd(a.accessList)), null == s.gasLimit && null != t.gas) {
                    let e = 21e3;
                    const n = fu(o);
                    for (let t = 0; t < n.length; t++) e += 4, n[t] && (e += 64);
                    s.gasLimit = Mu.from(t.gas).add(e)
                }
                if (a.value) {
                    const e = Mu.from(a.value);
                    e.isZero() || t.payable || gp.throwError("non-payable method cannot override value", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "overrides.value",
                        value: r.value
                    }), s.value = e
                }
                a.customData && (s.customData = Vl(a.customData)), a.ccipReadEnabled && (s.ccipReadEnabled = !!a.ccipReadEnabled), delete r.nonce, delete r.gasLimit, delete r.gasPrice, delete r.from, delete r.value, delete r.type, delete r.accessList, delete r.maxFeePerGas, delete r.maxPriorityFeePerGas, delete r.customData, delete r.ccipReadEnabled;
                const l = Object.keys(r).filter((e => null != r[e]));
                return l.length && gp.throwError(`cannot override ${l.map((e=>JSON.stringify(e))).join(",")}`, zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides",
                    overrides: l
                }), s
            }))
        }

        function wp(e, t) {
            const n = t.wait.bind(t);
            t.wait = t => n(t).then((t => (t.events = t.logs.map((n => {
                let r = Zl(n),
                    i = null;
                try {
                    i = e.interface.parseLog(n)
                } catch (dg) {}
                return i && (r.args = i.args, r.decode = (t, n) => e.interface.decodeEventLog(i.eventFragment, t, n), r.event = i.name, r.eventSignature = i.signature), r.removeListener = () => e.provider, r.getBlock = () => e.provider.getBlock(t.blockHash), r.getTransaction = () => e.provider.getTransaction(t.transactionHash), r.getTransactionReceipt = () => Promise.resolve(t), r
            })), t)))
        }

        function Ep(e, t, n) {
            const r = e.signer || e.provider;
            return function() {
                for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                return mp(this, void 0, void 0, (function*() {
                    let i;
                    if (o.length === t.inputs.length + 1 && "object" === typeof o[o.length - 1]) {
                        const e = Vl(o.pop());
                        null != e.blockTag && (i = yield e.blockTag), delete e.blockTag, o.push(e)
                    }
                    null != e.deployTransaction && (yield e._deployed(i));
                    const s = yield bp(e, t, o), a = yield r.call(s, i);
                    try {
                        let r = e.interface.decodeFunctionResult(t, a);
                        return n && 1 === t.outputs.length && (r = r[0]), r
                    } catch (l) {
                        throw l.code === zl.errors.CALL_EXCEPTION && (l.address = e.address, l.args = o, l.transaction = s), l
                    }
                }))
            }
        }

        function xp(e, t, n) {
            return t.constant ? Ep(e, t, n) : function(e, t) {
                return function() {
                    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
                    return mp(this, void 0, void 0, (function*() {
                        e.signer || gp.throwError("sending a transaction requires a signer", zl.errors.UNSUPPORTED_OPERATION, {
                            operation: "sendTransaction"
                        }), null != e.deployTransaction && (yield e._deployed());
                        const n = yield bp(e, t, r), i = yield e.signer.sendTransaction(n);
                        return wp(e, i), i
                    }))
                }
            }(e, t)
        }

        function Ap(e) {
            return !e.address || null != e.topics && 0 !== e.topics.length ? (e.address || "*") + "@" + (e.topics ? e.topics.map((e => Array.isArray(e) ? e.join("|") : e)).join(":") : "") : "*"
        }
        class kp {
            constructor(e, t) {
                Hl(this, "tag", e), Hl(this, "filter", t), this._listeners = []
            }
            addListener(e, t) {
                this._listeners.push({
                    listener: e,
                    once: t
                })
            }
            removeListener(e) {
                let t = !1;
                this._listeners = this._listeners.filter((n => !(!t && n.listener === e) || (t = !0, !1)))
            }
            removeAllListeners() {
                this._listeners = []
            }
            listeners() {
                return this._listeners.map((e => e.listener))
            }
            listenerCount() {
                return this._listeners.length
            }
            run(e) {
                const t = this.listenerCount();
                return this._listeners = this._listeners.filter((t => {
                    const n = e.slice();
                    return setTimeout((() => {
                        t.listener.apply(this, n)
                    }), 0), !t.once
                })), t
            }
            prepareEvent(e) {}
            getEmit(e) {
                return [e]
            }
        }
        class Cp extends kp {
            constructor() {
                super("error", null)
            }
        }
        class Pp extends kp {
            constructor(e, t, n, r) {
                const i = {
                    address: e
                };
                let o = t.getEventTopic(n);
                r ? (o !== r[0] && gp.throwArgumentError("topic mismatch", "topics", r), i.topics = r.slice()) : i.topics = [o], super(Ap(i), i), Hl(this, "address", e), Hl(this, "interface", t), Hl(this, "fragment", n)
            }
            prepareEvent(e) {
                super.prepareEvent(e), e.event = this.fragment.name, e.eventSignature = this.fragment.format(), e.decode = (e, t) => this.interface.decodeEventLog(this.fragment, e, t);
                try {
                    e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics)
                } catch (t) {
                    e.args = null, e.decodeError = t
                }
            }
            getEmit(e) {
                const t = function(e) {
                    const t = [],
                        n = function(e, r) {
                            if (Array.isArray(r))
                                for (let o in r) {
                                    const s = e.slice();
                                    s.push(o);
                                    try {
                                        n(s, r[o])
                                    } catch (i) {
                                        t.push({
                                            path: s,
                                            error: i
                                        })
                                    }
                                }
                        };
                    return n([], e), t
                }(e.args);
                if (t.length) throw t[0].error;
                const n = (e.args || []).slice();
                return n.push(e), n
            }
        }
        class Sp extends kp {
            constructor(e, t) {
                super("*", {
                    address: e
                }), Hl(this, "address", e), Hl(this, "interface", t)
            }
            prepareEvent(e) {
                super.prepareEvent(e);
                try {
                    const t = this.interface.parseLog(e);
                    e.event = t.name, e.eventSignature = t.signature, e.decode = (e, n) => this.interface.decodeEventLog(t.eventFragment, e, n), e.args = t.args
                } catch (t) {}
            }
        }
        class _p {
            constructor(e, t, n) {
                var r = this;
                Hl(this, "interface", $l(new.target, "getInterface")(t)), null == n ? (Hl(this, "provider", null), Hl(this, "signer", null)) : ru.isSigner(n) ? (Hl(this, "provider", n.provider || null), Hl(this, "signer", n)) : $d.isProvider(n) ? (Hl(this, "provider", n), Hl(this, "signer", null)) : gp.throwArgumentError("invalid signer or provider", "signerOrProvider", n), Hl(this, "callStatic", {}), Hl(this, "estimateGas", {}), Hl(this, "functions", {}), Hl(this, "populateTransaction", {}), Hl(this, "filters", {}); {
                    const e = {};
                    Object.keys(this.interface.events).forEach((t => {
                        const n = this.interface.events[t];
                        Hl(this.filters, t, (function() {
                            for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                            return {
                                address: r.address,
                                topics: r.interface.encodeFilterTopics(n, t)
                            }
                        })), e[n.name] || (e[n.name] = []), e[n.name].push(t)
                    })), Object.keys(e).forEach((t => {
                        const n = e[t];
                        1 === n.length ? Hl(this.filters, t, this.filters[n[0]]) : gp.warn(`Duplicate definition of ${t} (${n.join(", ")})`)
                    }))
                }
                if (Hl(this, "_runningEvents", {}), Hl(this, "_wrappedEmits", {}), null == e && gp.throwArgumentError("invalid contract address or ENS name", "addressOrName", e), Hl(this, "address", e), this.provider) Hl(this, "resolvedAddress", yp(this.provider, e));
                else try {
                    Hl(this, "resolvedAddress", Promise.resolve(Zu(e)))
                } catch (s) {
                    gp.throwError("provider is required to use ENS name as contract address", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "new Contract"
                    })
                }
                this.resolvedAddress.catch((e => {}));
                const i = {},
                    o = {};
                Object.keys(this.interface.functions).forEach((e => {
                    const t = this.interface.functions[e];
                    if (o[e]) gp.warn(`Duplicate ABI entry for ${JSON.stringify(e)}`);
                    else {
                        o[e] = !0; {
                            const n = t.name;
                            i[`%${n}`] || (i[`%${n}`] = []), i[`%${n}`].push(e)
                        }
                        null == this[e] && Hl(this, e, xp(this, t, !0)), null == this.functions[e] && Hl(this.functions, e, xp(this, t, !1)), null == this.callStatic[e] && Hl(this.callStatic, e, Ep(this, t, !0)), null == this.populateTransaction[e] && Hl(this.populateTransaction, e, function(e, t) {
                            return function() {
                                for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
                                return bp(e, t, r)
                            }
                        }(this, t)), null == this.estimateGas[e] && Hl(this.estimateGas, e, function(e, t) {
                            const n = e.signer || e.provider;
                            return function() {
                                for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++) i[o] = arguments[o];
                                return mp(this, void 0, void 0, (function*() {
                                    n || gp.throwError("estimate require a provider or signer", zl.errors.UNSUPPORTED_OPERATION, {
                                        operation: "estimateGas"
                                    });
                                    const r = yield bp(e, t, i);
                                    return yield n.estimateGas(r)
                                }))
                            }
                        }(this, t))
                    }
                })), Object.keys(i).forEach((e => {
                    const t = i[e];
                    if (t.length > 1) return;
                    e = e.substring(1);
                    const n = t[0];
                    try {
                        null == this[e] && Hl(this, e, this[n])
                    } catch (dg) {}
                    null == this.functions[e] && Hl(this.functions, e, this.functions[n]), null == this.callStatic[e] && Hl(this.callStatic, e, this.callStatic[n]), null == this.populateTransaction[e] && Hl(this.populateTransaction, e, this.populateTransaction[n]), null == this.estimateGas[e] && Hl(this.estimateGas, e, this.estimateGas[n])
                }))
            }
            static getContractAddress(e) {
                return Yu(e)
            }
            static getInterface(e) {
                return pp.isInterface(e) ? e : new pp(e)
            }
            deployed() {
                return this._deployed()
            }
            _deployed(e) {
                return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then((() => this)) : this._deployedPromise = this.provider.getCode(this.address, e).then((e => ("0x" === e && gp.throwError("contract not deployed", zl.errors.UNSUPPORTED_OPERATION, {
                    contractAddress: this.address,
                    operation: "getDeployed"
                }), this)))), this._deployedPromise
            }
            fallback(e) {
                this.signer || gp.throwError("sending a transactions require a signer", zl.errors.UNSUPPORTED_OPERATION, {
                    operation: "sendTransaction(fallback)"
                });
                const t = Vl(e || {});
                return ["from", "to"].forEach((function(e) {
                    null != t[e] && gp.throwError("cannot override " + e, zl.errors.UNSUPPORTED_OPERATION, {
                        operation: e
                    })
                })), t.to = this.resolvedAddress, this.deployed().then((() => this.signer.sendTransaction(t)))
            }
            connect(e) {
                "string" === typeof e && (e = new iu(e, this.provider));
                const t = new this.constructor(this.address, this.interface, e);
                return this.deployTransaction && Hl(t, "deployTransaction", this.deployTransaction), t
            }
            attach(e) {
                return new this.constructor(e, this.interface, this.signer || this.provider)
            }
            static isIndexed(e) {
                return dp.isIndexed(e)
            }
            _normalizeRunningEvent(e) {
                return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e
            }
            _getRunningEvent(e) {
                if ("string" === typeof e) {
                    if ("error" === e) return this._normalizeRunningEvent(new Cp);
                    if ("event" === e) return this._normalizeRunningEvent(new kp("event", null));
                    if ("*" === e) return this._normalizeRunningEvent(new Sp(this.address, this.interface));
                    const t = this.interface.getEvent(e);
                    return this._normalizeRunningEvent(new Pp(this.address, this.interface, t))
                }
                if (e.topics && e.topics.length > 0) {
                    try {
                        const t = e.topics[0];
                        if ("string" !== typeof t) throw new Error("invalid topic");
                        const n = this.interface.getEvent(t);
                        return this._normalizeRunningEvent(new Pp(this.address, this.interface, n, e.topics))
                    } catch (t) {}
                    const n = {
                        address: this.address,
                        topics: e.topics
                    };
                    return this._normalizeRunningEvent(new kp(Ap(n), n))
                }
                return this._normalizeRunningEvent(new Sp(this.address, this.interface))
            }
            _checkRunningEvents(e) {
                if (0 === e.listenerCount()) {
                    delete this._runningEvents[e.tag];
                    const t = this._wrappedEmits[e.tag];
                    t && e.filter && (this.provider.off(e.filter, t), delete this._wrappedEmits[e.tag])
                }
            }
            _wrapEvent(e, t, n) {
                const r = Zl(t);
                return r.removeListener = () => {
                    n && (e.removeListener(n), this._checkRunningEvents(e))
                }, r.getBlock = () => this.provider.getBlock(t.blockHash), r.getTransaction = () => this.provider.getTransaction(t.transactionHash), r.getTransactionReceipt = () => this.provider.getTransactionReceipt(t.transactionHash), e.prepareEvent(r), r
            }
            _addEventListener(e, t, n) {
                if (this.provider || gp.throwError("events require a provider or a signer with a provider", zl.errors.UNSUPPORTED_OPERATION, {
                        operation: "once"
                    }), e.addListener(t, n), this._runningEvents[e.tag] = e, !this._wrappedEmits[e.tag]) {
                    const n = n => {
                        let r = this._wrapEvent(e, n, t);
                        if (null == r.decodeError) try {
                            const t = e.getEmit(r);
                            this.emit(e.filter, ...t)
                        } catch (i) {
                            r.decodeError = i.error
                        }
                        null != e.filter && this.emit("event", r), null != r.decodeError && this.emit("error", r.decodeError, r)
                    };
                    this._wrappedEmits[e.tag] = n, null != e.filter && this.provider.on(e.filter, n)
                }
            }
            queryFilter(e, t, n) {
                const r = this._getRunningEvent(e),
                    i = Vl(r.filter);
                return "string" === typeof t && gu(t, 32) ? (null != n && gp.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", n), i.blockHash = t) : (i.fromBlock = null != t ? t : 0, i.toBlock = null != n ? n : "latest"), this.provider.getLogs(i).then((e => e.map((e => this._wrapEvent(r, e, null)))))
            }
            on(e, t) {
                return this._addEventListener(this._getRunningEvent(e), t, !1), this
            }
            once(e, t) {
                return this._addEventListener(this._getRunningEvent(e), t, !0), this
            }
            emit(e) {
                if (!this.provider) return !1;
                const t = this._getRunningEvent(e);
                for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                const o = t.run(r) > 0;
                return this._checkRunningEvents(t), o
            }
            listenerCount(e) {
                return this.provider ? null == e ? Object.keys(this._runningEvents).reduce(((e, t) => e + this._runningEvents[t].listenerCount()), 0) : this._getRunningEvent(e).listenerCount() : 0
            }
            listeners(e) {
                if (!this.provider) return [];
                if (null == e) {
                    const e = [];
                    for (let t in this._runningEvents) this._runningEvents[t].listeners().forEach((t => {
                        e.push(t)
                    }));
                    return e
                }
                return this._getRunningEvent(e).listeners()
            }
            removeAllListeners(e) {
                if (!this.provider) return this;
                if (null == e) {
                    for (const e in this._runningEvents) {
                        const t = this._runningEvents[e];
                        t.removeAllListeners(), this._checkRunningEvents(t)
                    }
                    return this
                }
                const t = this._getRunningEvent(e);
                return t.removeAllListeners(), this._checkRunningEvents(t), this
            }
            off(e, t) {
                if (!this.provider) return this;
                const n = this._getRunningEvent(e);
                return n.removeListener(t), this._checkRunningEvents(n), this
            }
            removeListener(e, t) {
                return this.off(e, t)
            }
        }
        class Np extends _p {}
        const Mp = JSON.parse('[{"inputs":[{"internalType":"address","name":"_tokenAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"claimTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"emergenceyWithdrawTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"isClaimActive","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"setBalance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"users","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"setBalanceBulk","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"toggleClaim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"tokenAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_tokenAddress","type":"address"}],"name":"updateTokenAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"userBalance","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"payable","type":"function"}]');
        var Ip = n(306);
        const Op = "0x15421e439e436A93b77d05cE836Bf94605803A16",
            Tp = "https://mainnet.infura.io/v3/9e75004732bc4843881c2c3a628f338a",
            Rp = new class extends tf {
                constructor(e, t) {
                    let n = t;
                    null == n && (n = new Promise(((e, t) => {
                        setTimeout((() => {
                            this.detectNetwork().then((t => {
                                e(t)
                            }), (e => {
                                t(e)
                            }))
                        }), 0)
                    }))), super(n), e || (e = $l(this.constructor, "defaultUrl")()), Hl(this, "connection", "string" === typeof e ? Object.freeze({
                        url: e
                    }) : Object.freeze(Vl(e))), this._nextId = 42
                }
                get _cache() {
                    return null == this._eventLoopCache && (this._eventLoopCache = {}), this._eventLoopCache
                }
                static defaultUrl() {
                    return "http://localhost:8545"
                }
                detectNetwork() {
                    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout((() => {
                        this._cache.detectNetwork = null
                    }), 0)), this._cache.detectNetwork
                }
                _uncachedDetectNetwork() {
                    return nf(this, void 0, void 0, (function*() {
                        yield lf(0);
                        let e = null;
                        try {
                            e = yield this.send("eth_chainId", [])
                        } catch (t) {
                            try {
                                e = yield this.send("net_version", [])
                            } catch (t) {}
                        }
                        if (null != e) {
                            const n = $l(this.constructor, "getNetwork");
                            try {
                                return n(Mu.from(e).toNumber())
                            } catch (t) {
                                return rf.throwError("could not detect network", zl.errors.NETWORK_ERROR, {
                                    chainId: e,
                                    event: "invalidNetwork",
                                    serverError: t
                                })
                            }
                        }
                        return rf.throwError("could not detect network", zl.errors.NETWORK_ERROR, {
                            event: "noNetwork"
                        })
                    }))
                }
                getSigner(e) {
                    return new hf(df, this, e)
                }
                getUncheckedSigner(e) {
                    return this.getSigner(e).connectUnchecked()
                }
                listAccounts() {
                    return this.send("eth_accounts", []).then((e => e.map((e => this.formatter.address(e)))))
                }
                send(e, t) {
                    const n = {
                        method: e,
                        params: t,
                        id: this._nextId++,
                        jsonrpc: "2.0"
                    };
                    this.emit("debug", {
                        action: "request",
                        request: Zl(n),
                        provider: this
                    });
                    const r = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
                    if (r && this._cache[e]) return this._cache[e];
                    const i = Dd(this.connection, JSON.stringify(n), uf).then((e => (this.emit("debug", {
                        action: "response",
                        request: n,
                        response: e,
                        provider: this
                    }), e)), (e => {
                        throw this.emit("debug", {
                            action: "response",
                            error: e,
                            request: n,
                            provider: this
                        }), e
                    }));
                    return r && (this._cache[e] = i, setTimeout((() => {
                        this._cache[e] = null
                    }), 0)), i
                }
                prepareRequest(e, t) {
                    switch (e) {
                        case "getBlockNumber":
                            return ["eth_blockNumber", []];
                        case "getGasPrice":
                            return ["eth_gasPrice", []];
                        case "getBalance":
                            return ["eth_getBalance", [cf(t.address), t.blockTag]];
                        case "getTransactionCount":
                            return ["eth_getTransactionCount", [cf(t.address), t.blockTag]];
                        case "getCode":
                            return ["eth_getCode", [cf(t.address), t.blockTag]];
                        case "getStorageAt":
                            return ["eth_getStorageAt", [cf(t.address), Au(t.position, 32), t.blockTag]];
                        case "sendTransaction":
                            return ["eth_sendRawTransaction", [t.signedTransaction]];
                        case "getBlock":
                            return t.blockTag ? ["eth_getBlockByNumber", [t.blockTag, !!t.includeTransactions]] : t.blockHash ? ["eth_getBlockByHash", [t.blockHash, !!t.includeTransactions]] : null;
                        case "getTransaction":
                            return ["eth_getTransactionByHash", [t.transactionHash]];
                        case "getTransactionReceipt":
                            return ["eth_getTransactionReceipt", [t.transactionHash]];
                        case "call":
                            return ["eth_call", [$l(this.constructor, "hexlifyTransaction")(t.transaction, {
                                from: !0
                            }), t.blockTag]];
                        case "estimateGas":
                            return ["eth_estimateGas", [$l(this.constructor, "hexlifyTransaction")(t.transaction, {
                                from: !0
                            })]];
                        case "getLogs":
                            return t.filter && null != t.filter.address && (t.filter.address = cf(t.filter.address)), ["eth_getLogs", [t.filter]]
                    }
                    return null
                }
                perform(e, t) {
                    return nf(this, void 0, void 0, (function*() {
                        if ("call" === e || "estimateGas" === e) {
                            const e = t.transaction;
                            if (e && null != e.type && Mu.from(e.type).isZero() && null == e.maxFeePerGas && null == e.maxPriorityFeePerGas) {
                                const n = yield this.getFeeData();
                                null == n.maxFeePerGas && null == n.maxPriorityFeePerGas && ((t = Vl(t)).transaction = Vl(e), delete t.transaction.type)
                            }
                        }
                        const n = this.prepareRequest(e, t);
                        null == n && rf.throwError(e + " not implemented", zl.errors.NOT_IMPLEMENTED, {
                            operation: e
                        });
                        try {
                            return yield this.send(n[0], n[1])
                        } catch (r) {
                            return af(e, r, t)
                        }
                    }))
                }
                _startEvent(e) {
                    "pending" === e.tag && this._startPending(), super._startEvent(e)
                }
                _startPending() {
                    if (null != this._pendingFilter) return;
                    const e = this,
                        t = this.send("eth_newPendingTransactionFilter", []);
                    this._pendingFilter = t, t.then((function(n) {
                        return function r() {
                            e.send("eth_getFilterChanges", [n]).then((function(n) {
                                if (e._pendingFilter != t) return null;
                                let r = Promise.resolve();
                                return n.forEach((function(t) {
                                    e._emitted["t:" + t.toLowerCase()] = "pending", r = r.then((function() {
                                        return e.getTransaction(t).then((function(t) {
                                            return e.emit("pending", t), null
                                        }))
                                    }))
                                })), r.then((function() {
                                    return lf(1e3)
                                }))
                            })).then((function() {
                                if (e._pendingFilter == t) return setTimeout((function() {
                                    r()
                                }), 0), null;
                                e.send("eth_uninstallFilter", [n])
                            })).catch((e => {}))
                        }(), n
                    })).catch((e => {}))
                }
                _stopEvent(e) {
                    "pending" === e.tag && 0 === this.listenerCount("pending") && (this._pendingFilter = null), super._stopEvent(e)
                }
                static hexlifyTransaction(e, t) {
                    const n = Vl(pf);
                    if (t)
                        for (const s in t) t[s] && (n[s] = !0);
                    var r, i;
                    i = n, (r = e) && "object" === typeof r || Gl.throwArgumentError("invalid object", "object", r), Object.keys(r).forEach((e => {
                        i[e] || Gl.throwArgumentError("invalid object key - " + e, "transaction:" + e, r)
                    }));
                    const o = {};
                    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((function(t) {
                        if (null == e[t]) return;
                        const n = xu(Mu.from(e[t]));
                        "gasLimit" === t && (t = "gas"), o[t] = n
                    })), ["from", "to", "data"].forEach((function(t) {
                        null != e[t] && (o[t] = vu(e[t]))
                    })), e.accessList && (o.accessList = Cd(e.accessList)), o
                }
            }(Tp);
        async function Lp(e) {
            try {
                const [t] = await e.getAddresses(), n = new Np(Op, Mp, Rp), r = await n.userBalance(t);
                return parseFloat((0, Ip.J)(r.toString(), 18).toString() || "0").toFixed(2)
            } catch (t) {
                console.log(t.message)
            }
        }
        async function Bp(e) {
            try {
                const [t] = await e.getAddresses(), n = new Np(Op, Mp, Rp);
                return await n.isClaimActive()
            } catch (t) {
                console.log(t.message)
            }
        }

        function Fp(e) {
            var t, n, r = "";
            if ("string" == typeof e || "number" == typeof e) r += e;
            else if ("object" == typeof e)
                if (Array.isArray(e)) {
                    var i = e.length;
                    for (t = 0; t < i; t++) e[t] && (n = Fp(e[t])) && (r && (r += " "), r += n)
                } else
                    for (n in e) e[n] && (r && (r += " "), r += n);
            return r
        }
        const jp = function() {
                for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = Fp(e)) && (r && (r += " "), r += t);
                return r
            },
            Dp = e => "number" == typeof e && !isNaN(e),
            Up = e => "string" == typeof e,
            zp = e => "function" == typeof e,
            qp = e => Up(e) || zp(e) ? e : null,
            Gp = e => (0, r.isValidElement)(e) || Up(e) || zp(e) || Dp(e);

        function Hp(e) {
            let {
                enter: t,
                exit: n,
                appendPosition: i = !1,
                collapse: o = !0,
                collapseDuration: s = 300
            } = e;
            return function(e) {
                let {
                    children: a,
                    position: l,
                    preventExitTransition: u,
                    done: c,
                    nodeRef: d,
                    isIn: h,
                    playToast: f
                } = e;
                const p = i ? `${t}--${l}` : t,
                    m = i ? `${n}--${l}` : n,
                    g = (0, r.useRef)(0);
                return (0, r.useLayoutEffect)((() => {
                    const e = d.current,
                        t = p.split(" "),
                        n = r => {
                            r.target === d.current && (f(), e.removeEventListener("animationend", n), e.removeEventListener("animationcancel", n), 0 === g.current && "animationcancel" !== r.type && e.classList.remove(...t))
                        };
                    e.classList.add(...t), e.addEventListener("animationend", n), e.addEventListener("animationcancel", n)
                }), []), (0, r.useEffect)((() => {
                    const e = d.current,
                        t = () => {
                            e.removeEventListener("animationend", t), o ? function(e, t, n) {
                                void 0 === n && (n = 300);
                                const {
                                    scrollHeight: r,
                                    style: i
                                } = e;
                                requestAnimationFrame((() => {
                                    i.minHeight = "initial", i.height = r + "px", i.transition = `all ${n}ms`, requestAnimationFrame((() => {
                                        i.height = "0", i.padding = "0", i.margin = "0", setTimeout(t, n)
                                    }))
                                }))
                            }(e, c, s) : c()
                        };
                    h || (u ? t() : (g.current = 1, e.className += ` ${m}`, e.addEventListener("animationend", t)))
                }), [h]), r.createElement(r.Fragment, null, a)
            }
        }

        function $p(e, t) {
            return null != e ? {
                content: e.content,
                containerId: e.props.containerId,
                id: e.props.toastId,
                theme: e.props.theme,
                type: e.props.type,
                data: e.props.data || {},
                isLoading: e.props.isLoading,
                icon: e.props.icon,
                status: t
            } : {}
        }
        const Qp = new Map;
        let Vp = [];
        const Kp = new Set,
            Wp = e => Kp.forEach((t => t(e))),
            Jp = () => Qp.size > 0;

        function Zp(e, t) {
            var n;
            if (t) return !(null == (n = Qp.get(t)) || !n.isToastActive(e));
            let r = !1;
            return Qp.forEach((t => {
                t.isToastActive(e) && (r = !0)
            })), r
        }

        function Yp(e, t) {
            Gp(e) && (Jp() || Vp.push({
                content: e,
                options: t
            }), Qp.forEach((n => {
                n.buildToast(e, t)
            })))
        }

        function Xp(e, t) {
            Qp.forEach((n => {
                null != t && null != t && t.containerId ? (null == t ? void 0 : t.containerId) === n.id && n.toggle(e, null == t ? void 0 : t.id) : n.toggle(e, null == t ? void 0 : t.id)
            }))
        }

        function em(e) {
            const {
                subscribe: t,
                getSnapshot: n,
                setProps: i
            } = (0, r.useRef)(function(e) {
                const t = e.containerId || 1;
                return {
                    subscribe(n) {
                        const i = function(e, t, n) {
                            let i = 1,
                                o = 0,
                                s = [],
                                a = [],
                                l = [],
                                u = t;
                            const c = new Map,
                                d = new Set,
                                h = () => {
                                    l = Array.from(c.values()), d.forEach((e => e()))
                                },
                                f = e => {
                                    a = null == e ? [] : a.filter((t => t !== e)), h()
                                },
                                p = e => {
                                    const {
                                        toastId: t,
                                        onOpen: i,
                                        updateId: o,
                                        children: s
                                    } = e.props, l = null == o;
                                    e.staleId && c.delete(e.staleId), c.set(t, e), a = [...a, e.props.toastId].filter((t => t !== e.staleId)), h(), n($p(e, l ? "added" : "updated")), l && zp(i) && i((0, r.isValidElement)(s) && s.props)
                                };
                            return {
                                id: e,
                                props: u,
                                observe: e => (d.add(e), () => d.delete(e)),
                                toggle: (e, t) => {
                                    c.forEach((n => {
                                        null != t && t !== n.props.toastId || zp(n.toggle) && n.toggle(e)
                                    }))
                                },
                                removeToast: f,
                                toasts: c,
                                clearQueue: () => {
                                    o -= s.length, s = []
                                },
                                buildToast: (t, a) => {
                                    if ((t => {
                                            let {
                                                containerId: n,
                                                toastId: r,
                                                updateId: i
                                            } = t;
                                            const o = n ? n !== e : 1 !== e,
                                                s = c.has(r) && null == i;
                                            return o || s
                                        })(a)) return;
                                    const {
                                        toastId: l,
                                        updateId: d,
                                        data: m,
                                        staleId: g,
                                        delay: y
                                    } = a, v = () => {
                                        f(l)
                                    }, b = null == d;
                                    b && o++;
                                    const w = { ...u,
                                        style: u.toastStyle,
                                        key: i++,
                                        ...Object.fromEntries(Object.entries(a).filter((e => {
                                            let [t, n] = e;
                                            return null != n
                                        }))),
                                        toastId: l,
                                        updateId: d,
                                        data: m,
                                        closeToast: v,
                                        isIn: !1,
                                        className: qp(a.className || u.toastClassName),
                                        bodyClassName: qp(a.bodyClassName || u.bodyClassName),
                                        progressClassName: qp(a.progressClassName || u.progressClassName),
                                        autoClose: !a.isLoading && (E = a.autoClose, x = u.autoClose, !1 === E || Dp(E) && E > 0 ? E : x),
                                        deleteToast() {
                                            const e = c.get(l),
                                                {
                                                    onClose: t,
                                                    children: i
                                                } = e.props;
                                            zp(t) && t((0, r.isValidElement)(i) && i.props), n($p(e, "removed")), c.delete(l), o--, o < 0 && (o = 0), s.length > 0 ? p(s.shift()) : h()
                                        }
                                    };
                                    var E, x;
                                    w.closeButton = u.closeButton, !1 === a.closeButton || Gp(a.closeButton) ? w.closeButton = a.closeButton : !0 === a.closeButton && (w.closeButton = !Gp(u.closeButton) || u.closeButton);
                                    let A = t;
                                    (0, r.isValidElement)(t) && !Up(t.type) ? A = (0, r.cloneElement)(t, {
                                        closeToast: v,
                                        toastProps: w,
                                        data: m
                                    }) : zp(t) && (A = t({
                                        closeToast: v,
                                        toastProps: w,
                                        data: m
                                    }));
                                    const k = {
                                        content: A,
                                        props: w,
                                        staleId: g
                                    };
                                    u.limit && u.limit > 0 && o > u.limit && b ? s.push(k) : Dp(y) ? setTimeout((() => {
                                        p(k)
                                    }), y) : p(k)
                                },
                                setProps(e) {
                                    u = e
                                },
                                setToggle: (e, t) => {
                                    c.get(e).toggle = t
                                },
                                isToastActive: e => a.some((t => t === e)),
                                getSnapshot: () => u.newestOnTop ? l.reverse() : l
                            }
                        }(t, e, Wp);
                        Qp.set(t, i);
                        const o = i.observe(n);
                        return Vp.forEach((e => Yp(e.content, e.options))), Vp = [], () => {
                            o(), Qp.delete(t)
                        }
                    },
                    setProps(e) {
                        var n;
                        null == (n = Qp.get(t)) || n.setProps(e)
                    },
                    getSnapshot() {
                        var e;
                        return null == (e = Qp.get(t)) ? void 0 : e.getSnapshot()
                    }
                }
            }(e)).current;
            i(e);
            const o = (0, r.useSyncExternalStore)(t, n, n);
            return {
                getToastToRender: function(e) {
                    if (!o) return [];
                    const t = new Map;
                    return o.forEach((e => {
                        const {
                            position: n
                        } = e.props;
                        t.has(n) || t.set(n, []), t.get(n).push(e)
                    })), Array.from(t, (t => e(t[0], t[1])))
                },
                isToastActive: Zp,
                count: null == o ? void 0 : o.length
            }
        }

        function tm(e) {
            const [t, n] = (0, r.useState)(!1), [i, o] = (0, r.useState)(!1), s = (0, r.useRef)(null), a = (0, r.useRef)({
                start: 0,
                delta: 0,
                removalDistance: 0,
                canCloseOnClick: !0,
                canDrag: !1,
                didMove: !1
            }).current, {
                autoClose: l,
                pauseOnHover: u,
                closeToast: c,
                onClick: d,
                closeOnClick: h
            } = e;
            var f, p;

            function m() {
                n(!0)
            }

            function g() {
                n(!1)
            }

            function y(n) {
                const r = s.current;
                a.canDrag && r && (a.didMove = !0, t && g(), a.delta = "x" === e.draggableDirection ? n.clientX - a.start : n.clientY - a.start, a.start !== n.clientX && (a.canCloseOnClick = !1), r.style.transform = `translate3d(${"x"===e.draggableDirection?`${a.delta}px, var(--y)`:`0, calc(${a.delta}px + var(--y))`},0)`, r.style.opacity = "" + (1 - Math.abs(a.delta / a.removalDistance)))
            }

            function v() {
                document.removeEventListener("pointermove", y), document.removeEventListener("pointerup", v);
                const t = s.current;
                if (a.canDrag && a.didMove && t) {
                    if (a.canDrag = !1, Math.abs(a.delta) > a.removalDistance) return o(!0), e.closeToast(), void e.collapseAll();
                    t.style.transition = "transform 0.2s, opacity 0.2s", t.style.removeProperty("transform"), t.style.removeProperty("opacity")
                }
            }
            null == (p = Qp.get((f = {
                id: e.toastId,
                containerId: e.containerId,
                fn: n
            }).containerId || 1)) || p.setToggle(f.id, f.fn), (0, r.useEffect)((() => {
                if (e.pauseOnFocusLoss) return document.hasFocus() || g(), window.addEventListener("focus", m), window.addEventListener("blur", g), () => {
                    window.removeEventListener("focus", m), window.removeEventListener("blur", g)
                }
            }), [e.pauseOnFocusLoss]);
            const b = {
                onPointerDown: function(t) {
                    if (!0 === e.draggable || e.draggable === t.pointerType) {
                        a.didMove = !1, document.addEventListener("pointermove", y), document.addEventListener("pointerup", v);
                        const n = s.current;
                        a.canCloseOnClick = !0, a.canDrag = !0, n.style.transition = "none", "x" === e.draggableDirection ? (a.start = t.clientX, a.removalDistance = n.offsetWidth * (e.draggablePercent / 100)) : (a.start = t.clientY, a.removalDistance = n.offsetHeight * (80 === e.draggablePercent ? 1.5 * e.draggablePercent : e.draggablePercent) / 100)
                    }
                },
                onPointerUp: function(t) {
                    const {
                        top: n,
                        bottom: r,
                        left: i,
                        right: o
                    } = s.current.getBoundingClientRect();
                    "touchend" !== t.nativeEvent.type && e.pauseOnHover && t.clientX >= i && t.clientX <= o && t.clientY >= n && t.clientY <= r ? g() : m()
                }
            };
            return l && u && (b.onMouseEnter = g, e.stacked || (b.onMouseLeave = m)), h && (b.onClick = e => {
                d && d(e), a.canCloseOnClick && c()
            }), {
                playToast: m,
                pauseToast: g,
                isRunning: t,
                preventExitTransition: i,
                toastRef: s,
                eventHandlers: b
            }
        }

        function nm(e) {
            let {
                delay: t,
                isRunning: n,
                closeToast: i,
                type: o = "default",
                hide: s,
                className: a,
                style: l,
                controlledProgress: u,
                progress: c,
                rtl: d,
                isIn: h,
                theme: f
            } = e;
            const p = s || u && 0 === c,
                m = { ...l,
                    animationDuration: `${t}ms`,
                    animationPlayState: n ? "running" : "paused"
                };
            u && (m.transform = `scaleX(${c})`);
            const g = jp("Toastify__progress-bar", u ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${f}`, `Toastify__progress-bar--${o}`, {
                    "Toastify__progress-bar--rtl": d
                }),
                y = zp(a) ? a({
                    rtl: d,
                    type: o,
                    defaultClassName: g
                }) : jp(g, a),
                v = {
                    [u && c >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: u && c < 1 ? null : () => {
                        h && i()
                    }
                };
            return r.createElement("div", {
                className: "Toastify__progress-bar--wrp",
                "data-hidden": p
            }, r.createElement("div", {
                className: `Toastify__progress-bar--bg Toastify__progress-bar-theme--${f} Toastify__progress-bar--${o}`
            }), r.createElement("div", {
                role: "progressbar",
                "aria-hidden": p ? "true" : "false",
                "aria-label": "notification timer",
                className: y,
                style: m,
                ...v
            }))
        }
        let rm = 1;
        const im = () => "" + rm++;

        function om(e) {
            return e && (Up(e.toastId) || Dp(e.toastId)) ? e.toastId : im()
        }

        function sm(e, t) {
            return Yp(e, t), t.toastId
        }

        function am(e, t) {
            return { ...t,
                type: t && t.type || e,
                toastId: om(t)
            }
        }

        function lm(e) {
            return (t, n) => sm(t, am(e, n))
        }

        function um(e, t) {
            return sm(e, am("default", t))
        }
        um.loading = (e, t) => sm(e, am("default", {
            isLoading: !0,
            autoClose: !1,
            closeOnClick: !1,
            closeButton: !1,
            draggable: !1,
            ...t
        })), um.promise = function(e, t, n) {
            let r, {
                pending: i,
                error: o,
                success: s
            } = t;
            i && (r = Up(i) ? um.loading(i, n) : um.loading(i.render, { ...n,
                ...i
            }));
            const a = {
                    isLoading: null,
                    autoClose: null,
                    closeOnClick: null,
                    closeButton: null,
                    draggable: null
                },
                l = (e, t, i) => {
                    if (null == t) return void um.dismiss(r);
                    const o = {
                            type: e,
                            ...a,
                            ...n,
                            data: i
                        },
                        s = Up(t) ? {
                            render: t
                        } : t;
                    return r ? um.update(r, { ...o,
                        ...s
                    }) : um(s.render, { ...o,
                        ...s
                    }), i
                },
                u = zp(e) ? e() : e;
            return u.then((e => l("success", s, e))).catch((e => l("error", o, e))), u
        }, um.success = lm("success"), um.info = lm("info"), um.error = lm("error"), um.warning = lm("warning"), um.warn = um.warning, um.dark = (e, t) => sm(e, am("default", {
            theme: "dark",
            ...t
        })), um.dismiss = function(e) {
            ! function(e) {
                var t;
                if (Jp()) {
                    if (null == e || Up(t = e) || Dp(t)) Qp.forEach((t => {
                        t.removeToast(e)
                    }));
                    else if (e && ("containerId" in e || "id" in e)) {
                        const t = Qp.get(e.containerId);
                        t ? t.removeToast(e.id) : Qp.forEach((t => {
                            t.removeToast(e.id)
                        }))
                    }
                } else Vp = Vp.filter((t => null != e && t.options.toastId !== e))
            }(e)
        }, um.clearWaitingQueue = function(e) {
            void 0 === e && (e = {}), Qp.forEach((t => {
                !t.props.limit || e.containerId && t.id !== e.containerId || t.clearQueue()
            }))
        }, um.isActive = Zp, um.update = function(e, t) {
            void 0 === t && (t = {});
            const n = ((e, t) => {
                var n;
                let {
                    containerId: r
                } = t;
                return null == (n = Qp.get(r || 1)) ? void 0 : n.toasts.get(e)
            })(e, t);
            if (n) {
                const {
                    props: r,
                    content: i
                } = n, o = {
                    delay: 100,
                    ...r,
                    ...t,
                    toastId: t.toastId || e,
                    updateId: im()
                };
                o.toastId !== e && (o.staleId = e);
                const s = o.render || i;
                delete o.render, sm(s, o)
            }
        }, um.done = e => {
            um.update(e, {
                progress: 1
            })
        }, um.onChange = function(e) {
            return Kp.add(e), () => {
                Kp.delete(e)
            }
        }, um.play = e => Xp(!0, e), um.pause = e => Xp(!1, e);
        const cm = "undefined" != typeof window ? r.useLayoutEffect : r.useEffect,
            dm = e => {
                let {
                    theme: t,
                    type: n,
                    isLoading: i,
                    ...o
                } = e;
                return r.createElement("svg", {
                    viewBox: "0 0 24 24",
                    width: "100%",
                    height: "100%",
                    fill: "colored" === t ? "currentColor" : `var(--toastify-icon-color-${n})`,
                    ...o
                })
            },
            hm = {
                info: function(e) {
                    return r.createElement(dm, { ...e
                    }, r.createElement("path", {
                        d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
                    }))
                },
                warning: function(e) {
                    return r.createElement(dm, { ...e
                    }, r.createElement("path", {
                        d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
                    }))
                },
                success: function(e) {
                    return r.createElement(dm, { ...e
                    }, r.createElement("path", {
                        d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
                    }))
                },
                error: function(e) {
                    return r.createElement(dm, { ...e
                    }, r.createElement("path", {
                        d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
                    }))
                },
                spinner: function() {
                    return r.createElement("div", {
                        className: "Toastify__spinner"
                    })
                }
            },
            fm = e => {
                const {
                    isRunning: t,
                    preventExitTransition: n,
                    toastRef: i,
                    eventHandlers: o,
                    playToast: s
                } = tm(e), {
                    closeButton: a,
                    children: l,
                    autoClose: u,
                    onClick: c,
                    type: d,
                    hideProgressBar: h,
                    closeToast: f,
                    transition: p,
                    position: m,
                    className: g,
                    style: y,
                    bodyClassName: v,
                    bodyStyle: b,
                    progressClassName: w,
                    progressStyle: E,
                    updateId: x,
                    role: A,
                    progress: k,
                    rtl: C,
                    toastId: P,
                    deleteToast: S,
                    isIn: _,
                    isLoading: N,
                    closeOnClick: M,
                    theme: I
                } = e, O = jp("Toastify__toast", `Toastify__toast-theme--${I}`, `Toastify__toast--${d}`, {
                    "Toastify__toast--rtl": C
                }, {
                    "Toastify__toast--close-on-click": M
                }), T = zp(g) ? g({
                    rtl: C,
                    position: m,
                    type: d,
                    defaultClassName: O
                }) : jp(O, g), R = function(e) {
                    let {
                        theme: t,
                        type: n,
                        isLoading: i,
                        icon: o
                    } = e, s = null;
                    const a = {
                        theme: t,
                        type: n
                    };
                    return !1 === o || (zp(o) ? s = o({ ...a,
                        isLoading: i
                    }) : (0, r.isValidElement)(o) ? s = (0, r.cloneElement)(o, a) : i ? s = hm.spinner() : (e => e in hm)(n) && (s = hm[n](a))), s
                }(e), L = !!k || !u, B = {
                    closeToast: f,
                    type: d,
                    theme: I
                };
                let F = null;
                return !1 === a || (F = zp(a) ? a(B) : (0, r.isValidElement)(a) ? (0, r.cloneElement)(a, B) : function(e) {
                    let {
                        closeToast: t,
                        theme: n,
                        ariaLabel: i = "close"
                    } = e;
                    return r.createElement("button", {
                        className: `Toastify__close-button Toastify__close-button--${n}`,
                        type: "button",
                        onClick: e => {
                            e.stopPropagation(), t(e)
                        },
                        "aria-label": i
                    }, r.createElement("svg", {
                        "aria-hidden": "true",
                        viewBox: "0 0 14 16"
                    }, r.createElement("path", {
                        fillRule: "evenodd",
                        d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
                    })))
                }(B)), r.createElement(p, {
                    isIn: _,
                    done: S,
                    position: m,
                    preventExitTransition: n,
                    nodeRef: i,
                    playToast: s
                }, r.createElement("div", {
                    id: P,
                    onClick: c,
                    "data-in": _,
                    className: T,
                    ...o,
                    style: y,
                    ref: i
                }, r.createElement("div", { ..._ && {
                        role: A
                    },
                    className: zp(v) ? v({
                        type: d
                    }) : jp("Toastify__toast-body", v),
                    style: b
                }, null != R && r.createElement("div", {
                    className: jp("Toastify__toast-icon", {
                        "Toastify--animate-icon Toastify__zoom-enter": !N
                    })
                }, R), r.createElement("div", null, l)), F, r.createElement(nm, { ...x && !L ? {
                        key: `pb-${x}`
                    } : {},
                    rtl: C,
                    theme: I,
                    delay: u,
                    isRunning: t,
                    isIn: _,
                    closeToast: f,
                    hide: h,
                    type: d,
                    style: E,
                    className: w,
                    controlledProgress: L,
                    progress: k || 0
                })))
            },
            pm = function(e, t) {
                return void 0 === t && (t = !1), {
                    enter: `Toastify--animate Toastify__${e}-enter`,
                    exit: `Toastify--animate Toastify__${e}-exit`,
                    appendPosition: t
                }
            },
            mm = Hp(pm("bounce", !0)),
            gm = (Hp(pm("slide", !0)), Hp(pm("zoom")), Hp(pm("flip")), {
                position: "top-right",
                transition: mm,
                autoClose: 5e3,
                closeButton: !0,
                pauseOnHover: !0,
                pauseOnFocusLoss: !0,
                draggable: "touch",
                draggablePercent: 80,
                draggableDirection: "x",
                role: "alert",
                theme: "light"
            });

        function ym(e) {
            let t = { ...gm,
                ...e
            };
            const n = e.stacked,
                [i, o] = (0, r.useState)(!0),
                s = (0, r.useRef)(null),
                {
                    getToastToRender: a,
                    isToastActive: l,
                    count: u
                } = em(t),
                {
                    className: c,
                    style: d,
                    rtl: h,
                    containerId: f
                } = t;

            function p(e) {
                const t = jp("Toastify__toast-container", `Toastify__toast-container--${e}`, {
                    "Toastify__toast-container--rtl": h
                });
                return zp(c) ? c({
                    position: e,
                    rtl: h,
                    defaultClassName: t
                }) : jp(t, qp(c))
            }

            function m() {
                n && (o(!0), um.play())
            }
            return cm((() => {
                if (n) {
                    var e;
                    const n = s.current.querySelectorAll('[data-in="true"]'),
                        r = 12,
                        o = null == (e = t.position) ? void 0 : e.includes("top");
                    let a = 0,
                        l = 0;
                    Array.from(n).reverse().forEach(((e, t) => {
                        const n = e;
                        n.classList.add("Toastify__toast--stacked"), t > 0 && (n.dataset.collapsed = `${i}`), n.dataset.pos || (n.dataset.pos = o ? "top" : "bot");
                        const s = a * (i ? .2 : 1) + (i ? 0 : r * t);
                        n.style.setProperty("--y", `${o?s:-1*s}px`), n.style.setProperty("--g", `${r}`), n.style.setProperty("--s", "" + (1 - (i ? l : 0))), a += n.offsetHeight, l += .025
                    }))
                }
            }), [i, u, n]), r.createElement("div", {
                ref: s,
                className: "Toastify",
                id: f,
                onMouseEnter: () => {
                    n && (o(!1), um.pause())
                },
                onMouseLeave: m
            }, a(((e, t) => {
                const i = t.length ? { ...d
                } : { ...d,
                    pointerEvents: "none"
                };
                return r.createElement("div", {
                    className: p(e),
                    style: i,
                    key: `container-${e}`
                }, t.map((e => {
                    let {
                        content: t,
                        props: i
                    } = e;
                    return r.createElement(fm, { ...i,
                        stacked: n,
                        collapseAll: m,
                        isIn: l(i.toastId, i.containerId),
                        style: i.style,
                        key: `toast-${i.key}`
                    }, t)
                })))
            })))
        }
        const vm = () => {
            const [e, t] = r.useState(!1), [n, i] = (0, r.useState)(!1), {
                disconnect: o
            } = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {
                    mutation: t
                } = e, n = gt(e), r = yr(n), {
                    mutate: i,
                    mutateAsync: o,
                    ...s
                } = Ye({ ...t,
                    ...r
                });
                return { ...s,
                    connectors: wr({
                        config: n
                    }).map((e => e.connector)),
                    disconnect: i,
                    disconnectAsync: o
                }
            }(), {
                address: s,
                connector: a
            } = kr(), [l, u] = (0, r.useState)(0), [c, d] = (0, r.useState)(!1), [h, f] = (0, r.useState)(!1), {
                data: p
            } = Wo(), m = Il(), g = async () => {
                f(!0);
                const e = await async function(e, t) {
                    try {
                        const [n] = await t.getAddresses(), {
                            request: r
                        } = await e.simulateContract({
                            abi: Mp,
                            address: Op,
                            functionName: "claimTokens",
                            args: [],
                            account: n
                        });
                        return {
                            tx: await t.writeContract(r),
                            success: !0
                        }
                    } catch (n) {
                        return console.log(n.message), {
                            message: n.message,
                            success: !1
                        }
                    }
                }(m, p);
                e.success ? (i(!1), t(!0), console.log(e), u(0)) : /User rejected the request./.test(e.message) || (i(!0), t(!0)), f(!1)
            };
            (0, r.useEffect)((() => {
                (async () => {
                    const e = await Lp(p);
                    u(e)
                })(), (async () => {
                    const e = await Bp(p);
                    d(e)
                })()
            }), [p]);
            return (0, he.jsx)(he.Fragment, {
                children: (0, he.jsxs)("div", {
                    className: "wallet",
                    children: [(0, he.jsx)("img", {
                        src: "/images/logo.svg",
                        alt: "logo"
                    }), (0, he.jsx)("h2", {
                        className: "pt-4",
                        children: "Claim Cosmic Tokens"
                    }), (0, he.jsxs)("div", {
                        className: "text-center d-flex flex-column align-items-center gap-4 justify-content-center pt-5",
                        children: [(0, he.jsx)("div", {
                            className: "card-custom",
                            children: (0, he.jsxs)("div", {
                                className: "d-flex align-items-center gap-2 gap-sm-4 justify-content-between",
                                children: [(0, he.jsxs)("div", {
                                    className: "d-flex align-items-center gap-2 gap-sm-4",
                                    children: [null !== a && void 0 !== a && a.icon ? (0, he.jsx)("img", {
                                        style: {
                                            width: 40,
                                            height: 40
                                        },
                                        src: a.icon
                                    }) : "WalletConnect" === a.name ? (0, he.jsxs)("svg", {
                                        width: "56",
                                        height: "57",
                                        viewBox: "0 0 56 57",
                                        fill: "none",
                                        xmlns: "http://www.w3.org/2000/svg",
                                        children: [(0, he.jsx)("circle", {
                                            cx: "28",
                                            cy: "28.5",
                                            r: "28",
                                            fill: "#3B99FC"
                                        }), (0, he.jsx)("path", {
                                            "fill-rule": "evenodd",
                                            "clip-rule": "evenodd",
                                            d: "M39.0237 21.3922C32.9354 15.3137 23.0644 15.3137 16.9762 21.3922L16.1719 22.1952C15.8675 22.4991 15.8675 22.9919 16.1719 23.2958L18.6785 25.7984C18.8307 25.9503 19.0774 25.9503 19.2296 25.7984L20.3095 24.7202C24.5568 20.4797 31.4431 20.4797 35.6904 24.7202L36.6987 25.727C36.8509 25.8789 37.0977 25.8789 37.2499 25.727L39.7564 23.2244C40.0609 22.9205 40.0609 22.4277 39.7564 22.1238L39.0237 21.3922ZM46.4383 28.795L44.2075 26.5678C43.903 26.2638 43.4095 26.2638 43.1051 26.5678L35.9659 33.6956C35.8898 33.7715 35.7664 33.7715 35.6903 33.6956L28.551 26.5676L28.551 26.5676C28.2466 26.2637 27.753 26.2637 27.4486 26.5676L20.3097 33.6956C20.2336 33.7716 20.1102 33.7716 20.0341 33.6956L12.8948 26.5676C12.5903 26.2637 12.0968 26.2637 11.7924 26.5676L9.56156 28.7949C9.25715 29.0988 9.25715 29.5916 9.56156 29.8955L19.6208 39.9387C19.9252 40.2426 20.4187 40.2426 20.7231 39.9387L27.8622 32.8109C27.9383 32.7349 28.0617 32.7349 28.1378 32.8109L35.277 39.9387C35.5814 40.2426 36.075 40.2426 36.3794 39.9387L46.4383 29.8956C46.7427 29.5917 46.7427 29.099 46.4383 28.795Z",
                                            fill: "white"
                                        })]
                                    }) : (0, he.jsxs)("svg", {
                                        width: "56",
                                        height: "57",
                                        viewBox: "0 0 56 57",
                                        fill: "none",
                                        xmlns: "http://www.w3.org/2000/svg",
                                        children: [(0, he.jsx)("path", {
                                            d: "M49.0087 6.59204L30.7996 20.1728L34.1669 12.1603L49.0087 6.59204Z",
                                            fill: "#E2761B"
                                        }), (0, he.jsx)("path", {
                                            d: "M6.97198 6.59204L25.0347 20.3015L21.8321 12.1603L6.97198 6.59204ZM42.457 38.0722L37.6073 45.5334L47.9837 48.4002L50.9668 38.2376L42.457 38.0722ZM5.05042 38.2376L8.01512 48.4002L18.3916 45.5334L13.5419 38.0722L5.05042 38.2376Z",
                                            fill: "#E4761B"
                                        }), (0, he.jsx)("path", {
                                            d: "M17.8061 25.4655L14.9146 29.8576L25.2178 30.3171L24.8518 19.1988L17.8061 25.4655ZM38.1747 25.4655L31.0374 19.0702L30.7995 30.3171L41.0845 29.8576L38.1747 25.4655ZM18.3917 45.5334L24.5773 42.5012L19.2335 38.3111L18.3917 45.5334ZM31.4034 42.5012L37.6074 45.5334L36.7472 38.3111L31.4034 42.5012Z",
                                            fill: "#E4761B"
                                        }), (0, he.jsx)("path", {
                                            d: "M37.6073 45.5333L31.4034 42.5011L31.8975 46.5625L31.8426 48.2716L37.6073 45.5333ZM18.3916 45.5333L24.1563 48.2716L24.1197 46.5625L24.5772 42.5011L18.3916 45.5333Z",
                                            fill: "#D7C1B3"
                                        }), (0, he.jsx)("path", {
                                            d: "M24.2478 35.6281L19.087 34.1027L22.7289 32.4304L24.2478 35.6281ZM31.7328 35.6281L33.2517 32.4304L36.9119 34.1027L31.7328 35.6281Z",
                                            fill: "#233447"
                                        }), (0, he.jsx)("path", {
                                            d: "M18.3917 45.5334L19.2701 38.0722L13.542 38.2376L18.3917 45.5334ZM36.7289 38.0722L37.6074 45.5334L42.457 38.2376L36.7289 38.0722ZM41.0845 29.8576L30.7995 30.317L31.7511 35.6281L33.2701 32.4304L36.9302 34.1027L41.0845 29.8576ZM19.0871 34.1027L22.7472 32.4304L24.2479 35.6281L25.2178 30.317L14.9145 29.8576L19.0871 34.1027Z",
                                            fill: "#CD6116"
                                        }), (0, he.jsx)("path", {
                                            d: "M14.9146 29.8576L19.2335 38.3111L19.0871 34.1027L14.9146 29.8576ZM36.9302 34.1027L36.7472 38.3111L41.0845 29.8576L36.9302 34.1027ZM25.2178 30.317L24.2479 35.6281L25.4557 41.8947L25.7302 33.6433L25.2178 30.317ZM30.7995 30.317L30.3054 33.6249L30.525 41.8947L31.7511 35.6281L30.7995 30.317Z",
                                            fill: "#E4751F"
                                        }), (0, he.jsx)("path", {
                                            d: "M31.7511 35.6281L30.5249 41.8947L31.4034 42.5012L36.7472 38.3112L36.9302 34.1028L31.7511 35.6281ZM19.087 34.1028L19.2334 38.3112L24.5772 42.5012L25.4557 41.8947L24.2478 35.6281L19.087 34.1028Z",
                                            fill: "#F6851B"
                                        }), (0, he.jsx)("path", {
                                            d: "M31.8426 48.2716L31.8975 46.5625L31.44 46.1582H24.5406L24.1197 46.5625L24.1563 48.2716L18.3916 45.5334L20.4047 47.1873L24.4857 50.0358H31.4949L35.5942 47.1873L37.6073 45.5334L31.8426 48.2716Z",
                                            fill: "#C0AD9E"
                                        }), (0, he.jsx)("path", {
                                            d: "M31.4034 42.5012L30.525 41.8947H25.4557L24.5773 42.5012L24.1198 46.5625L24.5407 46.1582H31.44L31.8975 46.5625L31.4034 42.5012Z",
                                            fill: "#161616"
                                        }), (0, he.jsx)("path", {
                                            d: "M49.7773 21.0549L51.3328 13.557L49.0086 6.59204L31.4034 19.7134L38.1746 25.4655L47.7459 28.2772L49.8688 25.7962L48.9537 25.1347L50.4178 23.7931L49.2831 22.911L50.7472 21.79L49.7773 21.0549ZM4.66614 13.557L6.22169 21.0549L5.23346 21.79L6.69751 22.911L5.58117 23.7931L7.04522 25.1347L6.13019 25.7962L8.23477 28.2772L17.806 25.4655L24.5773 19.7134L6.97202 6.59204L4.66614 13.557Z",
                                            fill: "#763D16"
                                        }), (0, he.jsx)("path", {
                                            d: "M47.7458 28.2772L38.1746 25.4655L41.0844 29.8576L36.7472 38.3111L42.457 38.2376H50.9668L47.7458 28.2772ZM17.806 25.4655L8.23473 28.2772L5.05042 38.2376H13.5419L19.2334 38.3111L14.9145 29.8576L17.806 25.4655ZM30.7994 30.317L31.4034 19.7134L34.1851 12.1603H21.8321L24.5772 19.7134L25.2177 30.317L25.4373 33.6617L25.4556 41.8947H30.5249L30.5615 33.6617L30.7994 30.317Z",
                                            fill: "#F6851B"
                                        })]
                                    }), (0, he.jsxs)("div", {
                                        className: "text-start",
                                        children: [(0, he.jsx)("p", {
                                            className: "text-start",
                                            children: "Wallet Address"
                                        }), (0, he.jsxs)("h1", {
                                            className: "d-flex align-items-center gap-1",
                                            children: [s.slice(0, 6), "...", s.slice(-5), (0, he.jsx)("svg", {
                                                onClick: () => {
                                                    navigator.clipboard.writeText(s).then((() => {
                                                        um.success("Address copied to clipboard!")
                                                    })).catch((e => {
                                                        console.error("Failed to copy address:", e)
                                                    }))
                                                },
                                                style: {
                                                    cursor: "pointer"
                                                },
                                                className: "mx-2 mx-sm-4 ",
                                                width: "21",
                                                height: "20",
                                                viewBox: "0 0 21 20",
                                                fill: "none",
                                                xmlns: "http://www.w3.org/2000/svg",
                                                children: (0, he.jsx)("path", {
                                                    d: "M6 1H13.1C15.3402 1 16.4603 1 17.316 1.43597C18.0686 1.81947 18.6805 2.43139 19.064 3.18404C19.5 4.03969 19.5 5.15979 19.5 7.4V14.5M4.7 19H12.8C13.9201 19 14.4802 19 14.908 18.782C15.2843 18.5903 15.5903 18.2843 15.782 17.908C16 17.4802 16 16.9201 16 15.8V7.7C16 6.57989 16 6.01984 15.782 5.59202C15.5903 5.21569 15.2843 4.90973 14.908 4.71799C14.4802 4.5 13.9201 4.5 12.8 4.5H4.7C3.5799 4.5 3.01984 4.5 2.59202 4.71799C2.21569 4.90973 1.90973 5.21569 1.71799 5.59202C1.5 6.01984 1.5 6.57989 1.5 7.7V15.8C1.5 16.9201 1.5 17.4802 1.71799 17.908C1.90973 18.2843 2.21569 18.5903 2.59202 18.782C3.01984 19 3.5799 19 4.7 19Z",
                                                    stroke: "#6A9EB2",
                                                    "stroke-width": "2",
                                                    "stroke-linecap": "round",
                                                    "stroke-linejoin": "round"
                                                })
                                            })]
                                        })]
                                    })]
                                }), (0, he.jsx)("button", {
                                    className: "outline",
                                    onClick: () => o(),
                                    children: "Disconnect"
                                })]
                            })
                        }), (0, he.jsxs)("div", {
                            className: "card-custom",
                            children: [(0, he.jsx)("p", {
                                children: "Claimable Tokens"
                            }), (0, he.jsxs)("div", {
                                className: "d-flex align-items-center gap-2 justify-content-center",
                                children: [(0, he.jsxs)("svg", {
                                    width: "26",
                                    height: "27",
                                    viewBox: "0 0 26 27",
                                    fill: "none",
                                    xmlns: "http://www.w3.org/2000/svg",
                                    children: [(0, he.jsx)("path", {
                                        d: "M24.8896 13.5003C24.9421 13.0747 24.9691 12.6417 24.9691 12.2029C24.9691 6.02099 19.6105 1.00952 13.0003 1.00952C6.39011 1.00952 1.03149 6.02099 1.03149 12.2029C1.03149 12.6417 1.05849 13.0747 1.11102 13.5003C1.05849 13.9259 1.03149 14.3588 1.03149 14.7976C1.03149 20.9796 6.39011 25.991 13.0003 25.991C19.6105 25.991 24.9691 20.9796 24.9691 14.7976C24.9691 14.3588 24.9421 13.9259 24.8896 13.5003Z",
                                        fill: "#01FFCD"
                                    }), (0, he.jsx)("path", {
                                        "fill-rule": "evenodd",
                                        "clip-rule": "evenodd",
                                        d: "M25.4022 13.5C25.4523 13.0739 25.478 12.641 25.478 12.2027C25.478 5.70787 19.8588 0.5 13 0.5C6.14124 0.5 0.521973 5.70787 0.521973 12.2027C0.521973 12.641 0.547687 13.0739 0.597815 13.5C0.547687 13.9261 0.521973 14.359 0.521973 14.7973C0.521973 21.2921 6.14124 26.5 13 26.5C19.8588 26.5 25.478 21.2921 25.478 14.7973C25.478 14.359 25.4523 13.9261 25.4022 13.5ZM24.9688 12.2027C24.9688 12.6415 24.9418 13.0744 24.8893 13.5C24.9418 13.9256 24.9688 14.3585 24.9688 14.7973C24.9688 20.9793 19.6102 25.9908 13 25.9908C6.38982 25.9908 1.03121 20.9793 1.03121 14.7973C1.03121 14.3585 1.05821 13.9256 1.11073 13.5C1.05821 13.0744 1.03121 12.6415 1.03121 12.2027C1.03121 6.02071 6.38982 1.00924 13 1.00924C19.6102 1.00924 24.9688 6.02071 24.9688 12.2027Z",
                                        fill: "url(#paint0_linear_2794_450)"
                                    }), (0, he.jsx)("path", {
                                        d: "M24.9691 14.7974C24.9691 20.9794 19.6105 25.9909 13.0003 25.9909C6.39011 25.9909 1.03149 20.9794 1.03149 14.7974C1.03149 8.61547 6.39011 3.604 13.0003 3.604C19.6105 3.604 24.9691 8.61547 24.9691 14.7974Z",
                                        fill: "url(#paint1_linear_2794_450)"
                                    }), (0, he.jsx)("path", {
                                        d: "M24.9691 12.203C24.9691 18.3849 19.6105 23.3964 13.0003 23.3964C6.39011 23.3964 1.03149 18.3849 1.03149 12.203C1.03149 6.02099 6.39011 1.00952 13.0003 1.00952C19.6105 1.00952 24.9691 6.02099 24.9691 12.203Z",
                                        fill: "#00FF86"
                                    }), (0, he.jsx)("path", {
                                        "fill-rule": "evenodd",
                                        "clip-rule": "evenodd",
                                        d: "M13.0003 23.1418C19.4862 23.1418 24.7145 18.2285 24.7145 12.203C24.7145 6.17741 19.4862 1.26414 13.0003 1.26414C6.5144 1.26414 1.28611 6.17741 1.28611 12.203C1.28611 18.2285 6.5144 23.1418 13.0003 23.1418ZM13.0003 23.3964C19.6105 23.3964 24.9691 18.3849 24.9691 12.203C24.9691 6.02099 19.6105 1.00952 13.0003 1.00952C6.39011 1.00952 1.03149 6.02099 1.03149 12.203C1.03149 18.3849 6.39011 23.3964 13.0003 23.3964Z",
                                        fill: "url(#paint2_linear_2794_450)"
                                    }), (0, he.jsx)("path", {
                                        "fill-rule": "evenodd",
                                        "clip-rule": "evenodd",
                                        d: "M3.69116 12.2769C3.89966 7.63706 7.98773 3.9353 13.0003 3.9353C18.0128 3.9353 22.1009 7.63707 22.3094 12.2769C22.1009 16.9168 18.0128 20.6186 13.0003 20.6186C7.98773 20.6186 3.89966 16.9168 3.69116 12.2769Z",
                                        fill: "#00D771"
                                    }), (0, he.jsx)("path", {
                                        "fill-rule": "evenodd",
                                        "clip-rule": "evenodd",
                                        d: "M11.251 15.951C9.38347 14.7652 8.7834 12.4038 9.92706 10.5395C11.0635 8.68689 13.5127 7.9923 15.5304 8.89554L16.9634 6.53305C13.5646 4.89182 9.35927 6.03365 7.42812 9.18163C5.48509 12.349 6.56201 16.3774 9.81805 18.3134L11.251 15.951ZM12.6399 15.1119L11.2012 17.4839C13.8918 18.6891 17.1581 17.763 18.6737 15.2925C20.1988 12.8064 19.3982 9.65726 16.9072 8.07648L15.4686 10.4484C16.5735 11.2706 16.8999 12.7526 16.1747 13.9347C15.4544 15.1089 13.9431 15.5853 12.6399 15.1119Z",
                                        fill: "url(#paint3_linear_2794_450)"
                                    }), (0, he.jsx)("path", {
                                        d: "M14.5099 12.2937C14.5099 13.1238 13.8369 13.7968 13.0068 13.7968C12.1767 13.7968 11.5037 13.1238 11.5037 12.2937C11.5037 11.4635 12.1767 10.7906 13.0068 10.7906C13.8369 10.7906 14.5099 11.4635 14.5099 12.2937Z",
                                        fill: "url(#paint4_linear_2794_450)"
                                    }), (0, he.jsx)("path", {
                                        "fill-rule": "evenodd",
                                        "clip-rule": "evenodd",
                                        d: "M22.3095 12.2768C22.315 12.1536 22.3178 12.0298 22.3178 11.9053C22.3178 7.09273 18.1462 3.19141 13.0003 3.19141C7.85443 3.19141 3.68286 7.09273 3.68286 11.9053C3.68286 13.5303 4.15852 15.0515 4.98673 16.3536C4.22211 15.1514 3.758 13.7626 3.69127 12.2776C3.89977 7.63771 7.98784 3.93595 13.0004 3.93595C18.0127 3.93595 22.1006 7.63732 22.3095 12.2768Z",
                                        fill: "#028B68"
                                    }), (0, he.jsxs)("defs", {
                                        children: [(0, he.jsxs)("linearGradient", {
                                            id: "paint0_linear_2794_450",
                                            x1: "13",
                                            y1: "1.00924",
                                            x2: "13",
                                            y2: "23.3961",
                                            gradientUnits: "userSpaceOnUse",
                                            children: [(0, he.jsx)("stop", {
                                                "stop-color": "#9CFFDD"
                                            }), (0, he.jsx)("stop", {
                                                offset: "1",
                                                "stop-color": "#5E9984",
                                                "stop-opacity": "0"
                                            })]
                                        }), (0, he.jsxs)("linearGradient", {
                                            id: "paint1_linear_2794_450",
                                            x1: "13.0003",
                                            y1: "3.604",
                                            x2: "13.0003",
                                            y2: "25.9909",
                                            gradientUnits: "userSpaceOnUse",
                                            children: [(0, he.jsx)("stop", {
                                                "stop-color": "#01B88C"
                                            }), (0, he.jsx)("stop", {
                                                offset: "0.215",
                                                "stop-color": "#025B40"
                                            }), (0, he.jsx)("stop", {
                                                offset: "0.49",
                                                "stop-color": "#018B67"
                                            })]
                                        }), (0, he.jsxs)("linearGradient", {
                                            id: "paint2_linear_2794_450",
                                            x1: "13.0003",
                                            y1: "1.00952",
                                            x2: "13.0003",
                                            y2: "23.3964",
                                            gradientUnits: "userSpaceOnUse",
                                            children: [(0, he.jsx)("stop", {
                                                "stop-color": "#9CFFDD"
                                            }), (0, he.jsx)("stop", {
                                                offset: "1",
                                                "stop-color": "#5E9984",
                                                "stop-opacity": "0"
                                            })]
                                        }), (0, he.jsxs)("linearGradient", {
                                            id: "paint3_linear_2794_450",
                                            x1: "15.3224",
                                            y1: "15.8287",
                                            x2: "7.54978",
                                            y2: "8.29525",
                                            gradientUnits: "userSpaceOnUse",
                                            children: [(0, he.jsx)("stop", {}), (0, he.jsx)("stop", {
                                                offset: "1",
                                                "stop-color": "#424242"
                                            })]
                                        }), (0, he.jsxs)("linearGradient", {
                                            id: "paint4_linear_2794_450",
                                            x1: "15.3224",
                                            y1: "15.8287",
                                            x2: "7.54978",
                                            y2: "8.29525",
                                            gradientUnits: "userSpaceOnUse",
                                            children: [(0, he.jsx)("stop", {}), (0, he.jsx)("stop", {
                                                offset: "1",
                                                "stop-color": "#424242"
                                            })]
                                        })]
                                    })]
                                }), (0, he.jsxs)("label", {
                                    className: "input-balance",
                                    children: [" ", l]
                                })]
                            }), (0, he.jsx)("button", {
                                disabled: !c,
                                className: "w-100 mt-3",
                                onClick: e => {
                                    e.preventDefault(), g()
                                },
                                children: h ? "Claiming, Please wait..." : 0 == l ? "There are no tokens to claim" : "Claim Tokens"
                            })]
                        })]
                    }), (0, he.jsxs)(gr, {
                        show: e,
                        onHide: () => t(!1),
                        size: "lg",
                        "aria-labelledby": "contained-modal-title-vcenter",
                        centered: !0,
                        children: [(0, he.jsx)(gr.Header, {
                            closeButton: !0
                        }), (0, he.jsx)(gr.Body, {
                            children: (0, he.jsx)(he.Fragment, {
                                children: n ? (0, he.jsxs)("div", {
                                    className: "text-center staked p-4",
                                    children: [(0, he.jsxs)("svg", {
                                        width: "95",
                                        height: "95",
                                        viewBox: "0 0 95 95",
                                        fill: "none",
                                        xmlns: "http://www.w3.org/2000/svg",
                                        children: [(0, he.jsxs)("g", {
                                            "clip-path": "url(#clip0_2446_55)",
                                            children: [(0, he.jsx)("path", {
                                                opacity: "0.05",
                                                d: "M47.0129 94.0179C72.9698 94.0179 94.0121 72.9757 94.0121 47.0187C94.0121 21.0618 72.9698 0.0195312 47.0129 0.0195312C21.0559 0.0195312 0.0136719 21.0618 0.0136719 47.0187C0.0136719 72.9757 21.0559 94.0179 47.0129 94.0179Z",
                                                fill: "url(#paint0_linear_2446_55)"
                                            }), (0, he.jsx)("g", {
                                                opacity: "0.3",
                                                filter: "url(#filter0_f_2446_55)",
                                                children: (0, he.jsx)("path", {
                                                    d: "M24.6819 55.3419C12.4669 46.6829 8.44394 31.37 15.6959 21.14C22.9479 10.91 38.7289 9.63695 50.9439 18.297C63.1589 26.956 83.2139 58.658 75.9619 68.888C68.7099 79.117 36.8969 64.0009 24.6819 55.3419Z",
                                                    fill: "#3ED2E6"
                                                })
                                            }), (0, he.jsx)("path", {
                                                opacity: "0.05",
                                                d: "M47.0141 84.9378C67.9562 84.9378 84.9332 67.9608 84.9332 47.0187C84.9332 26.0766 67.9562 9.09961 47.0141 9.09961C26.0719 9.09961 9.09497 26.0766 9.09497 47.0187C9.09497 67.9608 26.0719 84.9378 47.0141 84.9378Z",
                                                fill: "url(#paint1_linear_2446_55)"
                                            }), (0, he.jsx)("path", {
                                                d: "M47.014 75.5876C62.7918 75.5876 75.5822 62.7972 75.5822 47.0194C75.5822 31.2416 62.7918 18.4512 47.014 18.4512C31.2362 18.4512 18.4458 31.2416 18.4458 47.0194C18.4458 62.7972 31.2362 75.5876 47.014 75.5876Z",
                                                fill: "#F35421"
                                            }), (0, he.jsx)("path", {
                                                d: "M39.1909 54.8413L54.8359 39.1973",
                                                stroke: "#07060D",
                                                "stroke-width": "4",
                                                "stroke-linecap": "round",
                                                "stroke-linejoin": "round"
                                            }), (0, he.jsx)("path", {
                                                d: "M54.8359 54.8413L39.1909 39.1973",
                                                stroke: "#07060D",
                                                "stroke-width": "4",
                                                "stroke-linecap": "round",
                                                "stroke-linejoin": "round"
                                            })]
                                        }), (0, he.jsxs)("defs", {
                                            children: [(0, he.jsxs)("filter", {
                                                id: "filter0_f_2446_55",
                                                x: "-139.712",
                                                y: "-139.249",
                                                width: "369.014",
                                                height: "363.362",
                                                filterUnits: "userSpaceOnUse",
                                                "color-interpolation-filters": "sRGB",
                                                children: [(0, he.jsx)("feFlood", {
                                                    "flood-opacity": "0",
                                                    result: "BackgroundImageFix"
                                                }), (0, he.jsx)("feBlend", {
                                                    mode: "normal",
                                                    in: "SourceGraphic",
                                                    in2: "BackgroundImageFix",
                                                    result: "shape"
                                                }), (0, he.jsx)("feGaussianBlur", {
                                                    stdDeviation: "75.9",
                                                    result: "effect1_foregroundBlur_2446_55"
                                                })]
                                            }), (0, he.jsxs)("linearGradient", {
                                                id: "paint0_linear_2446_55",
                                                x1: "72.8659",
                                                y1: "15.5147",
                                                x2: "70.2409",
                                                y2: "91.8937",
                                                gradientUnits: "userSpaceOnUse",
                                                children: [(0, he.jsx)("stop", {
                                                    "stop-color": "#24D6F8"
                                                }), (0, he.jsx)("stop", {
                                                    offset: "1",
                                                    "stop-color": "#50F2A5"
                                                })]
                                            }), (0, he.jsxs)("linearGradient", {
                                                id: "paint1_linear_2446_55",
                                                x1: "67.8711",
                                                y1: "21.6017",
                                                x2: "65.7531",
                                                y2: "83.2247",
                                                gradientUnits: "userSpaceOnUse",
                                                children: [(0, he.jsx)("stop", {
                                                    "stop-color": "#24D6F8"
                                                }), (0, he.jsx)("stop", {
                                                    offset: "1",
                                                    "stop-color": "#50F2A5"
                                                })]
                                            }), (0, he.jsx)("clipPath", {
                                                id: "clip0_2446_55",
                                                children: (0, he.jsx)("rect", {
                                                    width: "94.02",
                                                    height: "94.02",
                                                    rx: "47.01",
                                                    fill: "white"
                                                })
                                            })]
                                        })]
                                    }), (0, he.jsxs)("h1", {
                                        className: "pt-3 pb-3",
                                        children: ["Oops! Something ", (0, he.jsx)("br", {}), " Went Wrong"]
                                    }), (0, he.jsx)("p", {
                                        className: "pb-3",
                                        children: "Unfortunately, we couldn't complete your claiming request. Please check your internet connection and try again. If the problem persists, contact support."
                                    }), (0, he.jsx)("button", {
                                        style: {
                                            width: "200px"
                                        },
                                        onClick: e => {
                                            e.preventDefault(), t(!1), g()
                                        },
                                        children: "Retry"
                                    })]
                                }) : (0, he.jsxs)("div", {
                                    className: "text-center staked p-4",
                                    children: [(0, he.jsxs)("svg", {
                                        width: "95",
                                        height: "95",
                                        viewBox: "0 0 95 95",
                                        fill: "none",
                                        xmlns: "http://www.w3.org/2000/svg",
                                        children: [(0, he.jsxs)("g", {
                                            "clip-path": "url(#clip0_2441_62)",
                                            children: [(0, he.jsx)("path", {
                                                opacity: "0.05",
                                                d: "M47.013 94.0179C72.9699 94.0179 94.0122 72.9757 94.0122 47.0187C94.0122 21.0618 72.9699 0.0195312 47.013 0.0195312C21.0561 0.0195312 0.0137939 21.0618 0.0137939 47.0187C0.0137939 72.9757 21.0561 94.0179 47.013 94.0179Z",
                                                fill: "url(#paint0_linear_2441_62)"
                                            }), (0, he.jsx)("g", {
                                                opacity: "0.3",
                                                filter: "url(#filter0_f_2441_62)",
                                                children: (0, he.jsx)("path", {
                                                    d: "M24.682 55.3419C12.467 46.6829 8.444 31.37 15.696 21.14C22.948 10.91 38.729 9.63695 50.944 18.297C63.159 26.956 83.214 58.658 75.962 68.888C68.71 79.117 36.897 64.0009 24.682 55.3419Z",
                                                    fill: "#3ED2E6"
                                                })
                                            }), (0, he.jsx)("path", {
                                                d: "M47.013 75.5876C62.7908 75.5876 75.5812 62.7972 75.5812 47.0194C75.5812 31.2416 62.7908 18.4512 47.013 18.4512C31.2352 18.4512 18.4448 31.2416 18.4448 47.0194C18.4448 62.7972 31.2352 75.5876 47.013 75.5876Z",
                                                fill: "url(#paint1_linear_2441_62)"
                                            }), (0, he.jsx)("path", {
                                                opacity: "0.05",
                                                d: "M47.014 84.9378C67.9562 84.9378 84.9331 67.9608 84.9331 47.0187C84.9331 26.0766 67.9562 9.09961 47.014 9.09961C26.0719 9.09961 9.09491 26.0766 9.09491 47.0187C9.09491 67.9608 26.0719 84.9378 47.014 84.9378Z",
                                                fill: "url(#paint2_linear_2441_62)"
                                            }), (0, he.jsx)("path", {
                                                d: "M35.346 47.1473L43.04 54.8413L58.685 39.1973",
                                                stroke: "#07060D",
                                                "stroke-width": "4",
                                                "stroke-linecap": "round",
                                                "stroke-linejoin": "round"
                                            })]
                                        }), (0, he.jsxs)("defs", {
                                            children: [(0, he.jsxs)("filter", {
                                                id: "filter0_f_2441_62",
                                                x: "-139.712",
                                                y: "-139.249",
                                                width: "369.014",
                                                height: "363.362",
                                                filterUnits: "userSpaceOnUse",
                                                "color-interpolation-filters": "sRGB",
                                                children: [(0, he.jsx)("feFlood", {
                                                    "flood-opacity": "0",
                                                    result: "BackgroundImageFix"
                                                }), (0, he.jsx)("feBlend", {
                                                    mode: "normal",
                                                    in: "SourceGraphic",
                                                    in2: "BackgroundImageFix",
                                                    result: "shape"
                                                }), (0, he.jsx)("feGaussianBlur", {
                                                    stdDeviation: "75.9",
                                                    result: "effect1_foregroundBlur_2441_62"
                                                })]
                                            }), (0, he.jsxs)("linearGradient", {
                                                id: "paint0_linear_2441_62",
                                                x1: "72.866",
                                                y1: "15.5147",
                                                x2: "70.241",
                                                y2: "91.8937",
                                                gradientUnits: "userSpaceOnUse",
                                                children: [(0, he.jsx)("stop", {
                                                    "stop-color": "#24D6F8"
                                                }), (0, he.jsx)("stop", {
                                                    offset: "1",
                                                    "stop-color": "#50F2A5"
                                                })]
                                            }), (0, he.jsxs)("linearGradient", {
                                                id: "paint1_linear_2441_62",
                                                x1: "62.728",
                                                y1: "27.8694",
                                                x2: "61.132",
                                                y2: "74.2964",
                                                gradientUnits: "userSpaceOnUse",
                                                children: [(0, he.jsx)("stop", {
                                                    "stop-color": "#24D6F8"
                                                }), (0, he.jsx)("stop", {
                                                    offset: "1",
                                                    "stop-color": "#50F2A5"
                                                })]
                                            }), (0, he.jsxs)("linearGradient", {
                                                id: "paint2_linear_2441_62",
                                                x1: "67.871",
                                                y1: "21.6017",
                                                x2: "65.753",
                                                y2: "83.2247",
                                                gradientUnits: "userSpaceOnUse",
                                                children: [(0, he.jsx)("stop", {
                                                    "stop-color": "#24D6F8"
                                                }), (0, he.jsx)("stop", {
                                                    offset: "1",
                                                    "stop-color": "#50F2A5"
                                                })]
                                            }), (0, he.jsx)("clipPath", {
                                                id: "clip0_2441_62",
                                                children: (0, he.jsx)("rect", {
                                                    width: "94.02",
                                                    height: "94.02",
                                                    rx: "47",
                                                    fill: "white"
                                                })
                                            })]
                                        })]
                                    }), (0, he.jsxs)("h1", {
                                        className: "pt-3 pb-3",
                                        children: ["Your tokens ", (0, he.jsx)("br", {}), " claimed ", (0, he.jsx)("br", {}), " Successfully"]
                                    }), (0, he.jsx)("p", {
                                        className: "pb-3",
                                        children: "Great job! Your tokens are now successfully claimed."
                                    }), (0, he.jsx)("button", {
                                        style: {
                                            width: "200px"
                                        },
                                        onClick: () => {
                                            t(!0), i(!0)
                                        },
                                        children: "Awesome! Got it"
                                    })]
                                })
                            })
                        }), (0, he.jsx)(gr.Footer, {})]
                    })]
                })
            })
        };
        class bm extends rt {
            constructor() {
                super("Provider not found."), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "ProviderNotFoundError"
                })
            }
        }
        class wm extends rt {
            constructor(e) {
                let {
                    connector: t
                } = e;
                super(`"${t.name}" does not support programmatic chain switching.`), Object.defineProperty(this, "name", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "SwitchChainNotSupportedError"
                })
            }
        }

        function Em(e) {
            return {
                mutationFn: t => async function(e, t) {
                    const {
                        addEthereumChainParameter: n,
                        chainId: r
                    } = t, i = e.state.connections.get(t.connector ? .uid ? ? e.state.current);
                    if (i) {
                        const e = i.connector;
                        if (!e.switchChain) throw new wm({
                            connector: e
                        });
                        return await e.switchChain({
                            addEthereumChainParameter: n,
                            chainId: r
                        })
                    }
                    const o = e.chains.find((e => e.id === r));
                    if (!o) throw new it;
                    return e.setState((e => ({ ...e,
                        chainId: r
                    }))), o
                }(e, t),
                mutationKey: ["switchChain"]
            }
        }
        let xm = [];

        function Am(e) {
            const t = e.chains;
            return yt(xm, t) ? xm : (xm = t, t)
        }

        function km() {
            const e = gt(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {});
            return (0, r.useSyncExternalStore)((t => function(e, t) {
                const {
                    onChange: n
                } = t;
                return e._internal.chains.subscribe(((e, t) => {
                    n(e, t)
                }))
            }(e, {
                onChange: t
            })), (() => Am(e)), (() => Am(e)))
        }
        const Cm = () => {
            const [e, t] = (0, r.useState)("splash"), {
                isConnected: n,
                chain: i
            } = kr(), o = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const {
                    mutation: t
                } = e, n = gt(e), r = Em(n), {
                    mutate: i,
                    mutateAsync: o,
                    ...s
                } = Ye({ ...t,
                    ...r
                });
                return { ...s,
                    chains: km({
                        config: n
                    }),
                    switchChain: i,
                    switchChainAsync: o
                }
            }(), [s, a] = (0, r.useState)(!1);
            (0, r.useEffect)((() => {
                var e;
                console.log("chain ", i), "1" === (null === i || void 0 === i || null === (e = i.id) || void 0 === e ? void 0 : e.toString()) ? a(!0) : a(!1)
            }), [null === i || void 0 === i ? void 0 : i.id]), (0, r.useEffect)((() => {
                let n;
                return "splash" === e && (n = setTimeout((() => t("checkConnection")), 2e3)), () => clearTimeout(n)
            }), [e]);
            return (0, he.jsxs)(he.Fragment, {
                children: [(0, he.jsx)(ym, {}), "splash" === e && (0, he.jsx)(fe, {}), (0, he.jsx)("div", {
                    className: "main",
                    children: (0, he.jsx)("div", {
                        className: "content-main",
                        children: "checkConnection" === e ? n ? s ? (0, he.jsx)(vm, {}) : (0, he.jsxs)("div", {
                            className: "wallet",
                            children: [(0, he.jsx)("img", {
                                src: "/images/logo.svg",
                                alt: "logo"
                            }), (0, he.jsx)("h2", {
                                className: "pt-4",
                                children: "Switch Network"
                            }), (0, he.jsx)("button", {
                                className: "mt-3",
                                onClick: e => {
                                    e.preventDefault();
                                    try {
                                        o.switchChain({
                                            chainId: 1
                                        })
                                    } catch (e) {}
                                },
                                children: "Switch"
                            })]
                        }) : (0, he.jsx)(Et, {}) : null
                    })
                })]
            })
        };
        var Pm = class extends Fe {
                constructor() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    super(), this.config = e, this.#U = new Map
                }#
                U;
                build(e, t, n) {
                    const r = t.queryKey,
                        i = t.queryHash ? ? Ae(r, t);
                    let o = this.get(i);
                    return o || (o = new No({
                        cache: this,
                        queryKey: r,
                        queryHash: i,
                        options: e.defaultQueryOptions(t),
                        state: n,
                        defaultOptions: e.getQueryDefaults(r)
                    }), this.add(o)), o
                }
                add(e) {
                    this.#U.has(e.queryHash) || (this.#U.set(e.queryHash, e), this.notify({
                        type: "added",
                        query: e
                    }))
                }
                remove(e) {
                    const t = this.#U.get(e.queryHash);
                    t && (e.destroy(), t === e && this.#U.delete(e.queryHash), this.notify({
                        type: "removed",
                        query: e
                    }))
                }
                clear() {
                    pe.batch((() => {
                        this.getAll().forEach((e => {
                            this.remove(e)
                        }))
                    }))
                }
                get(e) {
                    return this.#U.get(e)
                }
                getAll() {
                    return [...this.#U.values()]
                }
                find(e) {
                    const t = {
                        exact: !0,
                        ...e
                    };
                    return this.getAll().find((e => Ee(t, e)))
                }
                findAll() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const t = this.getAll();
                    return Object.keys(e).length > 0 ? t.filter((t => Ee(e, t))) : t
                }
                notify(e) {
                    pe.batch((() => {
                        this.listeners.forEach((t => {
                            t(e)
                        }))
                    }))
                }
                onFocus() {
                    pe.batch((() => {
                        this.getAll().forEach((e => {
                            e.onFocus()
                        }))
                    }))
                }
                onOnline() {
                    pe.batch((() => {
                        this.getAll().forEach((e => {
                            e.onOnline()
                        }))
                    }))
                }
            },
            Sm = class extends Fe {
                constructor() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    super(), this.config = e, this.#z = new Map, this.#q = Date.now()
                }#
                z;#
                q;
                build(e, t, n) {
                    const r = new $e({
                        mutationCache: this,
                        mutationId: ++this.#q,
                        options: e.defaultMutationOptions(t),
                        state: n
                    });
                    return this.add(r), r
                }
                add(e) {
                    const t = _m(e),
                        n = this.#z.get(t) ? ? [];
                    n.push(e), this.#z.set(t, n), this.notify({
                        type: "added",
                        mutation: e
                    })
                }
                remove(e) {
                    const t = _m(e);
                    if (this.#z.has(t)) {
                        const n = this.#z.get(t) ? .filter((t => t !== e));
                        n && (0 === n.length ? this.#z.delete(t) : this.#z.set(t, n))
                    }
                    this.notify({
                        type: "removed",
                        mutation: e
                    })
                }
                canRun(e) {
                    const t = this.#z.get(_m(e)) ? .find((e => "pending" === e.state.status));
                    return !t || t === e
                }
                runNext(e) {
                    const t = this.#z.get(_m(e)) ? .find((t => t !== e && t.state.isPaused));
                    return t ? .continue() ? ? Promise.resolve()
                }
                clear() {
                    pe.batch((() => {
                        this.getAll().forEach((e => {
                            this.remove(e)
                        }))
                    }))
                }
                getAll() {
                    return [...this.#z.values()].flat()
                }
                find(e) {
                    const t = {
                        exact: !0,
                        ...e
                    };
                    return this.getAll().find((e => xe(t, e)))
                }
                findAll() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return this.getAll().filter((t => xe(e, t)))
                }
                notify(e) {
                    pe.batch((() => {
                        this.listeners.forEach((t => {
                            t(e)
                        }))
                    }))
                }
                resumePausedMutations() {
                    const e = this.getAll().filter((e => e.state.isPaused));
                    return pe.batch((() => Promise.all(e.map((e => e.continue().catch(ge))))))
                }
            };

        function _m(e) {
            return e.options.scope ? .id ? ? String(e.mutationId)
        }

        function Nm(e) {
            return {
                onFetch: (t, n) => {
                    const r = async () => {
                        const n = t.options,
                            r = t.fetchOptions ? .meta ? .fetchMore ? .direction,
                            i = t.state.data ? .pages || [],
                            o = t.state.data ? .pageParams || [],
                            s = {
                                pages: [],
                                pageParams: []
                            };
                        let a = !1;
                        const l = Le(t.options, t.fetchOptions),
                            u = async (e, n, r) => {
                                if (a) return Promise.reject();
                                if (null == n && e.pages.length) return Promise.resolve(e);
                                const i = {
                                    queryKey: t.queryKey,
                                    pageParam: n,
                                    direction: r ? "backward" : "forward",
                                    meta: t.options.meta
                                };
                                var o;
                                o = i, Object.defineProperty(o, "signal", {
                                    enumerable: !0,
                                    get: () => (t.signal.aborted ? a = !0 : t.signal.addEventListener("abort", (() => {
                                        a = !0
                                    })), t.signal)
                                });
                                const s = await l(i),
                                    {
                                        maxPages: u
                                    } = t.options,
                                    c = r ? Te : Oe;
                                return {
                                    pages: c(e.pages, s, u),
                                    pageParams: c(e.pageParams, n, u)
                                }
                            };
                        let c;
                        if (r && i.length) {
                            const e = "backward" === r,
                                t = {
                                    pages: i,
                                    pageParams: o
                                },
                                s = (e ? Im : Mm)(n, t);
                            c = await u(t, s, e)
                        } else {
                            c = await u(s, o[0] ? ? n.initialPageParam);
                            const t = e ? ? i.length;
                            for (let e = 1; e < t; e++) {
                                const e = Mm(n, c);
                                if (null == e) break;
                                c = await u(c, e)
                            }
                        }
                        return c
                    };
                    t.options.persister ? t.fetchFn = () => t.options.persister ? .(r, {
                        queryKey: t.queryKey,
                        meta: t.options.meta,
                        signal: t.signal
                    }, n) : t.fetchFn = r
                }
            }
        }

        function Mm(e, t) {
            let {
                pages: n,
                pageParams: r
            } = t;
            const i = n.length - 1;
            return n.length > 0 ? e.getNextPageParam(n[i], n, r[i], r) : void 0
        }

        function Im(e, t) {
            let {
                pages: n,
                pageParams: r
            } = t;
            return n.length > 0 ? e.getPreviousPageParam ? .(n[0], n, r[0], r) : void 0
        }
        var Om = class {#
            G;#
            s;#
            v;#
            H;#
            $;#
            Q;#
            V;#
            K;
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.#G = e.queryCache || new Pm, this.#s = e.mutationCache || new Sm, this.#v = e.defaultOptions || {}, this.#H = new Map, this.#$ = new Map, this.#Q = 0
            }
            mount() {
                this.#Q++, 1 === this.#Q && (this.#V = je.subscribe((async e => {
                    e && (await this.resumePausedMutations(), this.#G.onFocus())
                })), this.#K = De.subscribe((async e => {
                    e && (await this.resumePausedMutations(), this.#G.onOnline())
                })))
            }
            unmount() {
                this.#Q--, 0 === this.#Q && (this.#V ? .(), this.#V = void 0, this.#K ? .(), this.#K = void 0)
            }
            isFetching(e) {
                return this.#G.findAll({ ...e,
                    fetchStatus: "fetching"
                }).length
            }
            isMutating(e) {
                return this.#s.findAll({ ...e,
                    status: "pending"
                }).length
            }
            getQueryData(e) {
                const t = this.defaultQueryOptions({
                    queryKey: e
                });
                return this.#G.get(t.queryHash) ? .state.data
            }
            ensureQueryData(e) {
                const t = this.getQueryData(e.queryKey);
                if (void 0 === t) return this.fetchQuery(e); {
                    const n = this.defaultQueryOptions(e),
                        r = this.#G.build(this, n);
                    return e.revalidateIfStale && r.isStaleByTime(be(n.staleTime, r)) && this.prefetchQuery(n), Promise.resolve(t)
                }
            }
            getQueriesData(e) {
                return this.#G.findAll(e).map((e => {
                    let {
                        queryKey: t,
                        state: n
                    } = e;
                    return [t, n.data]
                }))
            }
            setQueryData(e, t, n) {
                const r = this.defaultQueryOptions({
                        queryKey: e
                    }),
                    i = this.#G.get(r.queryHash),
                    o = i ? .state.data,
                    s = function(e, t) {
                        return "function" === typeof e ? e(t) : e
                    }(t, o);
                if (void 0 !== s) return this.#G.build(this, r).setData(s, { ...n,
                    manual: !0
                })
            }
            setQueriesData(e, t, n) {
                return pe.batch((() => this.#G.findAll(e).map((e => {
                    let {
                        queryKey: r
                    } = e;
                    return [r, this.setQueryData(r, t, n)]
                }))))
            }
            getQueryState(e) {
                const t = this.defaultQueryOptions({
                    queryKey: e
                });
                return this.#G.get(t.queryHash) ? .state
            }
            removeQueries(e) {
                const t = this.#G;
                pe.batch((() => {
                    t.findAll(e).forEach((e => {
                        t.remove(e)
                    }))
                }))
            }
            resetQueries(e, t) {
                const n = this.#G,
                    r = {
                        type: "active",
                        ...e
                    };
                return pe.batch((() => (n.findAll(e).forEach((e => {
                    e.reset()
                })), this.refetchQueries(r, t))))
            }
            cancelQueries() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                const t = {
                        revert: !0,
                        ...arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
                    },
                    n = pe.batch((() => this.#G.findAll(e).map((e => e.cancel(t)))));
                return Promise.all(n).then(ge).catch(ge)
            }
            invalidateQueries() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return pe.batch((() => {
                    if (this.#G.findAll(e).forEach((e => {
                            e.invalidate()
                        })), "none" === e.refetchType) return Promise.resolve();
                    const n = { ...e,
                        type: e.refetchType ? ? e.type ? ? "active"
                    };
                    return this.refetchQueries(n, t)
                }))
            }
            refetchQueries() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = arguments.length > 1 ? arguments[1] : void 0;
                const n = { ...t,
                        cancelRefetch: t ? .cancelRefetch ? ? !0
                    },
                    r = pe.batch((() => this.#G.findAll(e).filter((e => !e.isDisabled())).map((e => {
                        let t = e.fetch(void 0, n);
                        return n.throwOnError || (t = t.catch(ge)), "paused" === e.state.fetchStatus ? Promise.resolve() : t
                    }))));
                return Promise.all(r).then(ge)
            }
            fetchQuery(e) {
                const t = this.defaultQueryOptions(e);
                void 0 === t.retry && (t.retry = !1);
                const n = this.#G.build(this, t);
                return n.isStaleByTime(be(t.staleTime, n)) ? n.fetch(t) : Promise.resolve(n.state.data)
            }
            prefetchQuery(e) {
                return this.fetchQuery(e).then(ge).catch(ge)
            }
            fetchInfiniteQuery(e) {
                return e.behavior = Nm(e.pages), this.fetchQuery(e)
            }
            prefetchInfiniteQuery(e) {
                return this.fetchInfiniteQuery(e).then(ge).catch(ge)
            }
            resumePausedMutations() {
                return De.isOnline() ? this.#s.resumePausedMutations() : Promise.resolve()
            }
            getQueryCache() {
                return this.#G
            }
            getMutationCache() {
                return this.#s
            }
            getDefaultOptions() {
                return this.#v
            }
            setDefaultOptions(e) {
                this.#v = e
            }
            setQueryDefaults(e, t) {
                this.#H.set(ke(e), {
                    queryKey: e,
                    defaultOptions: t
                })
            }
            getQueryDefaults(e) {
                const t = [...this.#H.values()];
                let n = {};
                return t.forEach((t => {
                    Ce(e, t.queryKey) && (n = { ...n,
                        ...t.defaultOptions
                    })
                })), n
            }
            setMutationDefaults(e, t) {
                this.#$.set(ke(e), {
                    mutationKey: e,
                    defaultOptions: t
                })
            }
            getMutationDefaults(e) {
                const t = [...this.#$.values()];
                let n = {};
                return t.forEach((t => {
                    Ce(e, t.mutationKey) && (n = { ...n,
                        ...t.defaultOptions
                    })
                })), n
            }
            defaultQueryOptions(e) {
                if (e._defaulted) return e;
                const t = { ...this.#v.queries,
                    ...this.getQueryDefaults(e.queryKey),
                    ...e,
                    _defaulted: !0
                };
                return t.queryHash || (t.queryHash = Ae(t.queryKey, t)), void 0 === t.refetchOnReconnect && (t.refetchOnReconnect = "always" !== t.networkMode), void 0 === t.throwOnError && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), !0 !== t.enabled && t.queryFn === Re && (t.enabled = !1), t
            }
            defaultMutationOptions(e) {
                return e ? ._defaulted ? e : { ...this.#v.mutations,
                    ...e ? .mutationKey && this.getMutationDefaults(e.mutationKey),
                    ...e,
                    _defaulted : !0
                }
            }
            clear() {
                this.#G.clear(), this.#s.clear()
            }
        };

        function Tm() {
            const e = new Set;
            let t = [];
            const n = () => function(e) {
                const t = t => e(t.detail);
                return window.addEventListener("eip6963:announceProvider", t), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", t)
            }((n => {
                t.some((e => {
                    let {
                        info: t
                    } = e;
                    return t.uuid === n.info.uuid
                })) || (t = [...t, n], e.forEach((e => e(t, {
                    added: [n]
                }))))
            }));
            let r = n();
            return {
                _listeners: () => e,
                clear() {
                    e.forEach((e => e([], {
                        removed: [...t]
                    }))), t = []
                },
                destroy() {
                    this.clear(), e.clear(), r()
                },
                findProvider(e) {
                    let {
                        rdns: n
                    } = e;
                    return t.find((e => e.info.rdns === n))
                },
                getProviders: () => t,
                reset() {
                    this.clear(), r(), r = n()
                },
                subscribe(n) {
                    let {
                        emitImmediately: r
                    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return e.add(n), r && n(t, {
                        added: t
                    }), () => e.delete(n)
                }
            }
        }
        const Rm = e => (t, n, r) => {
            const i = r.subscribe;
            r.subscribe = (e, t, n) => {
                let o = e;
                if (t) {
                    const i = (null == n ? void 0 : n.equalityFn) || Object.is;
                    let s = e(r.getState());
                    o = n => {
                        const r = e(n);
                        if (!i(s, r)) {
                            const e = s;
                            t(s = r, e)
                        }
                    }, (null == n ? void 0 : n.fireImmediately) && t(s, s)
                }
                return i(o)
            };
            return e(t, n, r)
        };

        function Lm(e, t) {
            let n;
            try {
                n = e()
            } catch (dg) {
                return
            }
            const r = {
                getItem: e => {
                    var r;
                    const i = e => null === e ? null : JSON.parse(e, null == t ? void 0 : t.reviver),
                        o = null != (r = n.getItem(e)) ? r : null;
                    return o instanceof Promise ? o.then(i) : i(o)
                },
                setItem: (e, r) => n.setItem(e, JSON.stringify(r, null == t ? void 0 : t.replacer)),
                removeItem: e => n.removeItem(e)
            };
            return r
        }
        const Bm = e => t => {
                try {
                    const n = e(t);
                    return n instanceof Promise ? n : {
                        then: e => Bm(e)(n),
                        catch (e) {
                            return this
                        }
                    }
                } catch (dg) {
                    return {
                        then(e) {
                            return this
                        },
                        catch: t => Bm(t)(dg)
                    }
                }
            },
            Fm = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? (console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."), ((e, t) => (n, r, i) => {
                let o = {
                        getStorage: () => localStorage,
                        serialize: JSON.stringify,
                        deserialize: JSON.parse,
                        partialize: e => e,
                        version: 0,
                        merge: (e, t) => ({ ...t,
                            ...e
                        }),
                        ...t
                    },
                    s = !1;
                const a = new Set,
                    l = new Set;
                let u;
                try {
                    u = o.getStorage()
                } catch (dg) {}
                if (!u) return e((function() {
                    console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`), n(...arguments)
                }), r, i);
                const c = Bm(o.serialize),
                    d = () => {
                        const e = o.partialize({ ...r()
                        });
                        let t;
                        const n = c({
                            state: e,
                            version: o.version
                        }).then((e => u.setItem(o.name, e))).catch((e => {
                            t = e
                        }));
                        if (t) throw t;
                        return n
                    },
                    h = i.setState;
                i.setState = (e, t) => {
                    h(e, t), d()
                };
                const f = e((function() {
                    n(...arguments), d()
                }), r, i);
                let p;
                const m = () => {
                    var e;
                    if (!u) return;
                    s = !1, a.forEach((e => e(r())));
                    const t = (null == (e = o.onRehydrateStorage) ? void 0 : e.call(o, r())) || void 0;
                    return Bm(u.getItem.bind(u))(o.name).then((e => {
                        if (e) return o.deserialize(e)
                    })).then((e => {
                        if (e) {
                            if ("number" !== typeof e.version || e.version === o.version) return e.state;
                            if (o.migrate) return o.migrate(e.state, e.version);
                            console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                        }
                    })).then((e => {
                        var t;
                        return p = o.merge(e, null != (t = r()) ? t : f), n(p, !0), d()
                    })).then((() => {
                        null == t || t(p, void 0), s = !0, l.forEach((e => e(p)))
                    })).catch((e => {
                        null == t || t(void 0, e)
                    }))
                };
                return i.persist = {
                    setOptions: e => {
                        o = { ...o,
                            ...e
                        }, e.getStorage && (u = e.getStorage())
                    },
                    clearStorage: () => {
                        null == u || u.removeItem(o.name)
                    },
                    getOptions: () => o,
                    rehydrate: () => m(),
                    hasHydrated: () => s,
                    onHydrate: e => (a.add(e), () => {
                        a.delete(e)
                    }),
                    onFinishHydration: e => (l.add(e), () => {
                        l.delete(e)
                    })
                }, m(), p || f
            })(e, t)) : ((e, t) => (n, r, i) => {
                let o = {
                        storage: Lm((() => localStorage)),
                        partialize: e => e,
                        version: 0,
                        merge: (e, t) => ({ ...t,
                            ...e
                        }),
                        ...t
                    },
                    s = !1;
                const a = new Set,
                    l = new Set;
                let u = o.storage;
                if (!u) return e((function() {
                    console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`), n(...arguments)
                }), r, i);
                const c = () => {
                        const e = o.partialize({ ...r()
                        });
                        return u.setItem(o.name, {
                            state: e,
                            version: o.version
                        })
                    },
                    d = i.setState;
                i.setState = (e, t) => {
                    d(e, t), c()
                };
                const h = e((function() {
                    n(...arguments), c()
                }), r, i);
                let f;
                const p = () => {
                    var e, t;
                    if (!u) return;
                    s = !1, a.forEach((e => {
                        var t;
                        return e(null != (t = r()) ? t : h)
                    }));
                    const i = (null == (t = o.onRehydrateStorage) ? void 0 : t.call(o, null != (e = r()) ? e : h)) || void 0;
                    return Bm(u.getItem.bind(u))(o.name).then((e => {
                        if (e) {
                            if ("number" !== typeof e.version || e.version === o.version) return e.state;
                            if (o.migrate) return o.migrate(e.state, e.version);
                            console.error("State loaded from storage couldn't be migrated since no migrate function was provided")
                        }
                    })).then((e => {
                        var t;
                        return f = o.merge(e, null != (t = r()) ? t : h), n(f, !0), c()
                    })).then((() => {
                        null == i || i(f, void 0), f = r(), s = !0, l.forEach((e => e(f)))
                    })).catch((e => {
                        null == i || i(void 0, e)
                    }))
                };
                return i.persist = {
                    setOptions: e => {
                        o = { ...o,
                            ...e
                        }, e.storage && (u = e.storage)
                    },
                    clearStorage: () => {
                        null == u || u.removeItem(o.name)
                    },
                    getOptions: () => o,
                    rehydrate: () => p(),
                    hasHydrated: () => s,
                    onHydrate: e => (a.add(e), () => {
                        a.delete(e)
                    }),
                    onFinishHydration: e => (l.add(e), () => {
                        l.delete(e)
                    })
                }, o.skipHydration || p(), f || h
            })(e, t),
            jm = e => {
                let t;
                const n = new Set,
                    r = (e, r) => {
                        const i = "function" === typeof e ? e(t) : e;
                        if (!Object.is(i, t)) {
                            const e = t;
                            t = (null != r ? r : "object" !== typeof i) ? i : Object.assign({}, t, i), n.forEach((n => n(t, e)))
                        }
                    },
                    i = () => t,
                    o = {
                        setState: r,
                        getState: i,
                        subscribe: e => (n.add(e), () => n.delete(e)),
                        destroy: () => {
                            console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear()
                        }
                    };
                return t = e(r, i, o), o
            },
            Dm = e => e ? jm(e) : jm;

        function Um(e, t) {
            let {
                errorInstance: n = new Error("timed out"),
                timeout: r,
                signal: i
            } = t;
            return new Promise(((t, o) => {
                (async () => {
                    let s;
                    try {
                        const a = new AbortController;
                        r > 0 && (s = setTimeout((() => {
                            i ? a.abort() : o(n)
                        }), r)), t(await e({
                            signal: a ? .signal || null
                        }))
                    } catch (a) {
                        "AbortError" === a.name && o(n), o(a)
                    } finally {
                        clearTimeout(s)
                    }
                })()
            }))
        }
        const zm = /(rabby|trustwallet)/,
            qm = {
                coinbaseWallet: {
                    id: "coinbaseWallet",
                    name: "Coinbase Wallet",
                    provider: e => e ? .coinbaseWalletExtension ? e.coinbaseWalletExtension : Hm(e, "isCoinbaseWallet")
                },
                metaMask: {
                    id: "metaMask",
                    name: "MetaMask",
                    provider: e => Hm(e, (e => {
                        if (!e.isMetaMask) return !1;
                        if (e.isBraveWallet && !e._events && !e._state) return !1;
                        const t = ["isApexWallet", "isAvalanche", "isBitKeep", "isBlockWallet", "isKuCoinWallet", "isMathWallet", "isOkxWallet", "isOKExWallet", "isOneInchIOSWallet", "isOneInchAndroidWallet", "isOpera", "isPortal", "isRabby", "isTokenPocket", "isTokenary", "isZerion"];
                        for (const n of t)
                            if (e[n]) return !1;
                        return !0
                    }))
                },
                phantom: {
                    id: "phantom",
                    name: "Phantom",
                    provider: e => e ? .phantom ? .ethereum ? e.phantom ? .ethereum : Hm(e, "isPhantom")
                }
            };

        function Gm() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const {
                shimDisconnect: t = !0,
                unstable_shimAsyncInject: n
            } = e;

            function r() {
                const t = e.target;
                if ("function" === typeof t) {
                    const e = t();
                    if (e) return e
                }
                return "object" === typeof t ? t : "string" === typeof t ? { ...qm[t] ? ? {
                        id: t,
                        name: `${t[0].toUpperCase()}${t.slice(1)}`,
                        provider: `is${t[0].toUpperCase()}${t.slice(1)}`
                    }
                } : {
                    id: "injected",
                    name: "Injected",
                    provider: e => e ? .ethereum
                }
            }
            let i, o, s, a;
            return l => ({
                get icon() {
                    return r().icon
                },
                get id() {
                    return r().id
                },
                get name() {
                    return r().name
                },
                get supportsSimulation() {
                    return zm.test(this.id.toLowerCase())
                },
                type: Gm.type,
                async setup() {
                    const t = await this.getProvider();
                    t && e.target && (s || (s = this.onConnect.bind(this), t.on("connect", s)), i || (i = this.onAccountsChanged.bind(this), t.on("accountsChanged", i)))
                },
                async connect() {
                    let {
                        chainId: n,
                        isReconnecting: r
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const u = await this.getProvider();
                    if (!u) throw new bm;
                    let c = [];
                    if (r) c = await this.getAccounts().catch((() => []));
                    else if (t) try {
                        const e = await u.request({
                            method: "wallet_requestPermissions",
                            params: [{
                                eth_accounts: {}
                            }]
                        });
                        c = e[0] ? .caveats ? .[0] ? .value ? .map((e => (0, Li.b)(e)))
                    } catch (d) {
                        const e = d;
                        if (e.code === ho.code) throw new ho(e);
                        if (e.code === so.code) throw e
                    }
                    try {
                        if (!c ? .length && !r) {
                            c = (await u.request({
                                method: "eth_requestAccounts"
                            })).map((e => (0, Li.b)(e)))
                        }
                        s && (u.removeListener("connect", s), s = void 0), i || (i = this.onAccountsChanged.bind(this), u.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), u.on("chainChanged", o)), a || (a = this.onDisconnect.bind(this), u.on("disconnect", a));
                        let d = await this.getChainId();
                        if (n && d !== n) {
                            const e = await this.switchChain({
                                chainId: n
                            }).catch((e => {
                                if (e.code === ho.code) throw e;
                                return {
                                    id: d
                                }
                            }));
                            d = e ? .id ? ? d
                        }
                        return t && await (l.storage ? .removeItem(`${this.id}.disconnected`)), e.target || await (l.storage ? .setItem("injected.connected", !0)), {
                            accounts: c,
                            chainId: d
                        }
                    } catch (d) {
                        const e = d;
                        if (e.code === ho.code) throw new ho(e);
                        if (e.code === so.code) throw new so(e);
                        throw e
                    }
                },
                async disconnect() {
                    const n = await this.getProvider();
                    if (!n) throw new bm;
                    o && (n.removeListener("chainChanged", o), o = void 0), a && (n.removeListener("disconnect", a), a = void 0), s || (s = this.onConnect.bind(this), n.on("connect", s));
                    try {
                        await n.request({
                            method: "wallet_revokePermissions",
                            params: [{
                                eth_accounts: {}
                            }]
                        })
                    } catch {}
                    t && await (l.storage ? .setItem(`${this.id}.disconnected`, !0)), e.target || await (l.storage ? .removeItem("injected.connected"))
                },
                async getAccounts() {
                    const e = await this.getProvider();
                    if (!e) throw new bm;
                    return (await e.request({
                        method: "eth_accounts"
                    })).map((e => (0, Li.b)(e)))
                },
                async getChainId() {
                    const e = await this.getProvider();
                    if (!e) throw new bm;
                    const t = await e.request({
                        method: "eth_chainId"
                    });
                    return Number(t)
                },
                async getProvider() {
                    if ("undefined" === typeof window) return;
                    let e;
                    const t = r();
                    return e = "function" === typeof t.provider ? t.provider(window) : "string" === typeof t.provider ? Hm(window, t.provider) : t.provider, e && !e.removeListener && ("off" in e && "function" === typeof e.off ? e.removeListener = e.off : e.removeListener = () => {}), e
                },
                async isAuthorized() {
                    try {
                        if (t && await (l.storage ? .getItem(`${this.id}.disconnected`))) return !1;
                        if (!e.target) {
                            if (!await (l.storage ? .getItem("injected.connected"))) return !1
                        }
                        if (!await this.getProvider()) {
                            if (void 0 !== n && !1 !== n) {
                                const e = async () => {
                                        "undefined" !== typeof window && window.removeEventListener("ethereum#initialized", e);
                                        return !!await this.getProvider()
                                    },
                                    t = "number" === typeof n ? n : 1e3;
                                if (await Promise.race([..."undefined" !== typeof window ? [new Promise((t => window.addEventListener("ethereum#initialized", (() => t(e())), {
                                        once: !0
                                    })))] : [], new Promise((n => setTimeout((() => n(e())), t)))])) return !0
                            }
                            throw new bm
                        }
                        return !!(await wo((() => Um((() => this.getAccounts()), {
                            timeout: 100
                        })))).length
                    } catch {
                        return !1
                    }
                },
                async switchChain(e) {
                    let {
                        addEthereumChainParameter: t,
                        chainId: n
                    } = e;
                    const r = await this.getProvider();
                    if (!r) throw new bm;
                    const i = l.chains.find((e => e.id === n));
                    if (!i) throw new yo(new it);
                    try {
                        return await Promise.all([r.request({
                            method: "wallet_switchEthereumChain",
                            params: [{
                                chainId: (0, Sr.cK)(n)
                            }]
                        }).then((async () => {
                            await this.getChainId() === n && l.emitter.emit("change", {
                                chainId: n
                            })
                        })), new Promise((e => l.emitter.once("change", (t => {
                            let {
                                chainId: r
                            } = t;
                            r === n && e()
                        }))))]), i
                    } catch (o) {
                        const e = o;
                        if (4902 === e.code || 4902 === e ? .data ? .originalError ? .code) try {
                            const {
                                default: e,
                                ...o
                            } = i.blockExplorers ? ? {};
                            let s, a;
                            t ? .blockExplorerUrls ? s = t.blockExplorerUrls : e && (s = [e.url, ...Object.values(o).map((e => e.url))]), a = t ? .rpcUrls ? .length ? t.rpcUrls : [i.rpcUrls.default ? .http[0] ? ? ""];
                            const l = {
                                blockExplorerUrls: s,
                                chainId: (0, Sr.cK)(n),
                                chainName: t ? .chainName ? ? i.name,
                                iconUrls: t ? .iconUrls,
                                nativeCurrency: t ? .nativeCurrency ? ? i.nativeCurrency,
                                rpcUrls: a
                            };
                            await r.request({
                                method: "wallet_addEthereumChain",
                                params: [l]
                            });
                            if (await this.getChainId() !== n) throw new ho(new Error("User rejected switch after adding network."));
                            return i
                        } catch (s) {
                            throw new ho(s)
                        }
                        if (e.code === ho.code) throw new ho(e);
                        throw new yo(e)
                    }
                },
                async onAccountsChanged(e) {
                    if (0 === e.length) this.onDisconnect();
                    else if (l.emitter.listenerCount("connect")) {
                        const e = (await this.getChainId()).toString();
                        this.onConnect({
                            chainId: e
                        }), t && await (l.storage ? .removeItem(`${this.id}.disconnected`))
                    } else l.emitter.emit("change", {
                        accounts: e.map((e => (0, Li.b)(e)))
                    })
                },
                onChainChanged(e) {
                    const t = Number(e);
                    l.emitter.emit("change", {
                        chainId: t
                    })
                },
                async onConnect(e) {
                    const t = await this.getAccounts();
                    if (0 === t.length) return;
                    const n = Number(e.chainId);
                    l.emitter.emit("connect", {
                        accounts: t,
                        chainId: n
                    });
                    const r = await this.getProvider();
                    r && (s && (r.removeListener("connect", s), s = void 0), i || (i = this.onAccountsChanged.bind(this), r.on("accountsChanged", i)), o || (o = this.onChainChanged.bind(this), r.on("chainChanged", o)), a || (a = this.onDisconnect.bind(this), r.on("disconnect", a)))
                },
                async onDisconnect(e) {
                    const t = await this.getProvider();
                    e && 1013 === e.code && t && (await this.getAccounts()).length || (l.emitter.emit("disconnect"), t && (o && (t.removeListener("chainChanged", o), o = void 0), a && (t.removeListener("disconnect", a), a = void 0), s || (s = this.onConnect.bind(this), t.on("connect", s))))
                }
            })
        }

        function Hm(e, t) {
            function n(e) {
                return "function" === typeof t ? t(e) : "string" !== typeof t || e[t]
            }
            const r = e.ethereum;
            return r ? .providers ? r.providers.find((e => n(e))) : r && n(r) ? r : void 0
        }
        Gm.type = "injected";
        var $m = n(7283);
        class Qm {
            constructor(e) {
                Object.defineProperty(this, "uid", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: e
                }), Object.defineProperty(this, "_emitter", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: new $m
                })
            }
            on(e, t) {
                this._emitter.on(e, t)
            }
            once(e, t) {
                this._emitter.once(e, t)
            }
            off(e, t) {
                this._emitter.off(e, t)
            }
            emit(e) {
                const t = arguments.length <= 1 ? void 0 : arguments[1];
                this._emitter.emit(e, {
                    uid: this.uid,
                    ...t
                })
            }
            listenerCount(e) {
                return this._emitter.listenerCount(e)
            }
        }

        function Vm(e, t) {
            return JSON.parse(e, ((e, n) => {
                let r = n;
                return "bigint" === r ? .__type && (r = BigInt(r.value)), "Map" === r ? .__type && (r = new Map(r.value)), t ? .(e, r) ? ? r
            }))
        }

        function Km(e, t) {
            return e.slice(0, t).join(".") || "."
        }

        function Wm(e, t) {
            const {
                length: n
            } = e;
            for (let r = 0; r < n; ++r)
                if (e[r] === t) return r + 1;
            return 0
        }

        function Jm(e, t, n, r) {
            return JSON.stringify(e, function(e, t) {
                const n = "function" === typeof e,
                    r = "function" === typeof t,
                    i = [],
                    o = [];
                return function(s, a) {
                    if ("object" === typeof a)
                        if (i.length) {
                            const e = Wm(i, this);
                            0 === e ? i[i.length] = this : (i.splice(e), o.splice(e)), o[o.length] = s;
                            const n = Wm(i, a);
                            if (0 !== n) return r ? t.call(this, s, a, Km(o, n)) : `[ref=${Km(o,n)}]`
                        } else i[0] = a, o[0] = s;
                    return n ? e.call(this, s, a) : a
                }
            }(((e, n) => {
                let r = n;
                return "bigint" === typeof r && (r = {
                    __type: "bigint",
                    value: n.toString()
                }), r instanceof Map && (r = {
                    __type: "Map",
                    value: Array.from(n.entries())
                }), t ? .(e, r) ? ? r
            }), r), n ? ? void 0)
        }

        function Zm(e) {
            const {
                deserialize: t = Vm,
                key: n = "wagmi",
                serialize: r = Jm,
                storage: i = Ym
            } = e;

            function o(e) {
                return e instanceof Promise ? e.then((e => e)).catch((() => null)) : e
            }
            return { ...i,
                key: n,
                async getItem(e, r) {
                    const s = i.getItem(`${n}.${e}`),
                        a = await o(s);
                    return a ? t(a) ? ? null : r ? ? null
                },
                async setItem(e, t) {
                    const s = `${n}.${e}`;
                    null === t ? await o(i.removeItem(s)) : await o(i.setItem(s, r(t)))
                },
                async removeItem(e) {
                    await o(i.removeItem(`${n}.${e}`))
                }
            }
        }
        const Ym = {
                getItem: () => null,
                setItem: () => {},
                removeItem: () => {}
            },
            Xm = 256;
        let eg, tg = Xm;
        class ng extends Rr.C {
            constructor() {
                super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
                    docsPath: "/docs/clients/intro"
                })
            }
        }
        var rg = n(6510);

        function ig() {
            return {
                current: 0,
                take() {
                    return this.current++
                },
                reset() {
                    this.current = 0
                }
            }
        }
        const og = ig();

        function sg(e) {
            return {
                formatters: void 0,
                fees: void 0,
                serializers: void 0,
                ...e
            }
        }
        const ag = sg({
            id: 1,
            name: "Ethereum",
            nativeCurrency: {
                name: "Ether",
                symbol: "ETH",
                decimals: 18
            },
            rpcUrls: {
                default: {
                    http: ["https://cloudflare-eth.com"]
                }
            },
            blockExplorers: {
                default: {
                    name: "Etherscan",
                    url: "https://etherscan.io",
                    apiUrl: "https://api.etherscan.io/api"
                }
            },
            contracts: {
                ensRegistry: {
                    address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
                },
                ensUniversalResolver: {
                    address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
                    blockCreated: 19258213
                },
                multicall3: {
                    address: "0xca11bde05977b3631167028862be2a173976ca11",
                    blockCreated: 14353601
                }
            }
        });

        function lg(e) {
            const t = e.isNewChainsStale ? ? !0;
            let r, i;
            let o, s, a, l, u, c;
            return d => ({
                id: "walletConnect",
                name: "WalletConnect",
                type: lg.type,
                async setup() {
                    const e = await this.getProvider().catch((() => null));
                    e && (a || (a = this.onConnect.bind(this), e.on("connect", a)), u || (u = this.onSessionDelete.bind(this), e.on("session_delete", u)))
                },
                async connect() {
                    let {
                        chainId: e,
                        ...t
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    try {
                        const n = await this.getProvider();
                        if (!n) throw new bm;
                        l || (l = this.onDisplayUri, n.on("display_uri", l));
                        let r = e;
                        if (!r) {
                            const e = await (d.storage ? .getItem("state")) ? ? {},
                                t = d.chains.some((t => t.id === e.chainId));
                            r = t ? e.chainId : d.chains[0] ? .id
                        }
                        if (!r) throw new Error("No chains found on connector.");
                        const i = await this.isChainsStale();
                        if (n.session && i && await n.disconnect(), !n.session || i) {
                            const e = d.chains.filter((e => e.id !== r)).map((e => e.id));
                            await n.connect({
                                optionalChains: [r, ...e],
                                ..."pairingTopic" in t ? {
                                    pairingTopic: t.pairingTopic
                                } : {}
                            }), this.setRequestedChainsIds(d.chains.map((e => e.id)))
                        }
                        const h = (await n.enable()).map((e => (0, Li.b)(e))),
                            f = await this.getChainId();
                        return l && (n.removeListener("display_uri", l), l = void 0), a && (n.removeListener("connect", a), a = void 0), o || (o = this.onAccountsChanged.bind(this), n.on("accountsChanged", o)), s || (s = this.onChainChanged.bind(this), n.on("chainChanged", s)), c || (c = this.onDisconnect.bind(this), n.on("disconnect", c)), u || (u = this.onSessionDelete.bind(this), n.on("session_delete", u)), {
                            accounts: h,
                            chainId: f
                        }
                    } catch (n) {
                        if (/(user rejected|connection request reset)/i.test(n ? .message)) throw new ho(n);
                        throw n
                    }
                },
                async disconnect() {
                    const e = await this.getProvider();
                    try {
                        await (e ? .disconnect())
                    } catch (t) {
                        if (!/No matching key/i.test(t.message)) throw t
                    } finally {
                        s && (e ? .removeListener("chainChanged", s), s = void 0), c && (e ? .removeListener("disconnect", c), c = void 0), a || (a = this.onConnect.bind(this), e ? .on("connect", a)), o && (e ? .removeListener("accountsChanged", o), o = void 0), u && (e ? .removeListener("session_delete", u), u = void 0), this.setRequestedChainsIds([])
                    }
                },
                async getAccounts() {
                    return (await this.getProvider()).accounts.map((e => (0, Li.b)(e)))
                },
                async getProvider() {
                    let {
                        chainId: t
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    return r || (i || (i = async function() {
                        const t = d.chains.map((e => e.id));
                        if (!t.length) return;
                        const {
                            EthereumProvider: r
                        } = await Promise.all([n.e(444), n.e(432)]).then(n.bind(n, 1444));
                        return await r.init({ ...e,
                            disableProviderPing: !0,
                            optionalChains: t,
                            projectId: e.projectId,
                            rpcMap: Object.fromEntries(d.chains.map((e => [e.id, e.rpcUrls.default.http[0]]))),
                            showQrModal: e.showQrModal ? ? !0
                        })
                    }()), r = await i, r ? .events.setMaxListeners(1 / 0)), t && await (this.switchChain ? .({
                        chainId: t
                    })), r
                },
                async getChainId() {
                    return (await this.getProvider()).chainId
                },
                async isAuthorized() {
                    try {
                        const [e, t] = await Promise.all([this.getAccounts(), this.getProvider()]);
                        if (!e.length) return !1;
                        return !await this.isChainsStale() || !t.session || (await t.disconnect().catch((() => {})), !1)
                    } catch {
                        return !1
                    }
                },
                async switchChain(e) {
                    let {
                        addEthereumChainParameter: t,
                        chainId: n
                    } = e;
                    const r = await this.getProvider();
                    if (!r) throw new bm;
                    const i = d.chains.find((e => e.id === n));
                    if (!i) throw new yo(new it);
                    try {
                        await Promise.all([new Promise((e => {
                            const t = r => {
                                let {
                                    chainId: i
                                } = r;
                                i === n && (d.emitter.off("change", t), e())
                            };
                            d.emitter.on("change", t)
                        })), r.request({
                            method: "wallet_switchEthereumChain",
                            params: [{
                                chainId: (0, Sr.cK)(n)
                            }]
                        })]);
                        const e = await this.getRequestedChainsIds();
                        return this.setRequestedChainsIds([...e, n]), i
                    } catch (o) {
                        const e = o;
                        if (/(user rejected)/i.test(e.message)) throw new ho(e);
                        try {
                            let e, o;
                            e = t ? .blockExplorerUrls ? t.blockExplorerUrls : i.blockExplorers ? .default.url ? [i.blockExplorers ? .default.url] : [], o = t ? .rpcUrls ? .length ? t.rpcUrls : [...i.rpcUrls.default.http];
                            const s = {
                                blockExplorerUrls: e,
                                chainId: (0, Sr.cK)(n),
                                chainName: t ? .chainName ? ? i.name,
                                iconUrls: t ? .iconUrls,
                                nativeCurrency: t ? .nativeCurrency ? ? i.nativeCurrency,
                                rpcUrls: o
                            };
                            await r.request({
                                method: "wallet_addEthereumChain",
                                params: [s]
                            });
                            const a = await this.getRequestedChainsIds();
                            return this.setRequestedChainsIds([...a, n]), i
                        } catch (s) {
                            throw new ho(s)
                        }
                    }
                },
                onAccountsChanged(e) {
                    0 === e.length ? this.onDisconnect() : d.emitter.emit("change", {
                        accounts: e.map((e => (0, Li.b)(e)))
                    })
                },
                onChainChanged(e) {
                    const t = Number(e);
                    d.emitter.emit("change", {
                        chainId: t
                    })
                },
                async onConnect(e) {
                    const t = Number(e.chainId),
                        n = await this.getAccounts();
                    d.emitter.emit("connect", {
                        accounts: n,
                        chainId: t
                    })
                },
                async onDisconnect(e) {
                    this.setRequestedChainsIds([]), d.emitter.emit("disconnect");
                    const t = await this.getProvider();
                    o && (t.removeListener("accountsChanged", o), o = void 0), s && (t.removeListener("chainChanged", s), s = void 0), c && (t.removeListener("disconnect", c), c = void 0), u && (t.removeListener("session_delete", u), u = void 0), a || (a = this.onConnect.bind(this), t.on("connect", a))
                },
                onDisplayUri(e) {
                    d.emitter.emit("message", {
                        type: "display_uri",
                        data: e
                    })
                },
                onSessionDelete() {
                    this.onDisconnect()
                },
                getNamespaceChainsIds() {
                    if (!r) return [];
                    const e = r.session ? .namespaces.eip155 ? .chains ? .map((e => parseInt(e.split(":")[1] || "")));
                    return e ? ? []
                },
                async getRequestedChainsIds() {
                    return await (d.storage ? .getItem(this.requestedChainsStorageKey)) ? ? []
                },
                async isChainsStale() {
                    if (!t) return !1;
                    const e = d.chains.map((e => e.id)),
                        n = this.getNamespaceChainsIds();
                    if (n.length && !n.some((t => e.includes(t)))) return !1;
                    const r = await this.getRequestedChainsIds();
                    return !e.every((e => r.includes(e)))
                },
                async setRequestedChainsIds(e) {
                    await (d.storage ? .setItem(this.requestedChainsStorageKey, e))
                },
                get requestedChainsStorageKey() {
                    return `${this.id}.requestedChains`
                }
            })
        }
        lg.type = "walletConnect";
        const ug = function(e) {
            const {
                multiInjectedProviderDiscovery: t = !0,
                storage: n = Zm({
                    storage: "undefined" !== typeof window && window.localStorage ? window.localStorage : Ym
                }),
                syncConnectedChain: r = !0,
                ssr: i,
                ...o
            } = e, s = "undefined" !== typeof window && t ? Tm() : void 0, a = Dm((() => o.chains)), l = Dm((() => [...o.connectors ? ? [], ...i ? [] : s ? .getProviders().map(c) ? ? []].map(u)));

            function u(e) {
                const t = function(e) {
                        return new Qm(e)
                    }(function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 11;
                        if (!eg || tg + e > 2 * Xm) {
                            eg = "", tg = 0;
                            for (let e = 0; e < Xm; e++) eg += (256 + 256 * Math.random() | 0).toString(16).substring(1)
                        }
                        return eg.substring(tg, tg++ + e)
                    }()),
                    r = { ...e({
                            emitter: t,
                            chains: a.getState(),
                            storage: n
                        }),
                        emitter: t,
                        uid: t.uid
                    };
                return t.on("connect", y), r.setup ? .(), r
            }

            function c(e) {
                const {
                    info: t
                } = e, n = e.provider;
                return Gm({
                    target: { ...t,
                        id: t.rdns,
                        provider: n
                    }
                })
            }
            const d = new Map;

            function h() {
                return {
                    chainId: a.getState()[0].id,
                    connections: new Map,
                    current: null,
                    status: "disconnected"
                }
            }
            let f;
            const p = "0.0.0-canary-";
            f = Xe.startsWith(p) ? parseInt(Xe.replace(p, "")) : parseInt(Xe.split(".")[0] ? ? "0");
            const m = Dm(Rm(n ? Fm(h, {
                migrate(e, t) {
                    if (t === f) return e;
                    const n = h(),
                        r = e && "object" === typeof e && "chainId" in e && "number" === typeof e.chainId ? e.chainId : n.chainId;
                    return { ...n,
                        chainId: r
                    }
                },
                name: "store",
                partialize: e => ({
                    connections: {
                        __type: "Map",
                        value: Array.from(e.connections.entries()).map((e => {
                            let [t, n] = e;
                            const {
                                id: r,
                                name: i,
                                type: o,
                                uid: s
                            } = n.connector, a = {
                                id: r,
                                name: i,
                                type: o,
                                uid: s
                            };
                            return [t, { ...n,
                                connector: a
                            }]
                        }))
                    },
                    chainId: e.chainId,
                    current: e.current
                }),
                skipHydration: i,
                storage: n,
                version: f
            }) : h));

            function g(e) {
                m.setState((t => {
                    const n = t.connections.get(e.uid);
                    return n ? { ...t,
                        connections: new Map(t.connections).set(e.uid, {
                            accounts: e.accounts ? ? n.accounts,
                            chainId: e.chainId ? ? n.chainId,
                            connector: n.connector
                        })
                    } : t
                }))
            }

            function y(e) {
                "connecting" !== m.getState().status && "reconnecting" !== m.getState().status && m.setState((t => {
                    const n = l.getState().find((t => t.uid === e.uid));
                    return n ? (n.emitter.listenerCount("connect") && n.emitter.off("connect", g), n.emitter.listenerCount("change") || n.emitter.on("change", g), n.emitter.listenerCount("disconnect") || n.emitter.on("disconnect", v), { ...t,
                        connections: new Map(t.connections).set(e.uid, {
                            accounts: e.accounts,
                            chainId: e.chainId,
                            connector: n
                        }),
                        current: e.uid,
                        status: "connected"
                    }) : t
                }))
            }

            function v(e) {
                m.setState((t => {
                    const n = t.connections.get(e.uid);
                    if (n) {
                        const e = n.connector;
                        e.emitter.listenerCount("change") && n.connector.emitter.off("change", g), e.emitter.listenerCount("disconnect") && n.connector.emitter.off("disconnect", v), e.emitter.listenerCount("connect") || n.connector.emitter.on("connect", y)
                    }
                    if (t.connections.delete(e.uid), 0 === t.connections.size) return { ...t,
                        connections: new Map,
                        current: null,
                        status: "disconnected"
                    };
                    const r = t.connections.values().next().value;
                    return { ...t,
                        connections: new Map(t.connections),
                        current: r.connector.uid
                    }
                }))
            }
            return r && m.subscribe((e => {
                let {
                    connections: t,
                    current: n
                } = e;
                return n ? t.get(n) ? .chainId : void 0
            }), (e => {
                const t = a.getState().some((t => t.id === e));
                if (t) return m.setState((t => ({ ...t,
                    chainId: e ? ? t.chainId
                })))
            })), s ? .subscribe((e => {
                const t = new Map;
                for (const n of l.getState()) t.set(n.id, !0);
                const r = [];
                for (const n of e) {
                    const e = u(c(n));
                    t.has(e.id) || r.push(e)
                }
                n && !m.persist.hasHydrated() || l.setState((e => [...e, ...r]), !0)
            })), {
                get chains() {
                    return a.getState()
                },
                get connectors() {
                    return l.getState()
                },
                storage: n,
                getClient: function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const t = e.chainId ? ? m.getState().chainId,
                        n = a.getState().find((e => e.id === t));
                    if (e.chainId && !n) throw new it; {
                        const e = d.get(m.getState().chainId);
                        if (e && !n) return e;
                        if (!n) throw new it
                    } {
                        const e = d.get(t);
                        if (e) return e
                    }
                    let r;
                    if (o.client) r = o.client({
                        chain: n
                    });
                    else {
                        const e = n.id,
                            t = a.getState().map((e => e.id)),
                            i = {},
                            s = Object.entries(o);
                        for (const [n, r] of s)
                            if ("chains" !== n && "client" !== n && "connectors" !== n && "transports" !== n)
                                if ("object" === typeof r)
                                    if (e in r) i[n] = r[e];
                                    else {
                                        const e = t.some((e => e in r));
                                        if (e) continue;
                                        i[n] = r
                                    }
                        else i[n] = r;
                        r = Wi({ ...i,
                            chain: n,
                            batch: i.batch ? ? {
                                multicall: !0
                            },
                            transport: t => o.transports[e]({ ...t,
                                connectors: l
                            })
                        })
                    }
                    return d.set(t, r), r
                },
                get state() {
                    return m.getState()
                },
                setState(e) {
                    let t;
                    t = "function" === typeof e ? e(m.getState()) : e;
                    const n = h();
                    "object" !== typeof t && (t = n);
                    const r = Object.keys(n).some((e => !(e in t)));
                    r && (t = n), m.setState(t, !0)
                },
                subscribe: (e, t, n) => m.subscribe(e, t, n ? { ...n,
                    fireImmediately: n.emitImmediately
                } : void 0),
                _internal: {
                    mipd: s,
                    store: m,
                    ssr: Boolean(i),
                    syncConnectedChain: r,
                    transports: o.transports,
                    chains: {
                        setState(e) {
                            const t = "function" === typeof e ? e(a.getState()) : e;
                            if (0 !== t.length) return a.setState(t, !0)
                        },
                        subscribe: e => a.subscribe(e)
                    },
                    connectors: {
                        providerDetailToConnector: c,
                        setup: u,
                        setState: e => l.setState("function" === typeof e ? e(l.getState()) : e, !0),
                        subscribe: e => l.subscribe(e)
                    },
                    events: {
                        change: g,
                        connect: y,
                        disconnect: v
                    }
                }
            }
        }({
            chains: [ag],
            connectors: [lg({
                projectId: "8cff1ce28d43de0aef36256380727538",
                onError(e) {
                    console.error("WalletConnect Error:", e.message || e), e.message.includes("timeout") && alert("Connection timed out. Please try again.")
                }
            })],
            transports: {
                [ag.id]: function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const {
                        batch: n,
                        fetchOptions: r,
                        key: i = "http",
                        name: o = "HTTP JSON-RPC",
                        onFetchRequest: s,
                        onFetchResponse: a,
                        retryDelay: l
                    } = t;
                    return u => {
                        let {
                            chain: c,
                            retryCount: d,
                            timeout: h
                        } = u;
                        const {
                            batchSize: f = 1e3,
                            wait: p = 0
                        } = "object" === typeof n ? n : {}, m = t.retryCount ? ? d, g = h ? ? t.timeout ? ? 1e4, y = e || c ? .rpcUrls.default.http[0];
                        if (!y) throw new ng;
                        const v = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            return {
                                async request(n) {
                                    const {
                                        body: r,
                                        onRequest: i = t.onRequest,
                                        onResponse: o = t.onResponse,
                                        timeout: s = t.timeout ? ? 1e4
                                    } = n, a = { ...t.fetchOptions ? ? {},
                                        ...n.fetchOptions ? ? {}
                                    }, {
                                        headers: l,
                                        method: u,
                                        signal: c
                                    } = a;
                                    try {
                                        const t = await Um((async t => {
                                            let {
                                                signal: n
                                            } = t;
                                            const o = { ...a,
                                                    body: Array.isArray(r) ? (0, Bi.A)(r.map((e => ({
                                                        jsonrpc: "2.0",
                                                        id: e.id ? ? og.take(),
                                                        ...e
                                                    })))) : (0, Bi.A)({
                                                        jsonrpc: "2.0",
                                                        id: r.id ? ? og.take(),
                                                        ...r
                                                    }),
                                                    headers: { ...l,
                                                        "Content-Type": "application/json"
                                                    },
                                                    method: u || "POST",
                                                    signal: c || (s > 0 ? n : null)
                                                },
                                                d = new Request(e, o);
                                            return i && await i(d), await fetch(e, o)
                                        }), {
                                            errorInstance: new Ji.MU({
                                                body: r,
                                                url: e
                                            }),
                                            timeout: s,
                                            signal: !0
                                        });
                                        let n;
                                        if (o && await o(t), t.headers.get("Content-Type") ? .startsWith("application/json") ? n = await t.json() : (n = await t.text(), n = JSON.parse(n || "{}")), !t.ok) throw new Ji.Ci({
                                            body: r,
                                            details: (0, Bi.A)(n.error) || t.statusText,
                                            headers: t.headers,
                                            status: t.status,
                                            url: e
                                        });
                                        return n
                                    } catch (d) {
                                        if (d instanceof Ji.Ci) throw d;
                                        if (d instanceof Ji.MU) throw d;
                                        throw new Ji.Ci({
                                            body: r,
                                            details: d.message,
                                            url: e
                                        })
                                    }
                                }
                            }
                        }(y, {
                            fetchOptions: r,
                            onRequest: s,
                            onResponse: a,
                            timeout: g
                        });
                        return xo({
                            key: i,
                            name: o,
                            async request(t) {
                                let {
                                    method: r,
                                    params: i
                                } = t;
                                const o = {
                                        method: r,
                                        params: i
                                    },
                                    {
                                        schedule: s
                                    } = (0, rg.u)({
                                        id: `${e}`,
                                        wait: p,
                                        shouldSplitBatch: e => e.length > f,
                                        fn: e => v.request({
                                            body: e
                                        }),
                                        sort: (e, t) => e.id - t.id
                                    }),
                                    [{
                                        error: a,
                                        result: l
                                    }] = await (async e => n ? s(e) : [await v.request({
                                        body: e
                                    })])(o);
                                if (a) throw new Ji.J8({
                                    body: o,
                                    error: a,
                                    url: y
                                });
                                return l
                            },
                            retryCount: m,
                            retryDelay: l,
                            timeout: g,
                            type: "http"
                        }, {
                            fetchOptions: r,
                            url: y
                        })
                    }
                }({
                    onerror: e => {
                        console.error("HTTP Transport Error:", e.message || e)
                    }
                })
            }
        });
        window.addEventListener("unhandledrejection", (function(e) {
            e.reason.message.includes("Unsupported network") && console.error("Caught an unsupported network switch:", e.reason)
        }));
        const cg = function() {
            const e = new Om;
            return (0, he.jsx)(he.Fragment, {
                children: (0, he.jsx)(ft, {
                    config: ug,
                    children: (0, he.jsx)(We, {
                        client: e,
                        children: (0, he.jsx)(ue, {
                            children: (0, he.jsxs)(se, {
                                children: [(0, he.jsx)(ie, {
                                    path: "/",
                                    element: (0, he.jsx)(Cm, {})
                                }), (0, he.jsx)(ie, {
                                    path: "/claim",
                                    element: (0, he.jsx)(Cm, {})
                                })]
                            })
                        })
                    })
                })
            })
        };
        o.createRoot(document.getElementById("root")).render((0, he.jsx)(r.StrictMode, {
            children: (0, he.jsx)(cg, {})
        }))
    })()
})();
//# sourceMappingURL=main.e2909a3d.js.map